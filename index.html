<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-链表专题/">
                链表专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-链表专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-链表专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="keyword">next</span>;
    ListNode(<span class="keyword">int</span> x):val(x),<span class="keyword">next</span>(<span class="keyword">NULL</span>){}
};
</code></pre><h3 id="求链表中节点个数">求链表中节点个数</h3><pre><code><span class="keyword">int</span> getLength(ListNode* head)
{
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">while</span>(head)
    {
        head = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">count</span>++;
    }
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><h3 id="单链表翻转">单链表翻转</h3><pre><code><span class="constant">ListNode*</span> reverseList(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> newHead = <span class="constant">NULL;</span>
    <span class="constant">ListNode*</span> node = head;
    <span class="keyword">while</span>(node)
    {
        <span class="constant">ListNode*</span> temp = node-&gt;<span class="keyword">next</span>;
        node-&gt;<span class="keyword">next</span> = newHead;
        newHead = node;
        node = temp-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中倒数第k个节点">查找链表中倒数第k个节点</h3><pre><code>ListNode* getLastK(ListNode* head, <span class="built_in">int</span> k)
{
    ListNode* fisrt = head;
    ListNode* <span class="built_in">second</span> = head;
    <span class="keyword">while</span>(k--)
    {
        <span class="keyword">if</span>(first)
            first = first-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            return <span class="literal">NULL</span>;
    }
    <span class="keyword">while</span>(first)
    {
        fisrt = first-&gt;<span class="keyword">next</span>;
        <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>;
    }
    return <span class="built_in">second</span>;
}
</code></pre><h3 id="删除链表中第k个节点">删除链表中第k个节点</h3><pre><code>ListNode* deleteK(ListNode* head, <span class="keyword">int</span> k)
{
    <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)
        <span class="keyword">return</span> head;
    ListNode* toBeDelete;
    ListNode* newHead;
    <span class="keyword">if</span>(k == <span class="number">1</span>)
    {
        toBeDelete = head;
        newHead = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">delete</span> toBeDelete;
        <span class="keyword">return</span> newHead;
    }
    newHead = head;
    ListNode* node = head;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">2</span>; i++)
    {
        <span class="keyword">if</span>(node)
            node = node-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> newHead;
    }
    <span class="keyword">if</span>(node == <span class="keyword">NULL</span> || node-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)
        <span class="keyword">return</span> newHead;
    toBeDelete = node-&gt;<span class="keyword">next</span>;
    node-&gt;<span class="keyword">next</span> = node-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    <span class="keyword">delete</span> toBeDelete;
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中间节点">查找链表中间节点</h3><pre><code><span class="constant">ListNode*</span> findMiddle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> first = head;
    <span class="constant">ListNode*</span> second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = fisrt-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        if(first)
            second = second-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> second;
}
</code></pre><h3 id="从尾到头打印链表">从尾到头打印链表</h3><pre><code>void reversePrint(<span class="type">ListNode</span>* head)
{
    <span class="type">ListNode</span>* node = head;
    stack&lt;<span class="type">ListNode</span>*&gt; s;
    <span class="keyword">while</span>(node)
    {
        s.push(node);
        node = node-&gt;next;
    }
    <span class="keyword">while</span>(!s.empty<span class="literal">()</span>)
    {
        cout&lt;&lt;s.top<span class="literal">()</span>-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">" "</span>;
        s.pop<span class="literal">()</span>;
    }
}
</code></pre><h3 id="单链表排序，选择排序">单链表排序，选择排序</h3><pre><code>void sortList(<span class="type">ListNode</span>* head)
{
    <span class="keyword">for</span>(<span class="type">ListNode</span>* p = head; p != <span class="type">NULL</span>; p = p-&gt;next)
    {
        <span class="type">ListNode</span>* min = p;
        <span class="keyword">for</span>(<span class="type">ListNode</span>* q = p-&gt;next; q != <span class="type">NULL</span>; q = q-&gt;next)
        {
            <span class="keyword">if</span>(q-&gt;<span class="keyword">val</span> &lt; min-&gt;<span class="keyword">val</span>)
                min = q;
        }
        <span class="built_in">int</span> temp = p-&gt;<span class="keyword">val</span>;
        p-&gt;<span class="keyword">val</span> = min-&gt;<span class="keyword">val</span>;
        min-&gt;<span class="keyword">val</span> = temp;
    }
}
</code></pre><h3 id="合并两个有序链表">合并两个有序链表</h3><pre><code>ListNode<span class="subst">*</span> mergeList(ListNode<span class="subst">*</span> list1, ListNode<span class="subst">*</span> list2)
{
    <span class="keyword">if</span>(list1 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list2;
    <span class="keyword">if</span>(list2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list1;
    ListNode<span class="subst">*</span> head <span class="subst">=</span> <span class="built_in">NULL</span>;
    ListNode <span class="subst">*</span>node1 <span class="subst">=</span> list1, <span class="subst">*</span>node2 <span class="subst">=</span> list2;
    ListNode <span class="subst">*</span>tnode <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
    {
        head <span class="subst">=</span> node1;
        node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
    }
    <span class="keyword">else</span>
    {
        head <span class="subst">=</span> node2;
        node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
    }
    tnode <span class="subst">=</span> head;
    tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">while</span>(node1 <span class="subst">&amp;&amp;</span> node2)
    {
        <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
            node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
        <span class="keyword">else</span>
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
            node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
    }
    <span class="keyword">if</span>(node1)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
    <span class="keyword">if</span>(node2)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
    <span class="keyword">return</span> head;
}
</code></pre><h3 id="判断一个链表是否有环">判断一个链表是否有环</h3><pre><code>bool hasCircle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode </span>*first = head, *second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = first-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        second = second-&gt;<span class="keyword">next</span>;
        if(first == second)
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="判断两个链表是否相交">判断两个链表是否相交</h3><pre><code>bool isJoin(<span class="constant">ListNode </span>*list1, <span class="constant">ListNode </span>*list2)
{
    if(list1 == <span class="constant">NULL </span>|| list2 == <span class="constant">NULL)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="constant">ListNode </span>*n1 = list1, *n2 = list2;
    <span class="keyword">while</span>(n1-&gt;<span class="keyword">next</span>)
        n1 = n1-&gt;<span class="keyword">next</span>;
    <span class="keyword">while</span>(n2-&gt;<span class="keyword">next</span>)
        n2 = n2-&gt;<span class="keyword">next</span>;
    <span class="keyword">return</span> (n1 == n2);
}
</code></pre><h3 id="判断两个链表相交的第一个节点">判断两个链表相交的第一个节点</h3><ol>
<li>判断两个链表是否相交，得到两个链表长度len1,len2</li>
<li>假设len1 &gt; len2，n1先走(len1-len2)步</li>
<li>n1,n2一起走，直到n1 == n2</li>
</ol>
<h3 id="如果一个链表有环，求进入环中的第一个节点">如果一个链表有环，求进入环中的第一个节点</h3><ol>
<li>使用上面的方法判断是否有环</li>
<li>在环中走一圈得到环的长度len</li>
<li>前后两个节点一个先走len步（走一个环的长度），两个一起走相遇在环的入口</li>
</ol>
<h3 id="在O(1)的时间内删除节点">在O(1)的时间内删除节点</h3><pre><code><span class="literal">void</span> deleteInO1(ListNode<span class="subst">*</span> <span class="built_in">list</span>, ListNode<span class="subst">*</span> toBeDelete)
{
    <span class="keyword">if</span>(<span class="built_in">list</span> <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> toBeDelete <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="keyword">if</span>(toBeDelete <span class="subst">==</span> <span class="built_in">list</span>)
    {
        <span class="built_in">list</span> <span class="subst">=</span> <span class="built_in">list</span><span class="subst">-&gt;</span>next;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    <span class="keyword">if</span>(toBeDelete<span class="subst">-&gt;</span>next <span class="subst">==</span> <span class="built_in">NULL</span>)
    {
        ListNode<span class="subst">*</span> node <span class="subst">=</span> <span class="built_in">list</span>;
        <span class="keyword">while</span>(node <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>next <span class="subst">!=</span> toBeDelete)
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>next;
        node<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    ListNode<span class="subst">*</span> temp <span class="subst">=</span> toBeDelete<span class="subst">-&gt;</span>next;
    toBeDelete<span class="subst">-&gt;</span>val <span class="subst">=</span> temp<span class="subst">-&gt;</span>val;
    toBeDelete<span class="subst">-&gt;</span>next <span class="subst">=</span> temp<span class="subst">-&gt;</span>next;
    delete temp;
    <span class="keyword">return</span> ;
}
</code></pre><h2 id="特殊题目">特殊题目</h2><h3 id="剑指offer57_删除链表中的重复节点">剑指offer57 删除链表中的重复节点</h3><h4 id="问题描述">问题描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法">解法</h4><p>使用preNode和node指向最后一个未删除的节点和第一个可能删除的节点</p>
<ul>
<li>如果保留重复元素的第一个<br>只需要使用node扫描一次，判断和preNode-&gt;val是否相等，分两种情况处理即可</li>
<li>如果不保留重复元素<br>需要确定新的头元素newHead,需要判断是否重复，因为需要全部删除。</li>
</ul>
<h4 id="类型1的代码">类型1的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode *deleteDuplicates(ListNode *head) {
        <span class="keyword">if</span>(<span class="keyword">NULL</span> == head || <span class="keyword">NULL</span>==head-&gt;next)
            <span class="keyword">return</span> head;
        ListNode *preNode = head;
        ListNode *node = preNode-&gt;next;
        <span class="keyword">while</span>(node)
        {
            <span class="keyword">if</span>(node-&gt;val == preNode-&gt;val)
            {
                ListNode* temp = node;
                node = node-&gt;next;
                preNode-&gt;next = node;
                delete temp;
            }
            <span class="keyword">else</span>
            {
                node = node-&gt;next;
                preNode = preNode-&gt;next;
            }
        }
        <span class="keyword">return</span> head;
    }
};
</code></pre><h4 id="类型2的代码">类型2的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> head;
        ListNode *node = head;
        ListNode *newHead = <span class="keyword">NULL</span>;
        ListNode *preNode = <span class="keyword">NULL</span>;
        <span class="keyword">while</span>(node)
        {
            bool isDuplicated = <span class="keyword">false</span>;
            <span class="keyword">if</span>(node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)
                isDuplicated = <span class="keyword">true</span>;
            <span class="keyword">if</span>(isDuplicated)
            {
                int val = node-&gt;val;
                <span class="keyword">while</span>(node!= <span class="keyword">NULL</span> &amp;&amp; node-&gt;val == val)
                {
                    ListNode *temp = node;
                    node = node-&gt;next;
                    delete temp;
                }
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(!newHead)
                {
                    newHead = node;
                    preNode = node;
                }
                <span class="keyword">else</span>
                {
                    preNode-&gt;next = node;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
        }
        <span class="keyword">if</span>(preNode)
            preNode-&gt;next = <span class="keyword">NULL</span>;
        <span class="keyword">return</span> newHead;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/链表/"> #链表 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-一般题目/">
                找工作总结-二叉树专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/">
                找工作总结-二叉树专题-二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-二叉查找树/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-基础/">
                找工作总结-二叉树专题-基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/09/找工作总结-栈和队列专题/">
                栈和队列专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/09/找工作总结-栈和队列专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/09/找工作总结-栈和队列专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法">解法</h4><p>两个栈stack1,stack2。完成push和pop函数即可。</p>
<ul>
<li>push的时候向stack1压栈。</li>
<li>pop的时候<br>(1)stack2不为空，弹出stack2.top<br>(2)stack1不为空，把stack1中的元素全部弹出到stack2，然后弹出stack2.top<br>(3)如果stack1和stack2都是空，那么抛出异常<h4 id="注意点">注意点</h4></li>
<li>模板的写法</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">MyQueue</span>
{
public:
    <span class="type">void</span> push(<span class="keyword">const</span> T&amp; item);
    T pop();
private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> <span class="type">MyQueue</span>::push(<span class="keyword">const</span> T&amp; item)
{
    stack1.push(item);
}

<span class="keyword">template</span>&lt;typename T&gt;
T <span class="type">MyQueue</span>::pop()
{
    <span class="keyword">if</span>(!stack2.empty())
    {
        T temp = stack2.top();//?是否需要引用
        stack2.pop();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(!stack1.empty())
    {
        <span class="keyword">while</span>(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }
    <span class="keyword">else</span>
        throw exception(<span class="string">"MyQueue is empty!"</span>);
}
</code></pre><h4 id="扩展问题，使用两个队列实现栈">扩展问题，使用两个队列实现栈</h4><p>有queue1，queue2两个队列，完成push,pop。</p>
<ul>
<li>push<br>如果queue1.empty &amp;&amp; queue.empty 向queue1中push<br>如果有一个不为空，向不为空的队列里push</li>
<li>pop<br>如果queue1.empty &amp;&amp; queue.empty 抛出异常<br>把不为空的队列出队到空队列，直到剩下一个元素，弹出这个元素</li>
</ul>
<h3 id="剑指offer21_包含min函数的栈">剑指offer21 包含min函数的栈</h3><h4 id="问题描述-1">问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解法-1">解法</h4><p>使用stack1,stack2两个栈，stack1压入原本的元素，stack2只压最小元素</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">int</span> tempMin;
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            tempMin = <span class="keyword">value</span>;
        <span class="keyword">else</span>
        {
            tempMin = s2.top();
            <span class="keyword">if</span>(<span class="keyword">value</span> &lt; tempMin)
                tempMin = <span class="keyword">value</span>;
        }
        s1.push(<span class="keyword">value</span>);
        s2.push(tempMin);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">pop</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span>;
        s1.pop();
        s2.pop();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s1.top();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">min</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s2.top();
    }
<span class="keyword">private</span>:
    stack&lt;<span class="keyword">int</span>&gt; s1;
    stack&lt;<span class="keyword">int</span>&gt; s2;
};
</code></pre><h3 id="剑指offer22_栈的压入弹出序列">剑指offer22 栈的压入弹出序列</h3><h4 id="问题描述-2">问题描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h4 id="解法-2">解法</h4><p>使用一个栈stack进行模拟，遍历数组元素：</p>
<ul>
<li>如果<code>vec[i] != stack.top</code>，压入</li>
<li>如果<code>vec[i] == stack.top</code>，弹出</li>
<li><code>i == vec.size</code>时，判断栈是否为空</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    bool IsPopOrder<span class="params">(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)</span> {
        <span class="keyword">if</span><span class="params">(pushV.size<span class="params">()</span> != popV.size<span class="params">()</span>)</span>
            return <span class="literal">false</span>;
        stack&lt;int&gt; s;
        int i=<span class="number">0</span>,j=<span class="number">0</span>;
        <span class="keyword">for</span><span class="params">(;j &lt; popV.size<span class="params">()</span>; j++)</span>
        {
            while<span class="params">(s.empty<span class="params">()</span> || <span class="params">(i &lt; pushV.size<span class="params">()</span> &amp;&amp; s.top<span class="params">()</span> != popV[j])</span>)</span>
                s.push<span class="params">(pushV[i++])</span>;
            <span class="keyword">if</span><span class="params">(s.top<span class="params">()</span> == popV[j])</span>
                s.pop<span class="params">()</span>;
            <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span>)</span>
                break;
        }
        <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span> &amp;&amp; j == popV.size<span class="params">()</span> &amp;&amp; s.empty<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="剑指offer65_滑动窗口最大值">剑指offer65 滑动窗口最大值</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解法-3">解法</h4><p>使用双端队列(dequeue)记录当前窗口最大值<strong>下标</strong>序列，每插入一个元素就向前删除。通过比较dequeue的第一个元素是当前窗口的最大元素<strong>下标</strong>，比较首元素下标和i-size判断删除队列头部元素。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>从后向前删除</li>
<li>最后一个窗口</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; maxInWindows(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, unsigned <span class="type">int</span> size)
    {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(num.size() &lt; size || size &lt; <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        deque&lt;<span class="type">int</span>&gt; indexes;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)
        {
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            indexes.push_back(i);
        }

        <span class="keyword">for</span>(<span class="type">int</span> i = size;i &lt; num.size(); i++)
        {
            <span class="literal">result</span>.push_back(num[indexes.front()]);
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; indexes.front() &lt;= (i-size))
                indexes.pop_front();
            indexes.push_back(i);
        }
        <span class="literal">result</span>.push_back(num[indexes.front()]);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/栈和队列/"> #栈和队列 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/03/找工作总结-数组专题-两个指针/">
                数组专题-两个指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-02
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/03/找工作总结-数组专题-两个指针/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/03/找工作总结-数组专题-两个指针/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="通用解题思路">通用解题思路</h1><ul>
<li>使用快排中的partition函数</li>
<li>贪心,left++,right-直到相遇</li>
<li>二分查找，mid = (left + right) / 2</li>
</ul>
<h2 id="k-sum问题">k-sum问题</h2><p>k-sum问题解题思路:<br>先对数组进行排序(nlogn)。退化成2-sum问题，使用left,right指针向中间查找。最终把复杂度优化到O(n^(k-1))</p>
<h3 id="剑指offer41_和为S的两个数字_VS_和为S的连续正数序列">剑指offer41 和为S的两个数字 VS 和为S的连续正数序列</h3><h4 id="问题描述">问题描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<h4 id="解法">解法</h4><p>2-sum问题，乘积最小的两个数字就是left和right第一次满足条件的两个数字。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    vector&lt;<span class="built_in">int</span> &gt; FindNumbersWithSum(vector&lt;<span class="built_in">int</span>&gt; <span class="built_in">array</span>,<span class="built_in">int</span> sum) {
        vector&lt;<span class="built_in">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) return vec;
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &lt; sum)
                <span class="built_in">left</span>++;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &gt; sum)
                <span class="built_in">right</span>--;
            <span class="keyword">else</span>
            {
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">left</span>]);
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">right</span>]);
                return vec;
            }
        }
        return vec;
    }
};
</code></pre><h4 id="问题描述-1">问题描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<h4 id="解法-1">解法</h4><p>同上，不过比较条件变成。(left+right)(right-left+1)/2</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(sum &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;
        <span class="keyword">while</span>(right &lt;= (sum + <span class="number">1</span>) / <span class="number">2</span>)
        {
            <span class="keyword">int</span> temp = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(temp &lt; sum)
                right++;
            <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; sum)
                left++;
            <span class="keyword">else</span>
            {
                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)
                    vec.push_back(i);
                <span class="built_in">list</span>.push_back(vec);
                right++;
            }
        }
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }
};
</code></pre><h3 id="leetcode18_4Sum">leetcode18 4Sum</h3><h4 id="问题描述-2">问题描述</h4><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<ul>
<li>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)</li>
<li><p>The solution set must not contain duplicate quadruplets.</p>
<pre><code>For example, given<span class="instruction"> array </span>S = {1 0 -1 0 -2 2},<span class="instruction"> and </span>target = 0.

A solution set is:
(-1,  0, 0, 1<span class="function">)</span>
(-2, -1, 1, 2<span class="function">)</span>
(-2,  0, 0, 2<span class="function">)</span>
</code></pre></li>
</ul>
<h4 id="解法-2">解法</h4><p>先排序，退化到2-sum问题。</p>
<h4 id="注意点">注意点</h4><p>题目要求找出所有满足条件的数组，需要避免重复。</p>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//思路：K-Sum问题，复杂度降到O(n^(k-1))</span>
<span class="comment">//注意，不能重复，num个数不够4</span>
<span class="comment">//去重，left，right去重，i层循环去重，j层循环去重</span>
    vector&lt;vector&lt;<span class="built_in">int</span>&gt; &gt; fourSum(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>, <span class="built_in">int</span> target) {
        sort(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());
        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; list;
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() &lt; <span class="number">4</span>) 
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.size()-<span class="number">3</span>; i++)
        {
            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num</span>.size()- <span class="number">2</span>; j++)
            {
                <span class="built_in">int</span> left = j + <span class="number">1</span>, right = <span class="built_in">num</span>.size() - <span class="number">1</span>;
                <span class="keyword">while</span>(left &lt; right)
                {
                    <span class="built_in">int</span> sum = <span class="built_in">num</span>[i]+<span class="built_in">num</span>[j]+<span class="built_in">num</span>[left]+<span class="built_in">num</span>[right];
                    <span class="keyword">if</span>(sum &lt; target)
                        left++;
                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)
                        right--;
                    <span class="keyword">else</span>
                    {
                        vector&lt;<span class="built_in">int</span>&gt; vec;
                        vec.push_back(<span class="built_in">num</span>[i]);
                        vec.push_back(<span class="built_in">num</span>[j]);
                        vec.push_back(<span class="built_in">num</span>[left]);
                        vec.push_back(<span class="built_in">num</span>[right]);
                        list.push_back(vec);
                        left++;
                        right--; 
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[left] == <span class="built_in">num</span>[left - <span class="number">1</span>]) 
                            left++;
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[right] == <span class="built_in">num</span>[right + <span class="number">1</span>]) 
                            right--;
                    }
                }
                <span class="keyword">while</span>(j + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">2</span> &amp;&amp; <span class="built_in">num</span>[j] == <span class="built_in">num</span>[j + <span class="number">1</span>]) 
                    j++;
            }
            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">3</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i+<span class="number">1</span>]) 
                i++;
        }
        <span class="keyword">return</span> list;
    }
};
</code></pre><h2 id="二分查找问题">二分查找问题</h2><p>二分查找通用解题思路，left=头指针，right=尾指针，mid=(left+right)/2，通过条件判断，移动left和right最终使得left和right相遇得到最终结果。</p>
<h3 id="普通二分查找">普通二分查找</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个<strong>有序数组，可能含有重复元素</strong>。给定target，寻找target出现的下标，不存在返回-1.</p>
<h4 id="代码-3">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] == target)
            return <span class="built_in">mid</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><h3 id="等于target的第一个元素">等于target的第一个元素</h3><h4 id="问题描述-4">问题描述</h4><p>给定有序数组a,含有重复元素，求最小(或者求最大)的使得a[i]等于target的下标。不存在返回-1.<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnyv9bn30j20fg057q2z.jpg" alt=""></p>
<h4 id="代码-4">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] == target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="小于target的第一个元素">小于target的第一个元素</h3><h4 id="问题描述-5">问题描述</h4><p>给定有序数组a,含有重复元素，求最大的i使得a[i]小于target。不存在返回-1<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewnyykveyaj20bt04edfv.jpg" alt=""></p>
<h4 id="代码-5">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &gt;= target)
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] &lt; target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="求target在数组中的出现次数">求target在数组中的出现次数</h3><h4 id="解法-3">解法</h4><p>出现次数 = 最后一次出现位置 - 第一次出现位置 + 1<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnz2xlz25j20ep05ewek.jpg" alt=""></p>
<h4 id="代码-6">代码</h4><pre><code><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N, <span class="keyword">int</span> <span class="keyword">target</span>)</span>
</span>{
    <span class="keyword">int</span> first = searchFisrt(a, N, <span class="keyword">target</span>);
    <span class="keyword">if</span>(first == -<span class="number">1</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> last = searchLast(a, N, <span class="keyword">target</span>);
    <span class="keyword">return</span> (last - first + <span class="number">1</span>);
}
</code></pre><h3 id="插入的位置（小于等于target的第一个元素）">插入的位置（小于等于target的第一个元素）</h3><h4 id="问题描述-6">问题描述</h4><p>给定有序数组a,含有重复元素，若target在数组中出现，返回位置，如果不存在，返回应该插入的位置。</p>
<h4 id="解法-4">解法</h4><p>&lt;=target是可能的位置<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1ewo0ah8apsj20cf03lgln.jpg" alt=""></p>
<h4 id="代码-7">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt;= target)
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>; 
    }
    return <span class="built_in">left</span>;
}
</code></pre><h2 id="旋转数组的二分查找">旋转数组的二分查找</h2><h3 id="leetcode_33_Search_in_Rotated_Sorted_Array">leetcode 33 Search in Rotated Sorted Array</h3><h4 id="问题描述-7">问题描述</h4><p>给定有序数组，在某一个位置发生旋转，求target在数组中出现的位置。<strong>无重复元素</strong>，找到返回下标，找不到返回-1.</p>
<h4 id="解法-5">解法</h4><p>先判断mid落在了旋转数组的哪一部分，然后判断和target的关系<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewo177qwiyj20c507cq32.jpg" alt=""></p>
<h4 id="代码-8">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int <span class="keyword">left</span> = <span class="number">0</span>,<span class="keyword">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)
        {
            int mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[mid] == target)
                <span class="keyword">return</span> mid;
            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="keyword">left</span>])<span class="comment">//left-mid升序</span>
            {
                <span class="keyword">if</span>(nums[<span class="keyword">left</span>] &lt;= target &amp;&amp; target &lt; nums[mid])
                    <span class="keyword">right</span> = mid-<span class="number">1</span> ;
                <span class="keyword">else</span>
                    <span class="keyword">left</span> = mid+<span class="number">1</span>;
            }
            <span class="keyword">else</span><span class="comment">//mid-right升序</span>
            {
                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="keyword">right</span>])
                    <span class="keyword">left</span> = mid +<span class="number">1</span>;
                <span class="keyword">else</span>
                {
                    <span class="keyword">right</span> = mid-<span class="number">1</span>;
                }
            }
        }
        <span class="keyword">if</span>(nums[<span class="keyword">left</span>] == target)
            <span class="keyword">return</span> <span class="keyword">left</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> -<span class="number">1</span>;
    }
};
</code></pre><h3 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h3><h4 id="问题描述-8">问题描述</h4><p>其他条件相同，但允许数组中存在重复元素。判断target是否出现在数组中。</p>
<h4 id="解法-6">解法</h4><p>增加判断条件，当a[left] = a[mid] = a[right]，直接遍历去寻找，不能使用二分查找</p>
<h4 id="代码-9">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> target) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>,<span class="built_in">right</span> = nums.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == target)
                return <span class="literal">true</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == nums[<span class="built_in">left</span>] &amp;&amp; nums[<span class="built_in">mid</span>] == nums[<span class="built_in">right</span>])
            {
                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; i++)
                {
                    <span class="keyword">if</span>(nums[i] == target)
                        return <span class="literal">true</span>;
                }
                return <span class="literal">false</span>;
            }
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt;= nums[<span class="built_in">left</span>])
            {
                <span class="keyword">if</span>(target &gt;= nums[<span class="built_in">left</span>] &amp;&amp; target &lt; nums[<span class="built_in">mid</span>])
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(target &gt; nums[<span class="built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="built_in">right</span>])
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
            }
        }
        <span class="keyword">if</span>(nums[<span class="built_in">left</span>] == target)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="leetcode_153_Find_Minimum_in_Rotated_Sorted_Array">leetcode 153    Find Minimum in Rotated Sorted Array</h3><h4 id="问题描述-9">问题描述</h4><p>给定有序数组，<strong>无重复元素</strong>，在某一位置发生旋转，求数组中的最小元素</p>
<h4 id="解法-7">解法</h4><p>同上<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewo7wvjpz5j20as05ugln.jpg" alt=""></p>
<h4 id="注意点-1">注意点</h4><ul>
<li>对于数组旋转个数为0的考虑<br>如果使用a[mid] &gt;= a[left]判断，需要考虑数组是否并没有旋转(a[left] &lt; a[right])</li>
<li>也可以使用这样的条件进行判断 a[mid] &gt; a[right]</li>
</ul>
<h4 id="代码-10">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h3 id="leetcode_Find_Minimum_in_Rotated_Sorted_Array_II">leetcode Find Minimum in Rotated Sorted Array II</h3><h4 id="问题描述-10">问题描述</h4><p>同上，不过允许数组中存在重复元素</p>
<h4 id="解法-8">解法</h4><p>对a[mid] = a[right]时，right—。因为a[left] &lt;= a[right] == a[mid],为了使得a[mid]最小，需要对使得left和right逐渐接近，需要遍历才能找到，所以对right进行减一操作。</p>
<h4 id="代码-11">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span>--;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h2 id="一般题目">一般题目</h2><h3 id="剑指offer14_调整数组顺序使奇数位于偶数之前">剑指offer14 调整数组顺序使奇数位于偶数之前</h3><h4 id="问题描述-11">问题描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="解法-9">解法</h4><ul>
<li>使用插入排序的思想，复杂度O(n^2)</li>
<li>使用额外的O(n)存储，遍历原数组，计数从前往后放，偶数从后往前放。时间复杂度O(n)</li>
<li>补充，如果不需要保证相对位置，可以使用快排的partition函数做一次扫描。</li>
</ul>
<h4 id="方法2的代码">方法2的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">array</span>) {
        vector&lt;<span class="built_in">int</span>&gt; vec(<span class="built_in">array</span>.size());
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="built_in">int</span> leftIndex = <span class="number">0</span>, rightIndex = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
                vec[leftIndex++] = <span class="built_in">array</span>[<span class="built_in">left</span>++];
        }
        <span class="keyword">while</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">if</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
                vec[rightIndex--] = <span class="built_in">array</span>[<span class="built_in">right</span>--];
        }
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
            <span class="built_in">array</span>[i] = vec[i];
    }  
};
</code></pre><h4 id="方法3的代码">方法3的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
            {
                <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
                <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
                <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            }
        }
    }
};
</code></pre><h3 id="剑指offer36_数组中的逆序对">剑指offer36 数组中的逆序对</h3><h4 id="问题描述-12">问题描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="解法-10">解法</h4><p>使用归并排序的merge过程，统计逆序对的个数。merge过程需要merge,left~mid和mid~right。假如vec[lpos] &gt; vec[rpos],逆序对的个数需要增加<strong>mid-lpos+1</strong>个，因为vec中所有lpos之后的元素和rpos对应的元素都形成了逆序对。</p>
<h4 id="代码-12">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> InversePairs(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; temp(<span class="type">data</span>.<span class="built_in">size</span>());
        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;
        mergeSort(<span class="type">data</span>, temp, <span class="number">0</span>, <span class="type">data</span>.<span class="built_in">size</span>()-<span class="number">1</span>, <span class="built_in">count</span>);
        <span class="keyword">return</span> <span class="built_in">count</span>;
    }

    void mergeSort(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="keyword">if</span>(left &lt; right)
        {
            <span class="built_in">int</span> mid = (left + right) / <span class="number">2</span>;
            mergeSort(<span class="type">data</span>, temp, left, mid, <span class="built_in">count</span>);
            mergeSort(<span class="type">data</span>, temp, mid + <span class="number">1</span>, right, <span class="built_in">count</span>);
            <span class="built_in">merge</span>(<span class="type">data</span>, temp, left, mid, right, <span class="built_in">count</span>);
        }
    }

    void <span class="built_in">merge</span>(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> mid, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="built_in">int</span> lend = mid, rend = right;
        <span class="built_in">int</span> lpos = left, rpos = mid + <span class="number">1</span>, tpos = left;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(<span class="type">data</span>[lpos] &lt;= <span class="type">data</span>[rpos])
                temp[tpos++] = <span class="type">data</span>[lpos++];
            <span class="keyword">else</span>
            {
                <span class="built_in">count</span> += mid-lpos+<span class="number">1</span>;
                temp[tpos++] = <span class="type">data</span>[rpos++];
            }
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++]=<span class="type">data</span>[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = <span class="type">data</span>[rpos++];
        for(<span class="built_in">int</span> i = left; i &lt;= right; i++)
            <span class="type">data</span>[i] = temp[i];
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/两个指针/"> #两个指针 </a>
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-出现次数/">
                数组专题-数组中出现的次数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-出现次数/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-出现次数/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="通用的几种解题思路">通用的几种解题思路</h2><ul>
<li>使用map记录出现的次数，要求额外增加空间复杂度</li>
<li>所有数字异或可以消灭掉数组中出现偶数次的数字</li>
</ul>
<h3 id="剑指offer51_数组中重复的数字">剑指offer51 数组中重复的数字</h3><h4 id="问题描述">问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h4 id="解法">解法</h4><ul>
<li>排序后扫描，时间复杂度nlogn，空间复杂度O(1)</li>
<li>使用map记录，时间复杂度O(n)，空间复杂度O(n)</li>
</ul>
<h4 id="注意点">注意点</h4><ul>
<li>map的遍历<br><code>map&lt;int, int&gt;::iterator iter;</code><br><code>iter-&gt;first</code> <code>iter-&gt;second</code></li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{
        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;
        <span class="keyword">bool</span> ans = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)
        {
            <span class="keyword">if</span>(dict.count(numbers[i]) == <span class="number">0</span>)
                dict[numbers[i]] = <span class="number">1</span>;
            <span class="keyword">else</span>{
                dict[numbers[i]] += <span class="number">1</span>;
                ans = <span class="keyword">true</span>;
            }
        }
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;
        <span class="keyword">for</span>(iter = dict.begin();iter != dict.end();iter++)
        {
            <span class="keyword">if</span>(iter-&gt;second &gt; <span class="number">1</span>)
            {
                *duplication = iter-&gt;first;
                duplication++;
            }
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer29_数组中出现次数超过一半的数字">剑指offer29 数组中出现次数超过一半的数字</h3><h4 id="问题描述-1">问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<h4 id="解法-1">解法</h4><ul>
<li>使用快排partition函数，扫描一遍数组中间元素就是出现超过一半的数字</li>
<li>使用time记录数字出现的次数，cur记录当前数字</li>
</ul>
<h4 id="注意点-1">注意点</h4><ul>
<li>使用解法2需要判断最后的次数是否真的大于一半，如果不是，返回特定值</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="keyword">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="keyword">int</span>&gt; numbers) {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>) 
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> time = <span class="number">1</span>;
        <span class="keyword">int</span> cur = numbers[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(time == <span class="number">0</span>)
            {
                cur = numbers[i];
                time = <span class="number">1</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == cur)
                time++;
            <span class="keyword">else</span>
                time--;
        }
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == cur)
                <span class="keyword">count</span>++;
        }
        <span class="keyword">if</span>(<span class="keyword">count</span> * <span class="number">2</span> &gt; numbers.<span class="keyword">size</span>())
            <span class="keyword">return</span> cur;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre><h3 id="剑指offer40_数组中只出现一次的数字">剑指offer40 数组中只出现一次的数字</h3><h4 id="问题描述-2">问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解法-2">解法</h4><ul>
<li>对于只有一个数字出现一次，对所有数字做异或操作</li>
<li>有两个数字a,b出现了一次，其它出现偶数次。所有数字异或得temp = a^b，使用result做spliter，每一个数字和temp做与操作，把数组分成两组</li>
</ul>
<h4 id="注意点-2">注意点</h4><ul>
<li>与或非的操作符优先级</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void FindNumsAppearOnce(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>,<span class="built_in">int</span>* num1,<span class="built_in">int</span> *num2) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)
        {
            *num1 = <span class="number">0</span>;
            *num2 = <span class="number">0</span>;
            <span class="keyword">return</span> ;
        }
        <span class="built_in">int</span> temp = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;<span class="type">data</span>.<span class="built_in">size</span>(); i++)
            temp ^= <span class="type">data</span>[i];

        <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="type">data</span>.<span class="built_in">size</span>(); i++)
        {
            <span class="keyword">if</span>((<span class="type">data</span>[i] &amp; temp) == <span class="number">0</span>)
                a ^= <span class="type">data</span>[i];
            <span class="keyword">else</span>
                b ^= <span class="type">data</span>[i];

        }
        *num1 = a;
        *num2 = b;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-一般题目/">
                数组专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法">解法</h4><p>从右上角（这样使得这一行剩余元素都比他小，这一列剩余元素都比他大）向左下角扫描</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> width = <span class="built_in">array</span>[<span class="number">0</span>].size();
        <span class="keyword">int</span> height = <span class="built_in">array</span>.size();
        <span class="keyword">int</span> i = <span class="number">0</span>, j = width - <span class="number">1</span>;
        <span class="keyword">while</span>(i &lt; height &amp;&amp; j &gt;= <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)
                i++;
            <span class="keyword">else</span>
                j--;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer32_整数中1出现的次数（从1到n整数中1出现的次数）">剑指offer32 整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="问题描述-1">问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h4 id="解法-1">解法</h4><p>这个解法对于1-9的原理是一样的。首先找到规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从 1 至  10^i ，在它们右数第  i  位中，任意的 X 都出现了  10^(i−1)  次。这个可以用来计算高位的值。<br>计算方法：<br>当计算右数第  i  位包含的 X 的个数时：<br>取第  i  位左边（高位）的数字，乘以  10^(i−1) ，得到基础值  a 。<br>取第  i  位数字，计算修正值：<br>如果大于 X，则结果为  a+ 10^(i−1)。<br>如果小于 X，则结果为  a。<br>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  (a+b+1) 。<br>例如对于num=52134, i=3, a=52, b=34, i位数字k=1,k=x故 result=a+b+1<br>解释，a等于0~51，可推出高位的结果，a=52时，讨论低位的结果。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">int</span> NumberOf1Between1AndN_Solution(<span class="keyword">int</span> n)
    {
        <span class="keyword">int</span> x = <span class="number">1</span>;
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>, k;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)
        {
            k = n / i;
            <span class="comment">//k/10为高位数字</span>
            <span class="keyword">count</span> += (k / <span class="number">10</span>) * i;
            <span class="keyword">int</span> cur = k % <span class="number">10</span>;
            <span class="keyword">if</span>(cur &gt; x)
                <span class="keyword">count</span>+=i;               
            <span class="keyword">else</span> <span class="keyword">if</span>(cur == x)
                <span class="comment">//n%i为低位数字</span>
                <span class="keyword">count</span> += n % i + <span class="number">1</span>;
            <span class="keyword">else</span>{}
        }
        <span class="keyword">return</span> <span class="keyword">count</span>;
    }
};
</code></pre><h3 id="剑指offer44_扑克牌的顺子">剑指offer44 扑克牌的顺子</h3><h4 id="问题描述-2">问题描述</h4><p>抽出一序列牌，王代表任意数字是0，并且A看作1,J为11,Q为12,K为13。判断这个序列是否是顺子</p>
<h4 id="解法-2">解法</h4><p>对序列进行排序，看0是否能将空缺数字填满。</p>
<h4 id="注意点">注意点</h4><ul>
<li>统计0的个数和gap的数量进行比较</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool IsContinuous(vector&lt;<span class="keyword">int</span>&gt; numbers)
    {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">sort</span>(numbers.begin(), numbers.end());
        <span class="keyword">int</span> numOfZero = <span class="number">0</span>, numOfGap = <span class="number">0</span>;
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>() &amp;&amp; numbers[i] == <span class="number">0</span>; i++)
            numOfZero++;
        <span class="keyword">if</span>(i &lt; numbers.<span class="keyword">size</span>())
            i++;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == numbers[i - <span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>; 
            numOfGap += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;
        }
        <span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer52_构建乘积数组">剑指offer52 构建乘积数组</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组<code>A[0,1,...,n-1]</code>,请构建一个数组<code>B[0,1,...,n-1]</code>,其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<h4 id="解法-3">解法</h4><p>从上到下扫描，temp记录中间结果，避免重复的乘法。从上到下遍历一次，从下到上遍历一次。</p>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; multiply(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A) {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>(A.size(), <span class="number">1</span>);
        <span class="keyword">if</span>(A.size() &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)
        {
            temp *= A[i - <span class="number">1</span>];
            <span class="literal">result</span>[i] = temp;
        }
        temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)
        {
            temp *= A[i + <span class="number">1</span>];
            <span class="literal">result</span>[i] *= temp;
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h3 id="剑指offer20_顺时针打印矩阵">剑指offer20 顺时针打印矩阵</h3><h4 id="问题描述-4">问题描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h4 id="解法-4">解法</h4><p>先写一个打印一圈的函数，再遍历所有的圈。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>判断遍历是否越界</li>
<li>遍历的时候注意减回去(x—)</li>
</ul>
<h4 id="代码-4">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">matrix</span>) {
        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>.<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">int</span> start = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> start =  <span class="number">0</span>; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); start++)
            printInCircle(<span class="keyword">matrix</span>, start, vec);
        <span class="keyword">return</span> vec;
    }

    void printInCircle(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>, <span class="keyword">int</span> start, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)
    {
        <span class="keyword">int</span> x = start, y = start;
        <span class="comment">//从左向右打印</span>
        <span class="keyword">int</span> endx = <span class="keyword">matrix</span>[y].<span class="keyword">size</span>()- <span class="number">1</span> - start;
        <span class="keyword">for</span>(; x &lt;= endx; x++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        --x;

        <span class="comment">//从上向下打印</span>
        <span class="keyword">int</span> endy = <span class="keyword">matrix</span>.<span class="keyword">size</span>() - <span class="number">1</span> - start;
        <span class="keyword">if</span>(y + <span class="number">1</span> &gt; endy)
            <span class="keyword">return</span>;
        y++;
        <span class="keyword">for</span>(; y &lt;= endy; y++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y--;

        <span class="comment">//从右向左打印</span>
        <span class="keyword">if</span>(x - <span class="number">1</span> &lt; start)
            <span class="keyword">return</span>;
        x--;
        <span class="keyword">for</span>(; x &gt;= start; x--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        x++;
        <span class="comment">//从下向上打印</span>
        <span class="keyword">if</span>(y - <span class="number">1</span> &lt; start) <span class="keyword">return</span>;
        y--;
        <span class="keyword">for</span>(; y &gt; start; y--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y++;
    }

 };
</code></pre><h3 id="剑指offer30_最小的k个数">剑指offer30 最小的k个数</h3><h4 id="问题描述-5">问题描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="解法-5">解法</h4><p>使用大顶堆存储k个数，遍历原数据，每次淘汰最大的，最后堆中剩余的元素就是最小的k个数</p>
<h4 id="注意点-2">注意点</h4><ul>
<li>输入数据合法性，k的取值大于input.size()的情况</li>
<li><p>stl中<algorithm>关于堆的操作，make_heap,push_heap,pop_heap,sort_heap.默认建立大顶堆，如果想使用小顶堆需要加入比较函数。</algorithm></p>
<pre><code>make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
</code></pre></li>
</ul>
<h4 id="代码-5">代码</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    vector&lt;<span class="built_in">int</span>&gt; <span class="type">GetLeastNumbers_Solution</span>(vector&lt;<span class="built_in">int</span>&gt; input, <span class="built_in">int</span> k) {
        vector&lt;<span class="built_in">int</span>&gt; res;
        <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.size<span class="literal">()</span>)
            return res;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)
            res.push_back(input[i]);
        make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; input.size<span class="literal">()</span>; i++)
        {
            <span class="keyword">if</span>(input[i] &gt;= res[<span class="number">0</span>])
                continue;
            res.push_back(input[i]);
            push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            res.pop_back<span class="literal">()</span>;
        }
        sort_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        return res;
    }
};
</code></pre><h3 id="剑指offer33_把数组排成最小的数">剑指offer33 把数组排成最小的数</h3><h4 id="问题描述-6">问题描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="解法-6">解法</h4><p>首先要证明这样一个结论：</p>
<blockquote>
<p>若ca&lt;ac则在最后的字符串中，c应该在a的后面</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>条件：ca&lt;ac，有另一个任意<strong>字符串</strong>b与a,c进行排列组合<br>讨论：</p>
<pre><code>若b&lt;c&lt;<span class="tag">a</span> 可以得到bca是最小的
若c&lt;b&lt;<span class="tag">a</span> 可以得到cba是最小的
若c&lt;a&lt;<span class="tag">b</span> 可以得到cab是最小的
</code></pre><p>结论：c应该在a的前面</p>
<h4 id="注意点-3">注意点</h4><ul>
<li><p>sort函数中比较函数应该如何写</p>
<p>  <code>template &lt;class RandomAccessIterator, class Compare&gt;</code><br>  <code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
</li>
</ul>
<p>comp函数表示</p>
<blockquote>
<p>The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.<br>比较函数传入两个参数，返回bool，返回值表示在最终的排序结果中，第一个参数是否应该出现在第二个参数的前面。</p>
</blockquote>
<h4 id="代码-6">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span>
    </span>{
        <span class="built_in">string</span> temp1 = str1 + str2;
        <span class="built_in">string</span> temp2 = str2 + str1;
        <span class="keyword">if</span>(temp1.compare(temp2)&lt;=<span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;

    }

    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>{
        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs(numbers.size());
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)
        {
            strs[i] = numToString(numbers[i]);
        }
        <span class="built_in">std</span>::sort(strs.begin(), strs.end(), cmp);
        <span class="built_in">string</span> ans;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)
            ans += strs[i];
        <span class="keyword">return</span> ans;
    }  

    <span class="function"><span class="built_in">string</span> <span class="title">numToString</span><span class="params">(<span class="keyword">int</span> num)</span>
    </span>{
        <span class="built_in">string</span> str;
        <span class="keyword">while</span>(num)
        {
            str = (<span class="keyword">char</span>)(num % <span class="number">10</span> + <span class="string">'0'</span>) + str;
            num = num / <span class="number">10</span>;
        }
        <span class="keyword">return</span> str;
    } 
};
</code></pre><h3 id="剑指offer34_丑数">剑指offer34 丑数</h3><h4 id="问题描述-7">问题描述</h4><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="解法-7">解法</h4><p>使用递推法，<code>*numM2</code>,<code>*numM3</code>,<code>*numM5</code>表示，x2,x3,x5后产生的数</p>
<h4 id="代码-7">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> GetUglyNumber_Solution(<span class="built_in">int</span> <span class="built_in">index</span>) {
        <span class="keyword">if</span>(<span class="built_in">index</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> *a = new <span class="built_in">int</span>[<span class="built_in">index</span>];
        a[<span class="number">0</span>] = <span class="number">1</span>;
        <span class="built_in">int</span> *numM2 = a, *numM3 = a, *numM5 = a;
        for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">index</span>; i++)
        {
            <span class="built_in">int</span> <span class="built_in">min</span> = getMin((*numM2) * <span class="number">2</span>, (*numM3) * <span class="number">3</span>, (*numM5) * <span class="number">5</span>);
            a[i] = <span class="built_in">min</span>;
            <span class="keyword">while</span>((*numM2) * <span class="number">2</span> &lt;= <span class="built_in">min</span>)
                numM2++;
            <span class="keyword">while</span>((*numM3) * <span class="number">3</span> &lt;= <span class="built_in">min</span>)
                numM3++;
            <span class="keyword">while</span>((*numM5) * <span class="number">5</span> &lt;= <span class="built_in">min</span>)
                numM5++;
        }
        <span class="keyword">return</span> a[<span class="built_in">index</span>-<span class="number">1</span>];
    }

    <span class="built_in">int</span> getMin(<span class="built_in">int</span> num1,<span class="built_in">int</span> num2,<span class="built_in">int</span> num3)
    {
        <span class="keyword">return</span> <span class="built_in">min</span>(num1, <span class="built_in">min</span>(num2, num3));
    }
};
</code></pre><h3 id="剑指offer45_圆圈中最后剩下的数字（约瑟夫环问题）">剑指offer45 圆圈中最后剩下的数字（约瑟夫环问题）</h3><h4 id="问题描述-8">问题描述</h4><p>每年六一儿童节,NowCoder都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为NowCoder的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到NowCoder名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？</p>
<h4 id="解法-8">解法</h4><p>约瑟夫环递推公式：<br>f(n, m)表示n个人玩儿，报到m退出，最后剩下的人的编号。</p>
<pre><code><span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = 0, <span class="keyword">n</span>=1
<span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = (<span class="literal">f</span>(<span class="keyword">n</span> - 1) + <span class="keyword">m</span>) % <span class="keyword">n</span>, <span class="keyword">n</span> &gt; 1
</code></pre><h4 id="代码-8">代码</h4><h5 id="递推解法">递推解法</h5><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span>
    </span>{
        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">int</span> last = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)
            last=(last + m) % i;
        <span class="keyword">return</span> last;
    }
};
</code></pre><h5 id="递归解法">递归解法</h5><pre><code>int lastRemain(int <span class="keyword">n</span>, int  <span class="keyword">m</span>)
{
    <span class="keyword">if</span>(<span class="keyword">n</span> == 1)
        <span class="keyword">return</span> 0;
    <span class="keyword">return</span> (lastRemain(<span class="keyword">n</span> - 1, <span class="keyword">m</span>) % <span class="keyword">n</span>);
}
</code></pre><h4 id="问题拓展:求第i次出环的人的编号">问题拓展:求第i次出环的人的编号</h4><pre><code>int getNumOfI(int <span class="keyword">n</span>, int <span class="keyword">m</span>, int i)
{
    <span class="keyword">if</span>(i == 1)
        <span class="keyword">return</span> (<span class="keyword">n</span> + <span class="keyword">m</span> - 1) % <span class="keyword">n</span>; <span class="comment">//第一次出环 (n-1+m)%n</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> getNumOfI(<span class="keyword">n</span> - 1, <span class="keyword">m</span>, i - 1) % <span class="keyword">n</span>;
}
</code></pre><p><a href="http://www.cnblogs.com/yangyh/archive/2011/10/30/2229517.html" target="_blank" rel="external">参考</a></p>
<h3 id="剑指offer64_数据流中的中位数">剑指offer64 数据流中的中位数</h3><h4 id="问题描述-9">问题描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>实现一种数据结构，要求插入删除O(logn),取中位数O(1)</p>
<h4 id="解法-9">解法</h4><p>实现一个小顶堆和大顶堆，大数存在小顶堆，小数存在大顶堆，每次按大小压入元素，调整两个堆中的数量，使得<code>0&lt;=Num(大顶堆)-Num(小顶堆)&lt;=1</code>。</p>
<h4 id="注意点-4">注意点</h4><ul>
<li>使用priority_queue<br>初始化：<pre><code>priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;
priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;
</code></pre>压入，弹出：<pre><code><span class="tag">minHeap</span><span class="class">.push</span>(<span class="tag">maxHeap</span><span class="class">.top</span>());
<span class="tag">maxHeap</span><span class="class">.pop</span>();
</code></pre></li>
</ul>
<h4 id="代码-9">代码</h4><pre><code>class Solution {
public:
    void Insert<span class="params">(int num)</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.empty<span class="params">()</span> || num &lt;= maxHeap.top<span class="params">()</span>)</span>
            maxHeap.push<span class="params">(num)</span>;
        <span class="keyword">else</span>
            minHeap.push<span class="params">(num)</span>;
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>+<span class="number">2</span>)</span>
        {
            minHeap.push<span class="params">(maxHeap.top<span class="params">()</span>)</span>;
            maxHeap.pop<span class="params">()</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>-<span class="number">1</span>)</span>
        {
            maxHeap.push<span class="params">(minHeap.top<span class="params">()</span>)</span>;
            minHeap.pop<span class="params">()</span>;
        }
    }

    double GetMedian<span class="params">()</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>)</span>
            return <span class="params">(maxHeap.top<span class="params">()</span> + minHeap.top<span class="params">()</span>)</span>/<span class="number">2.0</span>;
        <span class="keyword">else</span>
            return maxHeap.top<span class="params">()</span>;
    }
private:
    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;

};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/25/找工作总结-字符串专题-一般题目/">
                字符串专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/25/找工作总结-字符串专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/25/找工作总结-字符串专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一遍，记录空格个数。申请newSize，从后向前填充数组。</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string replaceSpace(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="built_in">int</span> numOfSpace=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">str</span>.<span class="built_in">size</span>();++i)
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
                ++numOfSpace;
        <span class="built_in">int</span> newSize=<span class="built_in">str</span>.<span class="built_in">size</span>()+<span class="number">2</span>*numOfSpace;
        string ans;
        ans.resize(newSize);
        <span class="built_in">int</span> i=<span class="built_in">str</span>.<span class="built_in">size</span>()-<span class="number">1</span>,j=newSize-<span class="number">1</span>;
        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)   
        {
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
            {
                ans[j--]=<span class="string">'0'</span>;
                ans[j--]=<span class="string">'2'</span>;
                ans[j--]=<span class="string">'%'</span>;
                --i;
            }
            <span class="keyword">else</span>
                ans[j--]=<span class="built_in">str</span>[i--];
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer54_表示数值的字符串">剑指offer54 表示数值的字符串</h3><p>问题描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>解法：首先可以写出这个字符串的正则表达式</p>
<pre><code>(+|-)？\<span class="keyword">d</span>+(.\<span class="keyword">d</span>+)?(<span class="keyword">e</span>|<span class="literal">E</span>(+|-)?\<span class="keyword">d</span>+)?
</code></pre><p>对于正则表达式中的符号，<code>?</code>表示0或1，使用<code>if</code>判断，+表示1或者更多，直接扫描判断。</p>
<p>注意点：<br>(1) 非法输入，传入str == NULL<br>(2) 结束条件的判断</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isNumeric(<span class="keyword">char</span>* <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'.'</span>)
        {
            <span class="keyword">str</span>++;
            <span class="comment">//根据题目要求是否允许"32."这样的数据</span>
            <span class="comment">//if(*str == '\0')</span>
            <span class="comment">//    return false;</span>
            scanDigits(<span class="keyword">str</span>);
        }
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'e'</span> || *<span class="keyword">str</span> == <span class="string">'E'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">void</span> scanDigits(<span class="keyword">char</span> *(&amp;<span class="keyword">str</span>))
    {
        <span class="keyword">while</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'9'</span>)
            <span class="keyword">str</span>++;
    }
};
</code></pre><h3 id="剑指offer55_字符流中第一个不重复的字符">剑指offer55 字符流中第一个不重复的字符</h3><p>问题描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>解法：字符只有256个，所以可以使用<code>int dict[256]</code>数组来记录所有字符出现的情况。0表示未出现过，-1表示出现过大于1次，&gt;0时dict[i]表示字符i第一次出现的index</p>
<p>注意点：<br>通过遍历dict[26]找到minIndex找到<strong>第一次出现</strong>的字符</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>
</span>{
<span class="keyword">public</span>:
      <span class="comment">//Insert one char from stringstream</span>
    <span class="keyword">void</span> Insert(<span class="keyword">char</span> ch)
    {
        <span class="keyword">if</span>(dict[ch] == <span class="number">0</span>) <span class="comment">//没出现过</span>
            dict[ch] = <span class="keyword">index</span>;
        <span class="keyword">else</span> <span class="comment">//出现过</span>
            dict[ch] = -<span class="number">1</span>;
        <span class="keyword">index</span>++;
    }
      <span class="comment">//return the first appearence once char in current stringstream</span>
    <span class="keyword">char</span> FirstAppearingOnce()
    {
        <span class="keyword">char</span> ans=<span class="string">'#'</span>;
        <span class="keyword">int</span> minIndex = INT_MAX;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
        {
            <span class="keyword">if</span>(dict[i] &gt; <span class="number">0</span> &amp;&amp; dict[i] &lt; minIndex)
            {
                ans = i;
                minIndex = dict[i];
            }
        }
        <span class="keyword">return</span> ans;
    }

    Solution()
    {
        <span class="keyword">index</span> = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
            dict[i] = <span class="number">0</span>;
    }
<span class="keyword">private</span>:
    <span class="keyword">int</span> dict[<span class="number">256</span>];
    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">1</span>;
};
</code></pre><h3 id="剑指offer42_反转单词顺序_VS_左旋字符串">剑指offer42 反转单词顺序 VS 左旋字符串</h3><p>反转字符串函数：</p>
<pre><code>void reverseString(<span class="built_in">string</span> &amp;str, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        char temp = str[<span class="built_in">left</span>];
        str[<span class="built_in">left</span>] = str[<span class="built_in">right</span>];
        str[<span class="built_in">right</span>] = temp;
        <span class="built_in">left</span>++;
        <span class="built_in">right</span>--;
    }
}
</code></pre><h4 id="反转单词顺序">反转单词顺序</h4><p>问题描述：JOBDU最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>解法：先反转每一个单词，再反转整句</p>
<p>注意点：</p>
<ol>
<li>功能测试：”student. a am I”</li>
<li>特殊测试用例”aaa “,” aaa”</li>
</ol>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string ReverseSentence(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;
        <span class="keyword">while</span>(right &lt; <span class="built_in">str</span>.<span class="built_in">size</span>())
        {
            <span class="keyword">while</span>(<span class="built_in">str</span>[left] == <span class="string">' '</span>)
            {
                left++;
                right++;
            }
            <span class="comment">//应对用例"aa "</span>
            <span class="keyword">if</span>(left &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>()) 
                <span class="keyword">break</span>;
            <span class="keyword">while</span>(<span class="built_in">str</span>[right] != <span class="string">' '</span> &amp;&amp; <span class="built_in">str</span>[right] != <span class="string">'\0'</span>)
                right++;
            reverseString(<span class="built_in">str</span>,left,right-<span class="number">1</span>);
            left = right;
        }
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre><h4 id="左旋字符串">左旋字符串</h4><p>问题描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>解法：先反转3分割的两部分，再旋转这个字符串</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string LeftRotateString(string <span class="built_in">str</span>, <span class="built_in">int</span> n) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="keyword">if</span>(n &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, n - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, n, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/字符串/"> #字符串 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/24/排序算法总结/">
                排序算法总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/24/排序算法总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/24/排序算法总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>void insertSort(int a[], int N)
<span class="comment">{
    for(int i = 1; i &lt; N; i++)
    {
        int temp = a[i];
        int j;
        for(j = i; j &gt; 0 &amp;&amp; temp &lt; a[j-1]; j--)
            a[j] = a[j-1];
        a[j] = temp;
    }</span>
}
</code></pre><h3 id="希尔排序">希尔排序</h3><p>原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<blockquote>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> incre = N / <span class="number">2</span>; incre &gt; <span class="number">0</span>; incre /= <span class="number">2</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = incre; i &lt; N; i++)
        {
            <span class="keyword">int</span> temp = a[i];
            <span class="keyword">int</span> j;
            <span class="keyword">for</span>(j = i; j &gt;= incre &amp;&amp; temp &lt; a[j - incre]; j -= incre)
                a[j] = a[j - incre];
            a[j] = temp;
        }
    }
}
</code></pre><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。</p>
<pre><code>void bubbleSort(int <span class="literal">a</span>[], int N)
{
    for(int i = <span class="number">0</span><span class="comment">; i &lt; N; i++)</span>
    {
        for(int j = i<span class="comment">; j &lt; N - i - 1; j++)</span>
        {
            <span class="keyword">if</span>(<span class="literal">a</span>[j] &gt; <span class="literal">a</span>[j+<span class="number">1</span>])
            {
                int temp = <span class="literal">a</span>[j]<span class="comment">;</span>
                <span class="literal">a</span>[j] = <span class="literal">a</span>[j+<span class="number">1</span>]<span class="comment">;</span>
                <span class="literal">a</span>[j+<span class="number">1</span>] = temp<span class="comment">;</span>
            }
        }
    }
}
</code></pre><p>补充说明：使用didSwap=true/false可以避免重复的比较，使得最好情况的复杂度变为O(n)</p>
<h3 id="快速排序">快速排序</h3><p>原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>实现：</p>
<pre><code>void quickSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> temp = a[<span class="built_in">left</span>];
        <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">right</span>;
        <span class="keyword">while</span>(i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &lt;= a[j])
                j--;
            <span class="keyword">if</span>(i &lt; j)
                a[i++] = a[j];
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &gt;= a[i])
                i++;
            <span class="keyword">if</span>(i &lt; j)
                a[j--] = a[i];
        }
        a[i] = temp;
        quickSortCore(a, <span class="built_in">left</span>, i-<span class="number">1</span>);
        quickSortCore(a, i+<span class="number">1</span>, <span class="built_in">right</span>);
    }

}

void quickSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    quickSortCore(a, <span class="number">0</span>, N-<span class="number">1</span>);
}
</code></pre><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p>原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)
    {
        <span class="keyword">int</span> k = i;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)
        {
            <span class="keyword">if</span>(a[j] &lt; a[k])
                k = j;
        }
        <span class="keyword">int</span> temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
}
</code></pre><h3 id="堆排序">堆排序</h3><p>堆序性质： 堆分为大顶堆和小顶堆，满足<code>Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code>称为大顶堆，满足 <code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]</code>称为小顶堆。</p>
<p>原理：利用大顶堆或小顶堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。如从小到大排序，建立大顶堆，堆顶元素与堆尾不断交换，同时缩小堆的范围，最终得到排序结果。</p>
<pre><code>void percDown(int a[], int i, int N)
<span class="comment">{
    int temp = a[i], child;
    for(; 2 * i + 1 &lt; N; i = child)
    {
        child = 2 * i + 1;
        if(child + 1 &lt; N &amp;&amp; a[child] &lt; a[child + 1])
            child++;
        if(temp &lt; a[child])
            a[i] = a[child];
        else
            break;
    }</span>
    a[i] = temp;
}

void heapSort(int a[], int N)
<span class="comment">{
    for(int i = N / 2; i &gt;= 0; i--)
        percDown(a, i, N);
    for(int i = N-1; i &gt; 0; i--)
    {
        int temp = a[i];
        a[i] = a[0];
        a[0] = temp;
        percDown(a, 0, i);
    }</span>
}
</code></pre><h2 id="归并排序">归并排序</h2><p>原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。</p>
<pre><code>void merge(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> lpos = <span class="built_in">left</span>, lend = <span class="built_in">mid</span>;
        <span class="built_in">int</span> rpos = <span class="built_in">mid</span> + <span class="number">1</span>, rend = <span class="built_in">right</span>;
        <span class="built_in">int</span> tpos = <span class="built_in">left</span>;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(a[lpos] &lt;= a[rpos])
                temp[tpos++] = a[lpos++];
            <span class="keyword">else</span>
                temp[tpos++] = a[rpos++];
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++] = a[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = a[rpos++];
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">right</span>; i++)
            a[i] = temp[i];
    }
}
void mergeSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
        mergeSortCore(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>);
        mergeSortCore(a, temp, <span class="built_in">mid</span>+<span class="number">1</span>, <span class="built_in">right</span>);
        merge(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);
    }
}
void mergeSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    <span class="built_in">int</span> *temp = <span class="keyword">new</span> <span class="built_in">int</span>[N];
    mergeSortCore(a, temp, <span class="number">0</span>, N-<span class="number">1</span>);
    delete [] temp;
}
</code></pre><h2 id="各种排序算法的复杂度稳定性分析">各种排序算法的复杂度稳定性分析</h2><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">复杂度分析</th>
<th>稳定性</th>
<th>稳定性原因分析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">简单插入</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">平均接近nlogn,最好O(n),最坏O(n^2)</td>
<td>不稳定</td>
<td>增量分组，有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">交换排序</td>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">平均nlogn,最好nlogn,最坏O(n^2)</td>
<td>不稳定</td>
<td>有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">直接选择</td>
<td style="text-align:left">平均O(n^2),最好O(n^2),最坏O(n^2)</td>
<td>不稳定</td>
<td>5 8 5 2</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">平均,最好,最坏nlogn</td>
<td>不稳定</td>
<td>3 2 3 2</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">平均,最好,最坏nlogn，有O(n)空间复杂度</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
</tbody>
</table>
<h2 id="扩展问题">扩展问题</h2><ul>
<li>单链表可以做快速排序吗？为什么？</li>
</ul>
<p>可以。快速排序的核心函数partition，选择某个元素为枢纽元x(通常是第一个)，一遍扫描之后使得比x小的在枢纽元左边，比x大的在枢纽元的右边。使用链表时，x指向链表头(枢纽元)，扫描这个链表，小元素拼在链表头，大元素拼在链表尾部，从而完成一次partition函数的流程。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序/"> #排序 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
