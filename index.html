<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-动态规划专题/">
                动态规划
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-动态规划专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-动态规划专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>动态规划的关键是写出状态转移方程</p>
<h3 id="青蛙跳台阶_VS_斐波那契数列">青蛙跳台阶 VS 斐波那契数列</h3><h4 id="问题描述">问题描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="解法">解法</h4><p>状态转移方程：</p>
<pre><code><span class="tag">a</span>[n] = <span class="tag">a</span>[n-<span class="number">1</span>] + <span class="tag">a</span>[n-<span class="number">2</span>]
</code></pre><h4 id="代码">代码</h4><p>递归，使用vector存储每一步的结果，防止重复计算</p>
<pre><code><span class="keyword">class</span> Solution {
public:
    int jumpFloor(int number) {
        <span class="keyword">if</span>(number &lt;= 0) <span class="keyword">return</span> 0;
        vector&lt;int&gt; <span class="literal">vec</span>(number + 1, 0);
        <span class="keyword">count</span>(number, <span class="keyword">vec</span>);
        <span class="keyword">return</span> <span class="keyword">vec</span>[number];
    }
    int <span class="keyword">count</span>(int <span class="keyword">n</span>, vector&lt;int&gt;&amp; <span class="keyword">vec</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">n</span> == 0 || <span class="keyword">n</span> == 1 || <span class="keyword">n</span> == 2)
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">n</span>;
        <span class="keyword">if</span>(<span class="keyword">vec</span>[<span class="keyword">n</span>] != 0)
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        <span class="keyword">else</span>
        {
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">count</span>(<span class="keyword">n</span> - 1, <span class="keyword">vec</span>) + <span class="keyword">count</span>(<span class="keyword">n</span> - 2, <span class="keyword">vec</span>);
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        }
    }
};
</code></pre><p>非递归：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> jumpFloor(<span class="built_in">int</span> <span class="keyword">number</span>) {
        <span class="keyword">if</span>(<span class="keyword">number</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;
        <span class="built_in">int</span> temp1 = <span class="number">1</span>, temp2 = <span class="number">2</span>, ans = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= <span class="keyword">number</span>; i++)
        {
            ans = temp1 + temp2;
            temp1 = temp2;
            temp2 = ans;
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="House_Robber">House Robber</h3><h4 id="问题描述-1">问题描述</h4><p>强盗偷东西，不能连续抢两家，求最多可以打劫到的金钱数。</p>
<h4 id="解法-1">解法</h4><p>状态转移方程：</p>
<pre><code>dp[i] = max<span class="comment">(dp[i-1], dp[i-2]+num[i])</span>
</code></pre><p>表示当前位置最大的金钱数，等于i位置不打劫和i位置打劫的更大值。</p>
<h4 id="代码-1">代码</h4><p>递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//动态规划，状态转移方程：S(n)=max{S(n-1),S(n-2)+a[n]}</span>
<span class="comment">//直接使用递归超时，需要额外存储换时间</span>
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; res(<span class="built_in">num</span>.size(), -<span class="number">1</span>);
        <span class="keyword">return</span> S(<span class="built_in">num</span>.size() - <span class="number">1</span>, <span class="built_in">num</span>, res) ;
    }

    <span class="built_in">int</span> S(<span class="built_in">int</span> i, vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">num</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; res)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
            res[i] = <span class="built_in">num</span>[i];
        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)
            res[i] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
        <span class="keyword">else</span> <span class="keyword">if</span>(res[i] != -<span class="number">1</span>) 
            <span class="keyword">return</span> res[i];
        <span class="keyword">else</span>
        {
            <span class="built_in">int</span> S1=S(i-<span class="number">1</span>, <span class="built_in">num</span>, res);
            <span class="built_in">int</span> S2=S(i-<span class="number">2</span>, <span class="built_in">num</span>, res) + <span class="built_in">num</span>[i];
            res[i] = S1 &gt;= S2 ? S1 : S2;
        }
        <span class="keyword">return</span> res[i];
    }
};
</code></pre><p>非递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="built_in">int</span> n = <span class="built_in">num</span>.size();
        <span class="keyword">if</span>(n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)
            <span class="keyword">return</span> <span class="built_in">num</span>[<span class="number">0</span>];
        <span class="keyword">else</span>
        {
            vector&lt;<span class="built_in">int</span>&gt; maxV(n, <span class="number">0</span>);
            maxV[<span class="number">0</span>] = <span class="built_in">num</span>[<span class="number">0</span>];
            maxV[<span class="number">1</span>] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i ++)
                maxV[i] = max(maxV[i - <span class="number">2</span>] + <span class="built_in">num</span>[i], maxV[i - <span class="number">1</span>]);
            <span class="keyword">return</span> maxV[n - <span class="number">1</span>];
        }
    }
};
</code></pre><h3 id="House_Robber_II">House Robber II</h3><h4 id="题目描述">题目描述</h4><p>街道变成环，其他条件不变</p>
<h4 id="解法-2">解法</h4><p>res = max（抢第一家到倒数第二家， 抢第二家到最后一家）</p>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">int</span> rob(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">1</span>)
            <span class="keyword">return</span> nums[<span class="number">0</span>];
        <span class="keyword">return</span> <span class="keyword">max</span>(robber(nums, <span class="number">0</span>, nums.<span class="keyword">size</span>()-<span class="number">2</span>), robber(nums, <span class="number">1</span>, nums.<span class="keyword">size</span>()-<span class="number">1</span>));
    }

    <span class="keyword">int</span> robber(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)
    {
        <span class="keyword">int</span> temp1 = <span class="number">0</span>, temp2 = <span class="number">0</span>,res = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)
        {
            res = <span class="keyword">max</span>(temp1 + nums[i], temp2);
            temp1 = temp2;
            temp2 = res;
        }
        <span class="keyword">return</span> res;
    }
};
</code></pre><h3 id="最大连续子序列">最大连续子序列</h3><h4 id="最大连续子序列和">最大连续子序列和</h4><p>遍历如果currentSum&lt;0 丢弃前面的数，否则currentSum+=num[i]。记录max</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> greatest = <span class="built_in">array</span>[<span class="number">0</span>];
        <span class="keyword">int</span> currentSum = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
        {
            <span class="keyword">if</span>(currentSum &lt;= <span class="number">0</span>)
                currentSum = <span class="built_in">array</span>[i];
            <span class="keyword">else</span>
                currentSum += <span class="built_in">array</span>[i];

            <span class="keyword">if</span>(currentSum &gt; greatest)
                greatest = currentSum;
        }
        <span class="keyword">return</span> greatest;
    }
};
</code></pre><h4 id="最大连续子序列乘积">最大连续子序列乘积</h4><pre><code><span class="keyword">class</span> Solution {
//思路：动态规划，计算字数组和的时候sub[i+<span class="number">1</span>]=<span class="built_in">max</span>(sub[i]+A[i+<span class="number">1</span>],A[i+<span class="number">1</span>]),在计算子数组乘积的时候，
/*
<span class="built_in">max</span>[i]=<span class="built_in">max</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
<span class="built_in">min</span>[i]=<span class="built_in">min</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
*/
<span class="keyword">public</span>:
    <span class="built_in">int</span> maxProduct(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> maxcur,mincur;
        <span class="built_in">int</span> <span class="built_in">maxval</span> = nums[<span class="number">0</span>];
        <span class="built_in">int</span> minpre = nums[<span class="number">0</span>];
        <span class="built_in">int</span> maxpre = nums[<span class="number">0</span>];
        for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)
        {
            maxcur = <span class="built_in">max</span>(<span class="built_in">max</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            mincur = <span class="built_in">min</span>(<span class="built_in">min</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            <span class="built_in">maxval</span> = <span class="built_in">max</span>(<span class="built_in">maxval</span>, maxcur);
            minpre = mincur;
            maxpre = maxcur;
        }
        <span class="keyword">return</span> <span class="built_in">maxval</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-图遍历/">
                图，回溯，遍历
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-图遍历/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-图遍历/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer_66_矩阵中的路径">剑指offer 66 矩阵中的路径</h3><h4 id="问题描述">问题描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h4 id="解法">解法</h4><p>使用<code>vector&lt;vector&lt;bool&gt;&gt; visited</code>记录位置是否被访问过。每个节点指向周围四个点，从而形成一个有向图。然后使用递归进行有向图的深度优先遍历。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span>
    </span>{
        <span class="keyword">if</span>(matrix == NULL || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vec(cols, <span class="keyword">false</span>);
            visited.push_back(vec);
        }
        <span class="keyword">int</span> step = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)
            {
                <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, i, j, str, step, visited))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j,
                     <span class="keyword">char</span>* str, <span class="keyword">int</span> &amp;step, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;visited)</span>
    </span>{
        <span class="keyword">if</span>(str[step] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">bool</span> hasPath = <span class="keyword">false</span>;
        <span class="keyword">if</span>(i &gt;=<span class="number">0</span> &amp;&amp; i&lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp;
          matrix[i*cols + j] == str[step] &amp;&amp; !visited[i][j])
        {
            step++;
            visited[i][j] = <span class="keyword">true</span>;
            hasPath = hasPathCore(matrix, rows, cols, i-<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i+<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j-<span class="number">1</span>, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j+<span class="number">1</span>, str, step, visited);
            <span class="keyword">if</span>(!hasPath)
            {
                step--;
                visited[i][j] = <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> hasPath;          
    }
};
</code></pre><h3 id="剑指offer_67_机器人的运动范围">剑指offer 67 机器人的运动范围</h3><h4 id="问题描述-1">问题描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h4 id="解法-1">解法</h4><p>模拟，进行图的深度优先遍历，每走一步是否满足条件。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span>
    </span>{
        <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows*cols;i++)
            visited[i] = <span class="keyword">false</span>;
        <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);
        <span class="keyword">delete</span> [] visited;
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">if</span>(check(threshold, rows, cols, i, j, visited))
        {
            visited[i * cols + j] = <span class="keyword">true</span>;
            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, i-<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i+<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i, j-<span class="number">1</span>, visited)
                + movingCountCore(threshold, rows, cols, i, j+<span class="number">1</span>, visited);
        }
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp; !visited[i*cols + j]
          &amp;&amp; getDigitSum(i)+getDigitSum(j) &lt;= threshold
          )  
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span>
    </span>{
        <span class="keyword">int</span> sum = <span class="number">0</span>;
        <span class="keyword">while</span>(number)
        {
            sum += number%<span class="number">10</span>;
            number /= <span class="number">10</span>;
        }
        <span class="keyword">return</span> sum;
    }    
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/图/"> #图 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-递归专题/">
                递归
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-递归专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-递归专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer11_数值的整数次方">剑指offer11 数值的整数次方</h3><h4 id="问题描述">问题描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h4 id="解法">解法</h4><p>求a的b次方</p>
<ul>
<li>如果b是奇数，result=a*a^(b-1)</li>
<li>如果b是偶数，temp=a^(b/2),result=temp*temp</li>
</ul>
<p>避免多次乘法。</p>
<h4 id="注意点">注意点</h4><ul>
<li>判断输入数据是否合法，0的负数次方不合法，0的0次方返回1.0</li>
<li>浮点数相等的判断</li>
<li><p>负数次方转化为整数次方</p>
<h4 id="代码">代码</h4><p>  class Solution {<br>  public:</p>
<pre><code><span class="keyword">bool</span> invalidInput=<span class="keyword">false</span>;
<span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>) </span>{
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)
    {
        invalidInput = <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="number">0.0</span>;
    }
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1.0</span>;
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>,<span class="number">0.0</span>))
        <span class="keyword">return</span> <span class="number">0.0</span>;
    <span class="keyword">int</span> absExponent;
    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)
        absExponent =- exponent;
    <span class="keyword">else</span>
        absExponent = exponent;

    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, absExponent);
    <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)
        <span class="keyword">return</span> temp;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">1.0</span> / temp;
}

<span class="function"><span class="keyword">double</span> <span class="title">powerPositive</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exp</span>)
</span>{
    <span class="keyword">if</span>(exp == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">if</span>(exp == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">base</span>;
    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, exp &gt;&gt; <span class="number">1</span>);
    <span class="keyword">if</span>((exp&amp;<span class="number">1</span>) == <span class="number">1</span>)
        <span class="keyword">return</span> temp * temp * <span class="keyword">base</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> temp * temp;

}

<span class="function"><span class="keyword">bool</span> <span class="title">doubleEqual</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)
</span>{
    <span class="keyword">if</span>(a - b &gt; -<span class="number">0.0000001</span> &amp;&amp; a - b &lt; <span class="number">0.0000001</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>  };</p>
</li>
</ul>
<h3 id="全排列问题（剑指offer_28_字符串的全排列）">全排列问题（剑指offer 28 字符串的全排列）</h3><h4 id="问题描述-1">问题描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。</p>
<h4 id="解法-1">解法</h4><p>使用递归进行深度优先遍历，可以画出递归树，然后对这个树（图）进行深度优先遍历。递归函数表示当前位置的元素(index)和之后(包括自己)的元素进行交换。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>元素交换后还需要换回来</li>
<li>排列的序列中如果有重复元素需要判断。</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
  vector&lt;string&gt; Permutation(string <span class="keyword">str</span>) {
    vector&lt;string&gt; vec;
    <span class="keyword">if</span>(<span class="keyword">str</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> vec;
    PermutationR(<span class="keyword">str</span>,<span class="number">0</span>,vec);
    sort(vec.begin(),vec.end());
    <span class="keyword">return</span> vec;
  }

    <span class="keyword">void</span> PermutationR(string&amp; <span class="keyword">str</span>, <span class="keyword">int</span> <span class="keyword">index</span>, vector&lt;string&gt;&amp; vec)
    {
        <span class="keyword">if</span>(<span class="keyword">index</span> == <span class="keyword">str</span>.size() - <span class="number">1</span>)
            vec.push_back(<span class="keyword">str</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">index</span>; i &lt; <span class="keyword">str</span>.size(); i++)
        {
            <span class="keyword">if</span>(i != <span class="keyword">index</span> &amp;&amp; <span class="keyword">str</span>[<span class="keyword">index</span>] == <span class="keyword">str</span>[i]) 
                <span class="keyword">continue</span>;
            <span class="keyword">char</span> temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
            PermutationR(<span class="keyword">str</span>, <span class="keyword">index</span> + <span class="number">1</span>, vec); 
            temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
        }
    }
};
</code></pre><h3 id="剑指offer_53_正则表达式匹配">剑指offer 53 正则表达式匹配</h3><h4 id="问题描述-2">问题描述</h4><p>请实现一个函数用来匹配包括’.’和<code>&#39;*&#39;</code>的正则表达式。模式中的字符’.’表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和<code>&quot;ab*ac*a&quot;</code>匹配，但是与”aa.a”和<code>&quot;ab*a&quot;</code>均不匹配</p>
<h4 id="解法-2">解法</h4><p>考虑<code>bool match(char* str, char* pattern)</code><br>因为str中可能出现_*这种形式，所以每次需要扫描pattern的后一个元素。讨论以下几种情况：</p>
<ul>
<li><p><code>_*</code></p>
<ul>
<li><p>如果能匹配上 <code>*p == *str</code>或者 <code>*p == &#39;.&#39;</code></p>
<ul>
<li>next state -&gt; str+1, p+2</li>
<li>current state -&gt; str+1, p</li>
<li>ignore this -&gt; str p+2</li>
</ul>
</li>
<li><p>如果匹配不上 ignore this -&gt; str, p+2</p>
</li>
</ul>
</li>
<li><code>*str == *p</code> -&gt; str+1, p+1</li>
<li><code>*p == &#39;.&#39;</code> -&gt; str+1, p+1</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool match(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">char</span>* pattern)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || pattern == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, pattern);
    }
    bool matchCore(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">char</span> *p)
    {
        <span class="keyword">if</span>(*<span class="keyword">str</span>  == <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*(p+<span class="number">1</span>) == <span class="string">'*'</span>)
        {
            <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">2</span>) || matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p) || matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
            <span class="keyword">else</span>
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
        }
        <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
            <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">1</span>);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-常用函数专题/">
                常用函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-常用函数专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-常用函数专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="C语言常用库函数">C语言常用库函数</h2><p>需要引用断言函数库</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span>
</code></pre><h3 id="注意点">注意点</h3><ul>
<li>需要声明断言</li>
<li>字符串操作结尾需要’\0’</li>
<li>不改变的内容需要声明const</li>
<li>对于<code>void*</code>类型，使用<code>(char*)dst</code>按字节赋值</li>
</ul>
<h3 id="strlen">strlen</h3><pre><code>size_t strlen(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    size_t len = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> != <span class="string">'\0'</span>)
    {
        <span class="built_in">str</span>++;
        len++;
    }
    <span class="keyword">return</span> len;
}
</code></pre><h3 id="strcpy">strcpy</h3><pre><code><span class="keyword">char</span>* strcpy(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">char</span>* <span class="keyword">ret</span> = dst;
    <span class="keyword">while</span>(*src != '\0')
    {
<span class="comment">        *dst = *src;</span>
        dst++;
        src++;
    }
<span class="comment">    *dst = '\0';</span>
    <span class="keyword">return</span> <span class="keyword">ret</span>;
}
</code></pre><h3 id="memcpy">memcpy</h3><pre><code><span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, size_t <span class="built_in">size</span>)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="built_in">size</span>--)
    {
        *(<span class="built_in">char</span>*)dst = *(<span class="built_in">char</span>*)src;
        dst = (<span class="built_in">char</span>*)dst + <span class="number">1</span>;
        src = (<span class="built_in">char</span>*)src + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="memset">memset</h3><pre><code><span class="keyword">void</span>* memset(<span class="keyword">void</span>* dst, <span class="keyword">int</span> val, size_t <span class="keyword">size</span>)
{
    assert(dst != <span class="keyword">NULL</span>);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="keyword">size</span>--)
    {
        *(<span class="keyword">char</span>*)dst = val;
        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="strcmp">strcmp</h3><pre><code><span class="label">int</span> <span class="keyword">strcmp(const </span>char* <span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">assert</span>(<span class="keyword">str2 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&gt; *<span class="keyword">str2)
</span>            return <span class="number">1</span><span class="comment">;</span>
        <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&lt; <span class="keyword">str2)
</span>            return -<span class="number">1</span><span class="comment">;</span>
        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        return <span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
        return -<span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span>
        return <span class="number">0</span><span class="comment">;</span>
}
</code></pre><h3 id="strcat">strcat</h3><pre><code><span class="label">char</span>* <span class="keyword">strcat(char* </span><span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    char* ret = <span class="keyword">str1;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        <span class="keyword">str1++;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        *<span class="keyword">str1 </span>= *<span class="keyword">str2;
</span>        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    *<span class="keyword">str1 </span>= <span class="string">'\0'</span><span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><h2 id="atoi和itoa">atoi和itoa</h2><h3 id="atoi">atoi</h3><p>把字符串(<code>char*</code>或者<code>string</code>)转化为整数</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>删除字符串前面的空值</li>
<li>考虑字符传中可能出现的+,-</li>
<li>考虑溢出的情况</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="built_in">int</span> atoi(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    <span class="keyword">while</span>(*<span class="built_in">str</span> == <span class="string">' '</span>)
        <span class="built_in">str</span>++;
    bool isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'-'</span>)
    {
        isNeg = <span class="keyword">true</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'+'</span>)
        <span class="built_in">str</span>++;
    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> !=<span class="string">'\0'</span> &amp;&amp; *<span class="built_in">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="built_in">str</span> &lt;= <span class="string">'9'</span>)
    {
        num = num * <span class="number">10</span> + (*<span class="built_in">str</span> - <span class="string">'0'</span>);
        <span class="keyword">if</span>(isNeg &amp;&amp; -num &lt; INT_MIN)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(!isNeg &amp;&amp; num &gt; INT_MAX)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">return</span> -num;
    <span class="keyword">else</span>
        <span class="keyword">return</span> num;
}
</code></pre><h3 id="itoa">itoa</h3><h4 id="注意点-2">注意点</h4><ul>
<li>正负数</li>
<li>反转字符串</li>
<li>最后的’\0’</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">char</span>* itoa(<span class="keyword">int</span> num, <span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">bool</span> isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)
    {
        isNeg = <span class="keyword">true</span>;
        num = -num;
    }
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(num)
    {
        <span class="keyword">str</span>[i] = num % <span class="number">10</span>;
        num /= <span class="number">10</span>;
        i++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">str</span>[i++] = <span class="string">'-'</span>;
    <span class="keyword">for</span>(j = <span class="number">0</span>, k = i-<span class="number">1</span>; j &lt; k; j++, k--)
    {
        <span class="keyword">char</span> ch = <span class="keyword">str</span>[j];
        <span class="keyword">str</span>[j] = <span class="keyword">str</span>[k];
        <span class="keyword">str</span>[k] = ch;
    }
    <span class="keyword">str</span>[i] = <span class="string">'\0'</span>;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><h2 id="自己实现一个String">自己实现一个String</h2><h3 id="注意点-3">注意点</h3><ul>
<li>参数不修改使用const</li>
<li>构造函数<ul>
<li>为m_data申请空间，包括字符串结束符’\0’</li>
<li><code>const char* str</code>,判断传入<code>char* str</code>参数是否为空</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>复制一个对象，一定需要申请新的空间</li>
<li><code>strlen(other.m_data)</code>在类中获取m_data指针</li>
<li>使用字符串函数strcpy</li>
</ul>
</li>
<li>析构函数<ul>
<li><code>delete [] m_data;</code></li>
</ul>
</li>
<li>赋值函数<ul>
<li>判断this == &amp;rhs</li>
<li>先申请空间，再释放原空间，再赋值(避免申请失败造成不了后果)</li>
</ul>
</li>
<li>重载操作符<ul>
<li>考虑返回引用(operator=)or值(operator+)</li>
<li>一般单目运算符使用成员函数重载，双目运算符使用友元</li>
<li>MyString&amp; other参数是否和this相等</li>
<li>重载operator+,判断源字符串为空</li>
<li>重载operator==，使用strcmp</li>
</ul>
</li>
</ul>
<h3 id="代码-2">代码</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">class</span> MyString
{
<span class="keyword">public</span>:
    MyString();
    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str);
    MyString(<span class="keyword">const</span> MyString&amp; other);
    ~MyString();
    MyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs);
    MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index);
    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs);
<span class="keyword">private</span>:
    <span class="keyword">char</span>* m_data;
};

MyString::MyString()
{
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
    *m_data = <span class="string">'\0'</span>;
}

MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)
{
    <span class="keyword">if</span>(str == NULL)
    {
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
        *m_data = <span class="string">'\0'</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(m_data, str);
    }
}

MyString::MyString(<span class="keyword">const</span> MyString&amp; other)
{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
    <span class="built_in">strcpy</span>(m_data, other.m_data);
}

MyString::~MyString()
{
    <span class="keyword">delete</span> [] m_data;
}

MyString&amp; MyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)
    {
        <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(temp, rhs.m_data);
        <span class="keyword">delete</span> [] m_data;
        m_data = NULL;
        m_data = temp;
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}

MyString MyString::<span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs)
{
    MyString newStr;
    <span class="keyword">if</span>(rhs.m_data == NULL)
        newStr = *<span class="keyword">this</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(m_data == NULL)
        newStr = rhs;
    <span class="keyword">else</span>
    {
        newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(newStr.m_data, m_data);
        <span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);
    }
    <span class="keyword">return</span> newStr;
}

<span class="keyword">char</span> MyString::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index)
{
    <span class="keyword">return</span> m_data[index];
}

<span class="keyword">bool</span> MyString::<span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">int</span> result = <span class="built_in">strcmp</span>(m_data, rhs.m_data);
    <span class="keyword">return</span> (<span class="number">0</span> == result);
}

ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs)
{
    output &lt;&lt; rhs.m_data;
    <span class="keyword">return</span> output;
}
</code></pre><h2 id="Singleton">Singleton</h2><h3 id="简单写法">简单写法</h3><pre><code>class Singleton
{<span class="keyword">
public</span>:
   <span class="keyword"> static</span> Singleton*<span class="function"> getInstance(</span><span class="function">)</span>;
    virtual<span class="function"> ~Singleton(</span><span class="function">)</span>;<span class="keyword">
private</span>:
   <span class="function"> Singleton(</span><span class="function">)</span>;
   <span class="keyword"> static</span> Singleton *instance;
};

Singleton* Singleton::instance = NU<span class="class">LL;</span>//如果允许在这里直接new出来可以避免多线程的影响
Singleton::Singleton(<span class="function">)</span>{}
Singleton::~Singleton(<span class="function">)</span>
{
    delete instance;
   <span class="instruction"> instance </span>= NU<span class="class">LL;</span>
}

Singleton*<span class="function"> Singleton::getInstance(</span><span class="function">)</span>
{
   <span class="function"> if(</span>instance == NULL<span class="function">)</span>
    {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
    }
   <span class="instruction"> return </span>instance;
}
</code></pre><h3 id="模板+资源管理+线程安全">模板+资源管理+线程安全</h3><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Singleton</span>
{
private:
    <span class="type">Singleton</span>(){};
    <span class="keyword">static</span> auto_ptr&lt;T&gt; <span class="keyword">ptr</span>;
public:
    <span class="keyword">static</span> auto_ptr&lt;T&gt; getInstance()
    {
        <span class="type">Mutex</span> mutex;
        mutex.lock();
        <span class="keyword">if</span>(! <span class="keyword">ptr</span>.get())
        {
            auto_ptr&lt;T&gt; temp(new T);
            <span class="keyword">ptr</span> = temp;
        }
        <span class="keyword">return</span> <span class="keyword">ptr</span>;
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/常用函数/"> #常用函数 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-一般题目/">
                二叉树专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/">
                二叉树专题-二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-二叉查找树/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-基础/">
                二叉树专题-基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/04/找工作总结-链表专题/">
                链表专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/04/找工作总结-链表专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/04/找工作总结-链表专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="keyword">next</span>;
    ListNode(<span class="keyword">int</span> x):val(x),<span class="keyword">next</span>(<span class="keyword">NULL</span>){}
};
</code></pre><h3 id="求链表中节点个数">求链表中节点个数</h3><pre><code><span class="keyword">int</span> getLength(ListNode* head)
{
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">while</span>(head)
    {
        head = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">count</span>++;
    }
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><h3 id="单链表翻转">单链表翻转</h3><pre><code><span class="constant">ListNode*</span> reverseList(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> newHead = <span class="constant">NULL;</span>
    <span class="constant">ListNode*</span> node = head;
    <span class="keyword">while</span>(node)
    {
        <span class="constant">ListNode*</span> temp = node-&gt;<span class="keyword">next</span>;
        node-&gt;<span class="keyword">next</span> = newHead;
        newHead = node;
        node = temp-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中倒数第k个节点">查找链表中倒数第k个节点</h3><pre><code>ListNode* getLastK(ListNode* head, <span class="built_in">int</span> k)
{
    ListNode* fisrt = head;
    ListNode* <span class="built_in">second</span> = head;
    <span class="keyword">while</span>(k--)
    {
        <span class="keyword">if</span>(first)
            first = first-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            return <span class="literal">NULL</span>;
    }
    <span class="keyword">while</span>(first)
    {
        fisrt = first-&gt;<span class="keyword">next</span>;
        <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>;
    }
    return <span class="built_in">second</span>;
}
</code></pre><h3 id="删除链表中第k个节点">删除链表中第k个节点</h3><pre><code>ListNode* deleteK(ListNode* head, <span class="keyword">int</span> k)
{
    <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)
        <span class="keyword">return</span> head;
    ListNode* toBeDelete;
    ListNode* newHead;
    <span class="keyword">if</span>(k == <span class="number">1</span>)
    {
        toBeDelete = head;
        newHead = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">delete</span> toBeDelete;
        <span class="keyword">return</span> newHead;
    }
    newHead = head;
    ListNode* node = head;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">2</span>; i++)
    {
        <span class="keyword">if</span>(node)
            node = node-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> newHead;
    }
    <span class="keyword">if</span>(node == <span class="keyword">NULL</span> || node-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)
        <span class="keyword">return</span> newHead;
    toBeDelete = node-&gt;<span class="keyword">next</span>;
    node-&gt;<span class="keyword">next</span> = node-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    <span class="keyword">delete</span> toBeDelete;
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中间节点">查找链表中间节点</h3><pre><code><span class="constant">ListNode*</span> findMiddle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> first = head;
    <span class="constant">ListNode*</span> second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = fisrt-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        if(first)
            second = second-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> second;
}
</code></pre><h3 id="从尾到头打印链表">从尾到头打印链表</h3><pre><code>void reversePrint(<span class="type">ListNode</span>* head)
{
    <span class="type">ListNode</span>* node = head;
    stack&lt;<span class="type">ListNode</span>*&gt; s;
    <span class="keyword">while</span>(node)
    {
        s.push(node);
        node = node-&gt;next;
    }
    <span class="keyword">while</span>(!s.empty<span class="literal">()</span>)
    {
        cout&lt;&lt;s.top<span class="literal">()</span>-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">" "</span>;
        s.pop<span class="literal">()</span>;
    }
}
</code></pre><h3 id="单链表排序，选择排序">单链表排序，选择排序</h3><pre><code>void sortList(<span class="type">ListNode</span>* head)
{
    <span class="keyword">for</span>(<span class="type">ListNode</span>* p = head; p != <span class="type">NULL</span>; p = p-&gt;next)
    {
        <span class="type">ListNode</span>* min = p;
        <span class="keyword">for</span>(<span class="type">ListNode</span>* q = p-&gt;next; q != <span class="type">NULL</span>; q = q-&gt;next)
        {
            <span class="keyword">if</span>(q-&gt;<span class="keyword">val</span> &lt; min-&gt;<span class="keyword">val</span>)
                min = q;
        }
        <span class="built_in">int</span> temp = p-&gt;<span class="keyword">val</span>;
        p-&gt;<span class="keyword">val</span> = min-&gt;<span class="keyword">val</span>;
        min-&gt;<span class="keyword">val</span> = temp;
    }
}
</code></pre><h3 id="合并两个有序链表">合并两个有序链表</h3><pre><code>ListNode<span class="subst">*</span> mergeList(ListNode<span class="subst">*</span> list1, ListNode<span class="subst">*</span> list2)
{
    <span class="keyword">if</span>(list1 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list2;
    <span class="keyword">if</span>(list2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list1;
    ListNode<span class="subst">*</span> head <span class="subst">=</span> <span class="built_in">NULL</span>;
    ListNode <span class="subst">*</span>node1 <span class="subst">=</span> list1, <span class="subst">*</span>node2 <span class="subst">=</span> list2;
    ListNode <span class="subst">*</span>tnode <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
    {
        head <span class="subst">=</span> node1;
        node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
    }
    <span class="keyword">else</span>
    {
        head <span class="subst">=</span> node2;
        node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
    }
    tnode <span class="subst">=</span> head;
    tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">while</span>(node1 <span class="subst">&amp;&amp;</span> node2)
    {
        <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
            node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
        <span class="keyword">else</span>
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
            node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
    }
    <span class="keyword">if</span>(node1)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
    <span class="keyword">if</span>(node2)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
    <span class="keyword">return</span> head;
}
</code></pre><h3 id="判断一个链表是否有环">判断一个链表是否有环</h3><pre><code>bool hasCircle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode </span>*first = head, *second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = first-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        second = second-&gt;<span class="keyword">next</span>;
        if(first == second)
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="判断两个链表是否相交">判断两个链表是否相交</h3><pre><code>bool isJoin(<span class="constant">ListNode </span>*list1, <span class="constant">ListNode </span>*list2)
{
    if(list1 == <span class="constant">NULL </span>|| list2 == <span class="constant">NULL)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="constant">ListNode </span>*n1 = list1, *n2 = list2;
    <span class="keyword">while</span>(n1-&gt;<span class="keyword">next</span>)
        n1 = n1-&gt;<span class="keyword">next</span>;
    <span class="keyword">while</span>(n2-&gt;<span class="keyword">next</span>)
        n2 = n2-&gt;<span class="keyword">next</span>;
    <span class="keyword">return</span> (n1 == n2);
}
</code></pre><h3 id="判断两个链表相交的第一个节点">判断两个链表相交的第一个节点</h3><ol>
<li>判断两个链表是否相交，得到两个链表长度len1,len2</li>
<li>假设len1 &gt; len2，n1先走(len1-len2)步</li>
<li>n1,n2一起走，直到n1 == n2</li>
</ol>
<h3 id="如果一个链表有环，求进入环中的第一个节点">如果一个链表有环，求进入环中的第一个节点</h3><ol>
<li>使用上面的方法判断是否有环</li>
<li>在环中走一圈得到环的长度len</li>
<li>前后两个节点一个先走len步（走一个环的长度），两个一起走相遇在环的入口</li>
</ol>
<h3 id="在O(1)的时间内删除节点">在O(1)的时间内删除节点</h3><pre><code><span class="literal">void</span> deleteInO1(ListNode<span class="subst">*</span> <span class="built_in">list</span>, ListNode<span class="subst">*</span> toBeDelete)
{
    <span class="keyword">if</span>(<span class="built_in">list</span> <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> toBeDelete <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="keyword">if</span>(toBeDelete <span class="subst">==</span> <span class="built_in">list</span>)
    {
        <span class="built_in">list</span> <span class="subst">=</span> <span class="built_in">list</span><span class="subst">-&gt;</span>next;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    <span class="keyword">if</span>(toBeDelete<span class="subst">-&gt;</span>next <span class="subst">==</span> <span class="built_in">NULL</span>)
    {
        ListNode<span class="subst">*</span> node <span class="subst">=</span> <span class="built_in">list</span>;
        <span class="keyword">while</span>(node <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>next <span class="subst">!=</span> toBeDelete)
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>next;
        node<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    ListNode<span class="subst">*</span> temp <span class="subst">=</span> toBeDelete<span class="subst">-&gt;</span>next;
    toBeDelete<span class="subst">-&gt;</span>val <span class="subst">=</span> temp<span class="subst">-&gt;</span>val;
    toBeDelete<span class="subst">-&gt;</span>next <span class="subst">=</span> temp<span class="subst">-&gt;</span>next;
    delete temp;
    <span class="keyword">return</span> ;
}
</code></pre><h2 id="特殊题目">特殊题目</h2><h3 id="剑指offer57_删除链表中的重复节点">剑指offer57 删除链表中的重复节点</h3><h4 id="问题描述">问题描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法">解法</h4><p>使用preNode和node指向最后一个未删除的节点和第一个可能删除的节点</p>
<ul>
<li>如果保留重复元素的第一个<br>只需要使用node扫描一次，判断和preNode-&gt;val是否相等，分两种情况处理即可</li>
<li>如果不保留重复元素<br>需要确定新的头元素newHead,需要判断是否重复，因为需要全部删除。</li>
</ul>
<h4 id="类型1的代码">类型1的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode *deleteDuplicates(ListNode *head) {
        <span class="keyword">if</span>(<span class="keyword">NULL</span> == head || <span class="keyword">NULL</span>==head-&gt;next)
            <span class="keyword">return</span> head;
        ListNode *preNode = head;
        ListNode *node = preNode-&gt;next;
        <span class="keyword">while</span>(node)
        {
            <span class="keyword">if</span>(node-&gt;val == preNode-&gt;val)
            {
                ListNode* temp = node;
                node = node-&gt;next;
                preNode-&gt;next = node;
                delete temp;
            }
            <span class="keyword">else</span>
            {
                node = node-&gt;next;
                preNode = preNode-&gt;next;
            }
        }
        <span class="keyword">return</span> head;
    }
};
</code></pre><h4 id="类型2的代码">类型2的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> head;
        ListNode *node = head;
        ListNode *newHead = <span class="keyword">NULL</span>;
        ListNode *preNode = <span class="keyword">NULL</span>;
        <span class="keyword">while</span>(node)
        {
            bool isDuplicated = <span class="keyword">false</span>;
            <span class="keyword">if</span>(node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)
                isDuplicated = <span class="keyword">true</span>;
            <span class="keyword">if</span>(isDuplicated)
            {
                int val = node-&gt;val;
                <span class="keyword">while</span>(node!= <span class="keyword">NULL</span> &amp;&amp; node-&gt;val == val)
                {
                    ListNode *temp = node;
                    node = node-&gt;next;
                    delete temp;
                }
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(!newHead)
                {
                    newHead = node;
                    preNode = node;
                }
                <span class="keyword">else</span>
                {
                    preNode-&gt;next = node;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
        }
        <span class="keyword">if</span>(preNode)
            preNode-&gt;next = <span class="keyword">NULL</span>;
        <span class="keyword">return</span> newHead;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/链表/"> #链表 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/03/找工作总结-栈和队列专题/">
                栈和队列专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/03/找工作总结-栈和队列专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/03/找工作总结-栈和队列专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法">解法</h4><p>两个栈stack1,stack2。完成push和pop函数即可。</p>
<ul>
<li>push的时候向stack1压栈。</li>
<li>pop的时候<br>(1)stack2不为空，弹出stack2.top<br>(2)stack1不为空，把stack1中的元素全部弹出到stack2，然后弹出stack2.top<br>(3)如果stack1和stack2都是空，那么抛出异常<h4 id="注意点">注意点</h4></li>
<li>模板的写法</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">MyQueue</span>
{
public:
    <span class="type">void</span> push(<span class="keyword">const</span> T&amp; item);
    T pop();
private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> <span class="type">MyQueue</span>::push(<span class="keyword">const</span> T&amp; item)
{
    stack1.push(item);
}

<span class="keyword">template</span>&lt;typename T&gt;
T <span class="type">MyQueue</span>::pop()
{
    <span class="keyword">if</span>(!stack2.empty())
    {
        T temp = stack2.top();//?是否需要引用
        stack2.pop();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(!stack1.empty())
    {
        <span class="keyword">while</span>(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }
    <span class="keyword">else</span>
        throw exception(<span class="string">"MyQueue is empty!"</span>);
}
</code></pre><h4 id="扩展问题，使用两个队列实现栈">扩展问题，使用两个队列实现栈</h4><p>有queue1，queue2两个队列，完成push,pop。</p>
<ul>
<li>push<br>如果queue1.empty &amp;&amp; queue.empty 向queue1中push<br>如果有一个不为空，向不为空的队列里push</li>
<li>pop<br>如果queue1.empty &amp;&amp; queue.empty 抛出异常<br>把不为空的队列出队到空队列，直到剩下一个元素，弹出这个元素</li>
</ul>
<h3 id="剑指offer21_包含min函数的栈">剑指offer21 包含min函数的栈</h3><h4 id="问题描述-1">问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解法-1">解法</h4><p>使用stack1,stack2两个栈，stack1压入原本的元素，stack2只压最小元素</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">int</span> tempMin;
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            tempMin = <span class="keyword">value</span>;
        <span class="keyword">else</span>
        {
            tempMin = s2.top();
            <span class="keyword">if</span>(<span class="keyword">value</span> &lt; tempMin)
                tempMin = <span class="keyword">value</span>;
        }
        s1.push(<span class="keyword">value</span>);
        s2.push(tempMin);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">pop</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span>;
        s1.pop();
        s2.pop();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s1.top();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">min</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s2.top();
    }
<span class="keyword">private</span>:
    stack&lt;<span class="keyword">int</span>&gt; s1;
    stack&lt;<span class="keyword">int</span>&gt; s2;
};
</code></pre><h3 id="剑指offer22_栈的压入弹出序列">剑指offer22 栈的压入弹出序列</h3><h4 id="问题描述-2">问题描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h4 id="解法-2">解法</h4><p>使用一个栈stack进行模拟，遍历数组元素：</p>
<ul>
<li>如果<code>vec[i] != stack.top</code>，压入</li>
<li>如果<code>vec[i] == stack.top</code>，弹出</li>
<li><code>i == vec.size</code>时，判断栈是否为空</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    bool IsPopOrder<span class="params">(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)</span> {
        <span class="keyword">if</span><span class="params">(pushV.size<span class="params">()</span> != popV.size<span class="params">()</span>)</span>
            return <span class="literal">false</span>;
        stack&lt;int&gt; s;
        int i=<span class="number">0</span>,j=<span class="number">0</span>;
        <span class="keyword">for</span><span class="params">(;j &lt; popV.size<span class="params">()</span>; j++)</span>
        {
            while<span class="params">(s.empty<span class="params">()</span> || <span class="params">(i &lt; pushV.size<span class="params">()</span> &amp;&amp; s.top<span class="params">()</span> != popV[j])</span>)</span>
                s.push<span class="params">(pushV[i++])</span>;
            <span class="keyword">if</span><span class="params">(s.top<span class="params">()</span> == popV[j])</span>
                s.pop<span class="params">()</span>;
            <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span>)</span>
                break;
        }
        <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span> &amp;&amp; j == popV.size<span class="params">()</span> &amp;&amp; s.empty<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="剑指offer65_滑动窗口最大值">剑指offer65 滑动窗口最大值</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解法-3">解法</h4><p>使用双端队列(dequeue)记录当前窗口最大值<strong>下标</strong>序列，每插入一个元素就向前删除。通过比较dequeue的第一个元素是当前窗口的最大元素<strong>下标</strong>，比较首元素下标和i-size判断删除队列头部元素。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>从后向前删除</li>
<li>最后一个窗口</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; maxInWindows(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, unsigned <span class="type">int</span> size)
    {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(num.size() &lt; size || size &lt; <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        deque&lt;<span class="type">int</span>&gt; indexes;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)
        {
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            indexes.push_back(i);
        }

        <span class="keyword">for</span>(<span class="type">int</span> i = size;i &lt; num.size(); i++)
        {
            <span class="literal">result</span>.push_back(num[indexes.front()]);
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; indexes.front() &lt;= (i-size))
                indexes.pop_front();
            indexes.push_back(i);
        }
        <span class="literal">result</span>.push_back(num[indexes.front()]);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/栈和队列/"> #栈和队列 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-两个指针/">
                数组专题-两个指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-两个指针/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-两个指针/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="通用解题思路">通用解题思路</h1><ul>
<li>使用快排中的partition函数</li>
<li>贪心,left++,right-直到相遇</li>
<li>二分查找，mid = (left + right) / 2</li>
</ul>
<h2 id="k-sum问题">k-sum问题</h2><p>k-sum问题解题思路:<br>先对数组进行排序(nlogn)。退化成2-sum问题，使用left,right指针向中间查找。最终把复杂度优化到O(n^(k-1))</p>
<h3 id="剑指offer41_和为S的两个数字_VS_和为S的连续正数序列">剑指offer41 和为S的两个数字 VS 和为S的连续正数序列</h3><h4 id="问题描述">问题描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<h4 id="解法">解法</h4><p>2-sum问题，乘积最小的两个数字就是left和right第一次满足条件的两个数字。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    vector&lt;<span class="built_in">int</span> &gt; FindNumbersWithSum(vector&lt;<span class="built_in">int</span>&gt; <span class="built_in">array</span>,<span class="built_in">int</span> sum) {
        vector&lt;<span class="built_in">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) return vec;
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &lt; sum)
                <span class="built_in">left</span>++;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &gt; sum)
                <span class="built_in">right</span>--;
            <span class="keyword">else</span>
            {
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">left</span>]);
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">right</span>]);
                return vec;
            }
        }
        return vec;
    }
};
</code></pre><h4 id="问题描述-1">问题描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<h4 id="解法-1">解法</h4><p>同上，不过比较条件变成。(left+right)(right-left+1)/2</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(sum &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;
        <span class="keyword">while</span>(right &lt;= (sum + <span class="number">1</span>) / <span class="number">2</span>)
        {
            <span class="keyword">int</span> temp = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(temp &lt; sum)
                right++;
            <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; sum)
                left++;
            <span class="keyword">else</span>
            {
                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)
                    vec.push_back(i);
                <span class="built_in">list</span>.push_back(vec);
                right++;
            }
        }
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }
};
</code></pre><h3 id="leetcode18_4Sum">leetcode18 4Sum</h3><h4 id="问题描述-2">问题描述</h4><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<ul>
<li>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)</li>
<li><p>The solution set must not contain duplicate quadruplets.</p>
<pre><code>For example, given<span class="instruction"> array </span>S = {1 0 -1 0 -2 2},<span class="instruction"> and </span>target = 0.

A solution set is:
(-1,  0, 0, 1<span class="function">)</span>
(-2, -1, 1, 2<span class="function">)</span>
(-2,  0, 0, 2<span class="function">)</span>
</code></pre></li>
</ul>
<h4 id="解法-2">解法</h4><p>先排序，退化到2-sum问题。</p>
<h4 id="注意点">注意点</h4><p>题目要求找出所有满足条件的数组，需要避免重复。</p>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//思路：K-Sum问题，复杂度降到O(n^(k-1))</span>
<span class="comment">//注意，不能重复，num个数不够4</span>
<span class="comment">//去重，left，right去重，i层循环去重，j层循环去重</span>
    vector&lt;vector&lt;<span class="built_in">int</span>&gt; &gt; fourSum(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>, <span class="built_in">int</span> target) {
        sort(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());
        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; list;
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() &lt; <span class="number">4</span>) 
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.size()-<span class="number">3</span>; i++)
        {
            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num</span>.size()- <span class="number">2</span>; j++)
            {
                <span class="built_in">int</span> left = j + <span class="number">1</span>, right = <span class="built_in">num</span>.size() - <span class="number">1</span>;
                <span class="keyword">while</span>(left &lt; right)
                {
                    <span class="built_in">int</span> sum = <span class="built_in">num</span>[i]+<span class="built_in">num</span>[j]+<span class="built_in">num</span>[left]+<span class="built_in">num</span>[right];
                    <span class="keyword">if</span>(sum &lt; target)
                        left++;
                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)
                        right--;
                    <span class="keyword">else</span>
                    {
                        vector&lt;<span class="built_in">int</span>&gt; vec;
                        vec.push_back(<span class="built_in">num</span>[i]);
                        vec.push_back(<span class="built_in">num</span>[j]);
                        vec.push_back(<span class="built_in">num</span>[left]);
                        vec.push_back(<span class="built_in">num</span>[right]);
                        list.push_back(vec);
                        left++;
                        right--; 
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[left] == <span class="built_in">num</span>[left - <span class="number">1</span>]) 
                            left++;
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[right] == <span class="built_in">num</span>[right + <span class="number">1</span>]) 
                            right--;
                    }
                }
                <span class="keyword">while</span>(j + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">2</span> &amp;&amp; <span class="built_in">num</span>[j] == <span class="built_in">num</span>[j + <span class="number">1</span>]) 
                    j++;
            }
            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">3</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i+<span class="number">1</span>]) 
                i++;
        }
        <span class="keyword">return</span> list;
    }
};
</code></pre><h2 id="二分查找问题">二分查找问题</h2><p>二分查找通用解题思路，left=头指针，right=尾指针，mid=(left+right)/2，通过条件判断，移动left和right最终使得left和right相遇得到最终结果。</p>
<h3 id="普通二分查找">普通二分查找</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个<strong>有序数组，可能含有重复元素</strong>。给定target，寻找target出现的下标，不存在返回-1.</p>
<h4 id="代码-3">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] == target)
            return <span class="built_in">mid</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><h3 id="等于target的第一个元素">等于target的第一个元素</h3><h4 id="问题描述-4">问题描述</h4><p>给定有序数组a,含有重复元素，求最小(或者求最大)的使得a[i]等于target的下标。不存在返回-1.<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnyv9bn30j20fg057q2z.jpg" alt=""></p>
<h4 id="代码-4">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] == target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="小于target的第一个元素">小于target的第一个元素</h3><h4 id="问题描述-5">问题描述</h4><p>给定有序数组a,含有重复元素，求最大的i使得a[i]小于target。不存在返回-1<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewnyykveyaj20bt04edfv.jpg" alt=""></p>
<h4 id="代码-5">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &gt;= target)
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] &lt; target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="求target在数组中的出现次数">求target在数组中的出现次数</h3><h4 id="解法-3">解法</h4><p>出现次数 = 最后一次出现位置 - 第一次出现位置 + 1<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnz2xlz25j20ep05ewek.jpg" alt=""></p>
<h4 id="代码-6">代码</h4><pre><code><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N, <span class="keyword">int</span> <span class="keyword">target</span>)</span>
</span>{
    <span class="keyword">int</span> first = searchFisrt(a, N, <span class="keyword">target</span>);
    <span class="keyword">if</span>(first == -<span class="number">1</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> last = searchLast(a, N, <span class="keyword">target</span>);
    <span class="keyword">return</span> (last - first + <span class="number">1</span>);
}
</code></pre><h3 id="插入的位置（小于等于target的第一个元素）">插入的位置（小于等于target的第一个元素）</h3><h4 id="问题描述-6">问题描述</h4><p>给定有序数组a,含有重复元素，若target在数组中出现，返回位置，如果不存在，返回应该插入的位置。</p>
<h4 id="解法-4">解法</h4><p>&lt;=target是可能的位置<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1ewo0ah8apsj20cf03lgln.jpg" alt=""></p>
<h4 id="代码-7">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt;= target)
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>; 
    }
    return <span class="built_in">left</span>;
}
</code></pre><h2 id="旋转数组的二分查找">旋转数组的二分查找</h2><h3 id="leetcode_33_Search_in_Rotated_Sorted_Array">leetcode 33 Search in Rotated Sorted Array</h3><h4 id="问题描述-7">问题描述</h4><p>给定有序数组，在某一个位置发生旋转，求target在数组中出现的位置。<strong>无重复元素</strong>，找到返回下标，找不到返回-1.</p>
<h4 id="解法-5">解法</h4><p>先判断mid落在了旋转数组的哪一部分，然后判断和target的关系<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewo177qwiyj20c507cq32.jpg" alt=""></p>
<h4 id="代码-8">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int <span class="keyword">left</span> = <span class="number">0</span>,<span class="keyword">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)
        {
            int mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[mid] == target)
                <span class="keyword">return</span> mid;
            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="keyword">left</span>])<span class="comment">//left-mid升序</span>
            {
                <span class="keyword">if</span>(nums[<span class="keyword">left</span>] &lt;= target &amp;&amp; target &lt; nums[mid])
                    <span class="keyword">right</span> = mid-<span class="number">1</span> ;
                <span class="keyword">else</span>
                    <span class="keyword">left</span> = mid+<span class="number">1</span>;
            }
            <span class="keyword">else</span><span class="comment">//mid-right升序</span>
            {
                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="keyword">right</span>])
                    <span class="keyword">left</span> = mid +<span class="number">1</span>;
                <span class="keyword">else</span>
                {
                    <span class="keyword">right</span> = mid-<span class="number">1</span>;
                }
            }
        }
        <span class="keyword">if</span>(nums[<span class="keyword">left</span>] == target)
            <span class="keyword">return</span> <span class="keyword">left</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> -<span class="number">1</span>;
    }
};
</code></pre><h3 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h3><h4 id="问题描述-8">问题描述</h4><p>其他条件相同，但允许数组中存在重复元素。判断target是否出现在数组中。</p>
<h4 id="解法-6">解法</h4><p>增加判断条件，当a[left] = a[mid] = a[right]，直接遍历去寻找，不能使用二分查找</p>
<h4 id="代码-9">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> target) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>,<span class="built_in">right</span> = nums.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == target)
                return <span class="literal">true</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == nums[<span class="built_in">left</span>] &amp;&amp; nums[<span class="built_in">mid</span>] == nums[<span class="built_in">right</span>])
            {
                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; i++)
                {
                    <span class="keyword">if</span>(nums[i] == target)
                        return <span class="literal">true</span>;
                }
                return <span class="literal">false</span>;
            }
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt;= nums[<span class="built_in">left</span>])
            {
                <span class="keyword">if</span>(target &gt;= nums[<span class="built_in">left</span>] &amp;&amp; target &lt; nums[<span class="built_in">mid</span>])
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(target &gt; nums[<span class="built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="built_in">right</span>])
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
            }
        }
        <span class="keyword">if</span>(nums[<span class="built_in">left</span>] == target)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="leetcode_153_Find_Minimum_in_Rotated_Sorted_Array">leetcode 153    Find Minimum in Rotated Sorted Array</h3><h4 id="问题描述-9">问题描述</h4><p>给定有序数组，<strong>无重复元素</strong>，在某一位置发生旋转，求数组中的最小元素</p>
<h4 id="解法-7">解法</h4><p>同上<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewo7wvjpz5j20as05ugln.jpg" alt=""></p>
<h4 id="注意点-1">注意点</h4><ul>
<li>对于数组旋转个数为0的考虑<br>如果使用a[mid] &gt;= a[left]判断，需要考虑数组是否并没有旋转(a[left] &lt; a[right])</li>
<li>也可以使用这样的条件进行判断 a[mid] &gt; a[right]</li>
</ul>
<h4 id="代码-10">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h3 id="leetcode_Find_Minimum_in_Rotated_Sorted_Array_II">leetcode Find Minimum in Rotated Sorted Array II</h3><h4 id="问题描述-10">问题描述</h4><p>同上，不过允许数组中存在重复元素</p>
<h4 id="解法-8">解法</h4><p>对a[mid] = a[right]时，right—。因为a[left] &lt;= a[right] == a[mid],为了使得a[mid]最小，需要对使得left和right逐渐接近，需要遍历才能找到，所以对right进行减一操作。</p>
<h4 id="代码-11">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span>--;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h2 id="一般题目">一般题目</h2><h3 id="剑指offer14_调整数组顺序使奇数位于偶数之前">剑指offer14 调整数组顺序使奇数位于偶数之前</h3><h4 id="问题描述-11">问题描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="解法-9">解法</h4><ul>
<li>使用插入排序的思想，复杂度O(n^2)</li>
<li>使用额外的O(n)存储，遍历原数组，计数从前往后放，偶数从后往前放。时间复杂度O(n)</li>
<li>补充，如果不需要保证相对位置，可以使用快排的partition函数做一次扫描。</li>
</ul>
<h4 id="方法2的代码">方法2的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">array</span>) {
        vector&lt;<span class="built_in">int</span>&gt; vec(<span class="built_in">array</span>.size());
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="built_in">int</span> leftIndex = <span class="number">0</span>, rightIndex = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
                vec[leftIndex++] = <span class="built_in">array</span>[<span class="built_in">left</span>++];
        }
        <span class="keyword">while</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">if</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
                vec[rightIndex--] = <span class="built_in">array</span>[<span class="built_in">right</span>--];
        }
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
            <span class="built_in">array</span>[i] = vec[i];
    }  
};
</code></pre><h4 id="方法3的代码">方法3的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
            {
                <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
                <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
                <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            }
        }
    }
};
</code></pre><h3 id="剑指offer36_数组中的逆序对">剑指offer36 数组中的逆序对</h3><h4 id="问题描述-12">问题描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="解法-10">解法</h4><p>使用归并排序的merge过程，统计逆序对的个数。merge过程需要merge,left~mid和mid~right。假如vec[lpos] &gt; vec[rpos],逆序对的个数需要增加<strong>mid-lpos+1</strong>个，因为vec中所有lpos之后的元素和rpos对应的元素都形成了逆序对。</p>
<h4 id="代码-12">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> InversePairs(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; temp(<span class="type">data</span>.<span class="built_in">size</span>());
        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;
        mergeSort(<span class="type">data</span>, temp, <span class="number">0</span>, <span class="type">data</span>.<span class="built_in">size</span>()-<span class="number">1</span>, <span class="built_in">count</span>);
        <span class="keyword">return</span> <span class="built_in">count</span>;
    }

    void mergeSort(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="keyword">if</span>(left &lt; right)
        {
            <span class="built_in">int</span> mid = (left + right) / <span class="number">2</span>;
            mergeSort(<span class="type">data</span>, temp, left, mid, <span class="built_in">count</span>);
            mergeSort(<span class="type">data</span>, temp, mid + <span class="number">1</span>, right, <span class="built_in">count</span>);
            <span class="built_in">merge</span>(<span class="type">data</span>, temp, left, mid, right, <span class="built_in">count</span>);
        }
    }

    void <span class="built_in">merge</span>(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> mid, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="built_in">int</span> lend = mid, rend = right;
        <span class="built_in">int</span> lpos = left, rpos = mid + <span class="number">1</span>, tpos = left;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(<span class="type">data</span>[lpos] &lt;= <span class="type">data</span>[rpos])
                temp[tpos++] = <span class="type">data</span>[lpos++];
            <span class="keyword">else</span>
            {
                <span class="built_in">count</span> += mid-lpos+<span class="number">1</span>;
                temp[tpos++] = <span class="type">data</span>[rpos++];
            }
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++]=<span class="type">data</span>[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = <span class="type">data</span>[rpos++];
        for(<span class="built_in">int</span> i = left; i &lt;= right; i++)
            <span class="type">data</span>[i] = temp[i];
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/两个指针/"> #两个指针 </a>
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">42</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
