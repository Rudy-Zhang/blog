<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/21/effectiveCPP读书笔记/">
                Effective C++ 读书笔记
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-08-20
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/编程语言/">编程语言</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/08/21/effectiveCPP读书笔记/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/21/effectiveCPP读书笔记/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C++ 使用模板编程</li>
<li>STL</li>
</ul>
<p>每一个部分都有各自的规约</p>
<h2 id="条款2，_尽量以const，enum，inline替换#define">条款2， 尽量以const，enum，inline替换#define</h2><ul>
<li><h1 id="define只有替换功能，在预处理阶段完成，没有类型检查，也没有封装性">define只有替换功能，在预处理阶段完成，没有<strong>类型检查</strong>，也没有封装性</h1></li>
<li>使用const替代变量定义，inline替代函数定义</li>
<li>预处理器中，#include必不可少，#ifdef，#else可以用来进行控制编译</li>
</ul>
<h2 id="条款3，尽可能使用const">条款3，尽可能使用const</h2><p>只要是事实，就把它说出来。只要是const就要声明为const类型。</p>
<ul>
<li>const修饰变量<br>const char <em>p = greeting等价于char const </em>p = greeting<br>char * const p = greeting 指针不可更改指向对象</li>
<li>const修饰函数，是最有威力的应用</li>
</ul>
<p>(1) const 返回值</p>
<p>(2) const 函数参数，使用最多</p>
<p>(3) const 成员函数，表明这个函数不能修改任何成员变量（static变量可以修改），也不能调用任何非const成员</p>
<p>补充，<br>volidate int a，告诉编译器这个值可能被未知因素修改，每次都要从内存中重新读取<br>mutable int a，可以突破const成员函数限制，在函数中被修改</p>
<h2 id="条款4，确定对象被使用前已先被初始化">条款4，确定对象被使用前已先被初始化</h2><ul>
<li><p>成员初始化应该在构造函数之前，意味着要使用<strong>成员初始化列表</strong>进行成员变量的初始化<br>说明：成员变量总是以声明的次序被初始化</p>
</li>
<li><p>对于static变量，使用Singleton+inline，保证在对象使用前初始化</p>
</li>
</ul>
<h2 id="条款5，了解C++默默编写并调用了哪些函数">条款5，了解C++默默编写并调用了哪些函数</h2><p>构造函数，拷贝构造函数，赋值函数，析构函数</p>
<h2 id="条款6，若不想使用编译器自动生成的函数，就该明确拒绝">条款6，若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul>
<li>如果某些对象不可复制（不能使用copy constructor）<br>不是很安全的做法：把拷贝构造函数声明为private<br>更好的做法：写一个<strong>UnCopyable基类</strong>，copy constructor声明为private</li>
</ul>
<h2 id="条款7，为多态基类声明virtual析构函数">条款7，为多态基类声明virtual析构函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span></span>{}
A *b=<span class="keyword">new</span> B()
<span class="keyword">delete</span> b
</code></pre><p>因为b是A类型的指针，所以会导致局部销毁（只有A的部分被销毁）</p>
<p>原则：</p>
<ul>
<li><strong>企图作为（多态的）base class的类理论上都应该有virtual函数</strong>，否则不应该作为base class（虚指针会额外增加空间）</li>
<li>任何带有virtual 函数的类都应该把析构函数声明为virtual<br>不要试图继承任何STL容器，因为他们没有virtual的析构函数</li>
</ul>
<h2 id="条款8，别让异常逃离析构函数">条款8，别让异常逃离析构函数</h2><ul>
<li>析构函数不能抛出异常，否则会导致不明行为。</li>
<li>析构函数应该吞下这个异常，防止传播</li>
<li><strong>调用一个自己的函数，使得用户有机会来处理这个异常</strong>。 </li>
</ul>
<h2 id="条款9，_绝不要在构造或者析构过程中调用virtual函数">条款9， 绝不要在构造或者析构过程中调用virtual函数</h2><ul>
<li><p>构造过程</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:     
    A(){
         virtual <span class="function"><span class="title">fun</span><span class="params">()</span></span>
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{}</span></span>
B b;
</code></pre></li>
</ul>
<p>构造B-&gt;构造A-&gt;调用fun(),这时B还没构造完（被编译器看成A对象），导致virtual 函数不会下降到子类执行。</p>
<ul>
<li>析构过程<br>析构B-&gt;析构A-&gt;调用fun()，这时B已经被析构掉了，同样virtual函数不会下降，得不到想要的结果。</li>
</ul>
<h2 id="条款10，令operator=_返回一个reference_to_*this">条款10，令operator= 返回一个reference to *this</h2><p>为了保证连续运算如：A=B=C 相当于A = (B = C)<br>返回一个引用，不会调用copy constructor<br>对于+=同样适用</p>
<h2 id="条款11，在operator=_中处理自我赋值">条款11，在operator= 中处理自我赋值</h2><p>判断一下，if (this == &amp;rhs) return *this</p>
<h2 id="条款12，复制对象时勿忘其每一个成分">条款12，复制对象时勿忘其每一个成分</h2><p>可能出现的问题</p>
<p>（1）对象中的非内置类型不能得到赋值</p>
<p>（2）对象从父类继承而来的变量不能得到赋值</p>
<ul>
<li>赋值所有local成员（内置类型，对象）</li>
<li>调用所有base class中的适当的copy constructor</li>
</ul>
<h2 id="条款13，以对象管理资源">条款13，以对象管理资源</h2><p>C++申请释放的资源：堆内存（最常用），文件，互斥锁，数据库连接等。一旦申请资源，就必须释放，否则就会造成内存泄露。</p>
<p>以对象管理资源相当于，使用一个类（RAII类）封装这个资源，在构造时初始化，在析构时释放。声明这个对象时使用栈内存声明。</p>
<p>常用：</p>
<p><code>auto_ptr</code> ,封装对象，重写了指针行为，看起来像一个指针。只能指向一个对象。复制或者赋值，会删除原来的指针。</p>
<p><code>shared_ptr</code>，类似于auto_ptr，不过允许多个指针指向同一个对象，内部提供引用计数。<br>这两个是最常见的RAII类，在构造时初始化，析构时delete。（注意不能<code>auto_ptr</code>(new std::string[10])数组对象）</p>
<h2 id="条款14，在资源管理类中小心copying行为">条款14，在资源管理类中小心copying行为</h2><p>类似于<code>auto_ptr</code>或者<code>shared_ptr</code>的处理方式，对于复制。可以：</p>
<ul>
<li>禁止复制</li>
<li>引用计数，类似于shared_ptr</li>
</ul>
<h2 id="条款15，在资源管理类中提供对原始资源的访问">条款15，在资源管理类中提供对原始资源的访问</h2><p>隐式：如<code>auto_ptr</code>重写了指针行为，*ptr,<code>ptr-&gt;</code>使得这个变量看起来像一个指针。从而可以访问封装的资源</p>
<p>显示：提供get()函数返回资源</p>
<h2 id="条款16，使用new和delete时要采用相同的形式">条款16，使用new和delete时要采用相同的形式</h2><p>A *a=new A() ,释放时 使用delete a</p>
<p>int *a=new a[100],释放时使用delete []a</p>
<h2 id="条款17，以独立语句将newed对象置入智能指针">条款17，以独立语句将newed对象置入智能指针</h2><pre><code>std::tr1::shared_ptr&lt;Widget&gt; <span class="function"><span class="title">pw</span><span class="params">(new Widget)</span></span>
<span class="function"><span class="title">processWidget</span><span class="params">(pwd, priority()</span></span>)
</code></pre><p>使用单独语句，不要放到一起可能会造成编译先后导致指针丢失。<br>其实不是很明白这点</p>
<h2 id="条款18，让接口容易被使用，不易被误用">条款18，让接口容易被使用，不易被误用</h2><ul>
<li><p>导入新类型</p>
<pre><code><span class="built_in">Date</span>(<span class="built_in">int</span> <span class="built_in">month</span>, <span class="built_in">int</span> <span class="built_in">day</span>, <span class="built_in">int</span> <span class="built_in">year</span>)
</code></pre></li>
</ul>
<p>多个参数，使用Month，Day，Year类型，可以预防接口被误用</p>
<ul>
<li>接口一致性</li>
</ul>
<p>如:stl每个容器都有size()方法</p>
<h2 id="条款19，设计class犹如设计type">条款19，设计class犹如设计type</h2><p>设计一个类时需要考虑很多问题：</p>
<ol>
<li>创建和销毁</li>
<li>初始化（初始化列表），拷贝构造函数</li>
<li>pass by value &amp;&amp; pass by reference</li>
<li>继承关系</li>
<li>类型转换</li>
<li>操作符重载</li>
<li>标准函数驳回（private copy constructor）</li>
<li>public private</li>
<li>效率，异常</li>
<li>不够一般化，太过一般化</li>
<li>是否真的需要这个类型</li>
</ol>
<h2 id="条款20，_宁以pass_by_reference_to_const_替换_pass_by_value">条款20， 宁以pass by reference to const 替换 pass by value</h2><ul>
<li>区别</li>
</ul>
<p>pass by value:</p>
<p>要调用copy constructor，可能是费时的操作</p>
<p>pass by reference to const:</p>
<p>const Student &amp;s，const保证变量在函数内不会被修改</p>
<ul>
<li><p>pass by value可能导致多态失效</p>
<pre><code><span class="keyword">void</span> printNameAndDisplay（Window w）
</code></pre></li>
</ul>
<p>传入子类对象，不能实现多态</p>
<ul>
<li>在编译器底层，reference是通过指针来实现的</li>
</ul>
<h2 id="条款21，必须返回对象时，别妄想返回其reference">条款21，必须返回对象时，别妄想返回其reference</h2><pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator* (<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs)
</code></pre><p>如果返回reference</p>
<ul>
<li>返回local stack的对象（Rational r），则函数退出时，这个对象已经被销毁了</li>
<li>返回heap-allocate对象，会造成何时delete的问题。</li>
<li>返回static对象，if(a<em>b == c</em>d),导致一个static对象不够用的问题</li>
</ul>
<p>原则，必须在返回reference和object作出一个选择，程序员的工作就是选出正确的那个</p>
<h2 id="条款22，将变量声明为private">条款22，将变量声明为private</h2><ul>
<li>public接口内全部都是函数，可以产生用户使用这个类时，良好的一致性</li>
<li>private parameter可以产生封装的效果，封装使得变更更加容易</li>
<li>假如有一个public变量，如果取消它，所有使用它的客户代码都会被破坏<br>假如有一个protect变量，如果取笑它，所有使用它的derived class都会被破坏<br>所以protect并不比public更具有封装性</li>
</ul>
<h2 id="条款23，宁以non-member、non-friend替换member函数">条款23，宁以non-member、non-friend替换member函数</h2><ul>
<li>多个操作具有先后顺序，应该把他们绑定到一起</li>
<li>封装-&gt;客户端难修改-&gt;更多弹性去改变</li>
<li>non-member（non-friend）函数VSmember函数</li>
</ul>
<p>non-member函数不能访问private成分，提供更大的封装性</p>
<h2 id="条款24，若所有参数皆需类型转换，请为此采用non-member函数">条款24，若所有参数皆需类型转换，请为此采用non-member函数</h2><p>实现有理数类Rational，乘法的操作符重载<br>开始可能会向使用成员函数的写法 </p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp; rhs) <span class="keyword">const</span>
</code></pre><p>但是希望完成乘法交换律</p>
<pre><code><span class="type">Rational</span> r
<span class="type">Rational</span> <span class="literal">result</span> = <span class="number">2</span> * r
</code></pre><p>需要对2进行隐式类型转换，方法</p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs) 
</code></pre><p>使用non-member函数。</p>
<p>不是很明白</p>
<h2 id="条款25，考虑写出一个不抛出异常的swap函数">条款25，考虑写出一个不抛出异常的swap函数</h2><p>std::swap(T&amp; a, T&amp; b)可以对两个对象进行交换</p>
<p>如果这样做的效率不高，可以考虑自己写一个不会抛出异常的swap成员函数</p>
<p>例如：stl 容器中就有很多swap函数，只交换指针，而不会复制对象。</p>
<ol>
<li>自行实现这样一个swap成员函数(可以使用std::swap调换指针)</li>
<li>在命名空间内提供一个swap<widget>(Widget &amp;a,Widget &amp;b)去实现一个非成员函数来调用前者。</widget></li>
</ol>
<h2 id="条款26，尽可能延后变量定义式的出现时间">条款26，尽可能延后变量定义式的出现时间</h2><p>对变量进行定义，意味着承受构造的成本。</p>
<p>原则：应该延后变量定义到使用前的一刻为止。</p>
<h2 id="条款27，尽量少做转型动作">条款27，尽量少做转型动作</h2><p>C风格的转型</p>
<pre><code><span class="list">(<span class="keyword">int</span>)</span><span class="number">2.1</span>
int<span class="list">(<span class="number">2.1</span>)</span>
</code></pre><p>C++的新式转型：</p>
<ul>
<li><code>const_cast&lt;T&gt;(expression)</code> 将对象的常量性移除</li>
<li><code>dynamic_cast&lt;T&gt;(expression)</code> 主要用来进行安全向下转型<br>例如：只有基类可以使用，但是想调用子类的函数。尝试使用多态来代替。</li>
<li><code>static_cast&lt;T&gt;(expression)</code> 主要用来强制类型转换<br>例如：<code>static_cast&lt;int&gt;(2.1)</code><br>尽量使用C++风格的转型</li>
</ul>
<h2 id="条款28，避免返回handles指向对象内部成分">条款28，避免返回handles指向对象内部成分</h2><pre><code><span class="keyword">class</span> <span class="title">A</span>{
<span class="keyword">public</span>：
     <span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span>;
}
<span class="keyword">class</span> <span class="title">B</span>{
<span class="keyword">private</span>:
     A *a
}
</code></pre><p>如果在B类中提供<code>A&amp;</code>的返回（假设为rt），那么用户可以调用<code>rt.func()</code>修改B中的private成员了。<br>这是一种放松封装的行为。</p>
<h2 id="条款29，为“异常安全”而努力是值得的">条款29，为“异常安全”而努力是值得的</h2><p>异常安全的函数提供以下三个保证之一（从弱到强）：</p>
<ul>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下</li>
<li>强烈保证：函数调用成功，则完全成功。函数调用失败，则程序回复到调用之前的状态</li>
<li>nothrow：保证绝对不抛出异常。（通常完全使用内置类型的操作，提供不抛出异常的保证）<br>一个软件系统，要么具备异常安全性，要么不具备。只提供部分异常安全性函数，不能叫做具备异常安全性的系统。<br>以对象管理资源，是一种很好的防止内存泄露，保证异常安全性的方法。</li>
</ul>
<h2 id="条款30，透彻了解inlining的里里外外">条款30，透彻了解inlining的里里外外</h2><ul>
<li>inline函数意味着对这个函数的每一次调用，使用函数本体替换</li>
</ul>
<p>好处：减少调用成本</p>
<p>坏处：增加代码体积</p>
<ul>
<li>inline函数适合小型被频繁调用的函数</li>
</ul>
<p>函数内部有for循环不适合inline，因为本身的开销已经够大，减少调用的开销意义不大。</p>
<ul>
<li>inline只是一个向编译器发出的申请，编译器可以忽略它。</li>
</ul>
<p>如编译器拒绝复杂函数inline(带有递归，循环),virtual函数也会使inline落空。</p>
<h2 id="条款31，将文件间的编译依存关系降到最低">条款31，将文件间的编译依存关系降到最低</h2><p>方法1，使用Handle class</p>
<p>增加一个实现类去真正实现类的功能，原来的类只维护一个指向实现类的指针</p>
<p>方法2，使用Interface class</p>
<p>基类是虚基类，不包括任何成员变量。</p>
<h2 id="条款32，确定你的public继承是is-a的关系">条款32，确定你的public继承是is-a的关系</h2><p>如题</p>
<h2 id="条款33，避免遮掩继承而来的名称">条款33，避免遮掩继承而来的名称</h2><p>假如：Derived:Base</p>
<p>当编译器通过函数名称去找相应函数，会先从Derived类作用域找，然后再从Base类的作用域找<br>当使用函数重载的时候就可能出现问题。</p>
<p>使用using Base::func可以避免这种情况。 </p>
<h2 id="条款34，区分接口继承和实现继承">条款34，区分接口继承和实现继承</h2><ul>
<li>对于non-virtual函数的继承</li>
</ul>
<p>意味着，子类必须有和父类一样的实现</p>
<ul>
<li>对于virtual</li>
</ul>
<p>（1）pure-virtual, 只继承接口，意味着每个子类的行为都很有可能不一样</p>
<p>（2）imprure-virtual， 提供缺省的实现，意味着有一些子类的行为可能一样</p>
<p>可以使用pure-virtual+缺省行为分离(另外写一个函数)的方法，解决有可能子类在不知情的情况下继承了并不需要的缺省的实现。 </p>
<h2 id="条款35，考虑virtual函数以外的其他选择">条款35，考虑virtual函数以外的其他选择</h2><ul>
<li><p>NVI Non-virtual Interface<br>使用public non-virtual 函数调用private virtual函数(做一下修饰而已)</p>
</li>
<li><p>使用函数指针</p>
</li>
<li><p>使用tr1::function封装函数指针，代替函数指针的行为</p>
</li>
<li><p>使用strategy设计模式</p>
</li>
</ul>
<p>将想要virtual的行为封装成一个类(Calculator)，在类内部进行多态计算，通过传入的对象指针来判断。</p>
<h2 id="条款36，绝不重新定义继承而来的non-virtual函数">条款36，绝不重新定义继承而来的non-virtual函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{</span></span>
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
A *ptA=new B()
B *ptB=new B()
</code></pre><p>ptA-&gt;fun()调用A中的fun<br>ptB-&gt;fun()调用B中的fun<br>因为non-virtual函数不能进行动态绑定，调用函数只跟指针类型有关，所以</p>
<ol>
<li>不要重写父类的non-virtual函数</li>
<li>父类的non-virtual函数意味着，所有子类的实现都是这样</li>
</ol>
<h2 id="条款37，绝不重新定义进程而来的缺省参数值">条款37，绝不重新定义进程而来的缺省参数值</h2><p>缺省参数都是静态绑定的，即使是在virtual的函数中</p>
<h2 id="条款38，复合（组合）是has-a的关系">条款38，复合（组合）是has-a的关系</h2><h2 id="条款39，明智而审慎地使用private继承">条款39，明智而审慎地使用private继承</h2><p>private继承意味着所有父类的成员在子类中都变为private，</p>
<p>好处：可以让基类部分最优化，减少尺寸。</p>
<h2 id="条款40，明智而审慎地使用多重继承">条款40，明智而审慎地使用多重继承</h2><ul>
<li>一个class继承自多个base class，那么父类成分有相同函数，就需要显示指定。</li>
<li>对于钻石型继承，B:A,C:A,D:B,D:C，需要指定虚继承，来避免重复继承A中的成分</li>
<li>虚继承需要编译器做很多工作，要付出一定成本，一般不用。</li>
<li>如果有单一继承可以满足需求，一般这个方案一定比多重继承要好。</li>
</ul>
<h2 id="条款41，了解隐式接口和编译器多态">条款41，了解隐式接口和编译器多态</h2><ul>
<li><p>运行时多态，通过虚指针和虚函数实现</p>
</li>
<li><p>编译时多态</p>
</li>
</ul>
<p>(1) 函数重载，相同函数名不同参数列表</p>
<p>(2) 在模板特化的时候，根据类型生成具体的函数</p>
<h2 id="条款42，了解typename的双重意义">条款42，了解typename的双重意义</h2><pre><code><span class="keyword">template</span>&lt; class T&gt; class <span class="type">Widget</span>;
<span class="keyword">template</span>&lt;typename T&gt;class <span class="type">Widget</span>;
</code></pre><p>并没有什么不同</p>
<p>当使用嵌套从属名称，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename C&gt;
typename C::const_iterator iter(container.begin())
</code></pre><p>const_iterator是依赖于C的名称，这时候必须用typename</p>
<h2 id="条款43，学习处理模板化基类内的名称">条款43，学习处理模板化基类内的名称</h2><p>对于模板C++的继承，由于基类模板可能被特化，特化使得基类内的成员不确定，C++会拒绝从模板化基类中寻找继承而来的名称</p>
<p>解决办法：</p>
<ol>
<li>在使用base class之前使用this-&gt;</li>
<li>使用using</li>
</ol>
<h2 id="条款44，将与参数无关的代码抽离templates">条款44，将与参数无关的代码抽离templates</h2><p>使用带参template可能会引起代码膨胀，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename T,std:size_t n&gt;
</code></pre><p>解决办法：<br>使用模板父类去处理由于size_t而造成的代码膨胀的问题</p>
<h2 id="条款45，运用成员函数模板接受所有兼容类型的参数">条款45，运用成员函数模板接受所有兼容类型的参数</h2><ul>
<li>智能指针是使用模板实现的，那如果我们要智能指针之间（具有继承关系的）能够相互转化，赋值，解决办法：</li>
<li>使用成员函数模板，对兼容的类型进行构造和赋值</li>
</ul>
<h2 id="条款46，需要类型转换时请为模版定义非成员函数">条款46，需要类型转换时请为模版定义非成员函数</h2><pre><code><span class="type">Rational</span>&lt;<span class="type">int</span>&gt; a(<span class="number">1</span>,<span class="number">2</span>);
<span class="type">Rational</span>&lt;<span class="type">int</span>&gt; <span class="literal">result</span> = a*<span class="number">2</span>; // <span class="type">Error</span>
</code></pre><p>模板化实例，不进行隐式类型转换，使用friend方法。</p>
<h2 id="条款47，请使用traits_classes表现类型信息">条款47，请使用traits classes表现类型信息</h2><p>引用：</p>
<blockquote>
<p>traits class是个类模板，在不修改一个实体（通常是数据类型或常量）的前提下，把属性和方法关联到一个编译时的实体。在c++中的具体实现方式是：首先定义一个类模板，然后进行显式特化或进行相关类型的部分特化。<br>我的理解是：traits是服务于泛型编程的，其目的是让模板更加通用，同时把一些细节向普通的模板用户隐藏起来。当用不同的类型去实例化一个模板时，不可避免有些类型会存在一些与众不同的属性，若考虑这些特性的话，可能会导致形成的模板不够“泛型”或是过于繁琐，而traits的作用是把这些特殊属性隐藏起来，从而实现让模板更加通用。</p>
</blockquote>
<h2 id="条款48，认识template元编程">条款48，认识template元编程</h2><ul>
<li>模版元编程有两个效力：第一，它让某些事情更容易；第二，可将工作从运行期转移到编译期。</li>
<li>引用：<blockquote>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。</p>
</blockquote>
</li>
</ul>
<h2 id="条款49，了解new_handler的行为">条款49，了解new_handler的行为</h2><p>new_handler 的意思就是说，当使用operator new 无法分配内存时，转交给用户，用户来做一些事情。</p>
<h2 id="条款50，了解new和delete的合理替换时机">条款50，了解new和delete的合理替换时机</h2><p>有时候，我们替换掉编译器提供的new或者delete。重写operator new。三个常见理由：</p>
<ol>
<li>用来检测运用上的错误，超额分配一些内存，再额外的空间放置一些内存；</li>
<li>为了强化效能，编译器提供的new/delete是通用的，通用就意味着冗余和效率低下，为什么？这个很好理解，因为他要支持很多情况下，也必须考虑很多情况。我们重写new/delete，也就是说，对于特定情况，给出特定的实现。</li>
<li>为了收集使用上的统计数据。</li>
</ol>
<h2 id="条款51，编写new和delete时需固守常规">条款51，编写new和delete时需固守常规</h2><p>自定义new/delete的时候，需要遵守一些规则。</p>
<ol>
<li>循环申请，直到成功或者抛出异常</li>
<li>class专属版本处理，分配大小与class大小不一致的错误。</li>
<li>delete的时候，判断是否为null。</li>
</ol>
<h2 id="条款52，写了placement_new也要写placement_delete">条款52，写了placement new也要写placement delete</h2><h2 id="条款53，不要轻忽编译器的警告">条款53，不要轻忽编译器的警告</h2><h2 id="条款54，让自己熟悉包括TR1在内的标准程序库">条款54，让自己熟悉包括TR1在内的标准程序库</h2><p>C++11（原名C++0x）于2011年8月12日公布。<br>TR1是一份文档，由编译器实现，在std::tr1命名空间下<br>C++11纳入了大部分TR1的内容</p>
<h2 id="条款55，让自己熟悉Boost">条款55，让自己熟悉Boost</h2><p>Boost是一个社区，提供很多程序库，作为新的C++标准的试验场。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/"> #C++ </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/31/从图灵测试到图灵停机/">
                从图灵到图灵测试再到图灵停机
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-31
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/杂七杂八/">杂七杂八</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/31/从图灵测试到图灵停机/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/31/从图灵测试到图灵停机/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮助盟军破解德军密码系统Enigma的故事。图灵，这个计算机之父，影响着计算机技术发展的方方面面，计算机的最高奖图灵奖也是以他的名字命名的，没办法人家是祖师爷呀。</p>
<h2 id="图灵生平">图灵生平</h2><blockquote>
<p>阿兰·麦席森·图灵（Alan Mathison Turing），生于1912年6月23日，逝于1954年6月7日 ，被誉为“<strong>计算机科学之父</strong>”和“人工智能之父”。图灵和同事破译的情报，在盟军诺曼底登陆等重大军事行动中发挥了重要作用，图灵因此在1946年获得“不列颠帝国勋章”。历史学家认为，他让二战提早了2年结束，至少拯救了2000万人的生命 。<br>计算机逻辑的奠基者，提出了“图灵机”和“图灵测试”等重要概念。美国计算机协会（ACM）1966年设立的以其名命名的“<strong>图灵奖</strong>”是计算机界最负盛名和最崇高的一个奖项，有“计算机界的诺贝尔奖”之称。</p>
<p>1912年6月23日出生于英国帕丁顿，1931年进入剑桥大学国王学院，师从著名数学家哈代，1938年在美国普林斯顿大学取得博士学位，二战爆发后返回剑桥，曾经协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。</p>
<p>因图灵的同性恋倾向，他于1952年被起诉（这种行为在当时的英国仍属刑事犯罪）。 为了继续科研工作，他接受了治疗雌激素注射（ 化学阉割 ）代替牢狱之刑。 图灵于1954年6月7日去世（食用氰化物泡过的苹果中毒）， 勘验确定他的死亡是自杀。 英国女王伊丽莎白二世在2013年追授特赦。</p>
<p>阿兰·麦席森·图灵是一名世界级的长跑运动员。他的马拉松最好成绩是2小时46分3秒，比1948年奥林匹克运动会金牌成绩慢11分钟。1948年的一次跨国赛跑比赛中，他跑赢了同年奥运会银牌得主汤姆·理查兹（Tom Richards）。</p>
</blockquote>
<h2 id="图灵测试">图灵测试</h2><blockquote>
<p>如果一台机器能够与人类展开对话（通过电传设备）而不能被辨别出其机器身份，那么称这台机器具有智能。</p>
</blockquote>
<p>这也是《机械姬》这部电影讨论的核心所在。善良单纯的天才程序员被大Boss天才坑蒙拐骗参加设计的图灵测试，机器人ava通过利用程序员的同情心（程序员多么可怜），诱骗他完成了逃离实验基地的任务。最终是否通过测试不是由程序员判断的，而是由机器人能否骗到程序员决定的。多么精巧的设计！一个高智商的程序员，明知道很有可能被骗，但还是被骗了，这无疑是真正的人工智能。</p>
<p>最后实验失控，大Boss被AI杀死（预示着人类要灭亡么？），AI进入到人群之中。</p>
<p>这是一部好电影，但这篇文章不是一篇影评，就不赘述电影的细节了。</p>
<h2 id="图灵停机问题">图灵停机问题</h2><p>突然想起来本科离散数学提到的一个很有意思的问题，图灵停机问题（The Halting Problem））。描述如下：</p>
<blockquote>
<p>不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。</p>
</blockquote>
<p>精妙的是这个问题的证明过程。通过反证法可以证明这个命题。</p>
<p>假设我们某一天真做出了这么一个极度聪明的万能算法（就叫God_algo吧），你只要给它一段程序（二进制描述），再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束（停机），我们来编写一下我们的这个算法吧：</p>
<pre><code>bool God_algo(<span class="keyword">char</span>* <span class="keyword">program</span>, <span class="keyword">char</span>* <span class="keyword">input</span>)
{
    <span class="keyword">if</span>(&lt;<span class="keyword">program</span>&gt; halts <span class="keyword">on</span> &lt;<span class="keyword">input</span>&gt;)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> false;
}
</code></pre><p>这里我们假设if的判断语句里面是你天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在，我们从这个God_algo出发导出一个新的算法：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span><span class="params">(<span class="keyword">char</span>* program)</span>
</span>{
    <span class="keyword">if</span>( God_algo(program, program) )
    {
           <span class="keyword">while</span>(<span class="number">1</span>);        <span class="comment">// loop forever!</span>
           <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// can never get here!</span>
    }
    <span class="keyword">else</span>
       <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<pre><code>Satan_algo<span class="list">(<span class="keyword">Satan_algo</span>)</span><span class="comment">;</span>
</code></pre><p>我们来分析一下这行简单的调用：</p>
<ol>
<li><p>Satan_algo(Satan_algo)这个调用要么能够运行结束返回（停机），要么不能返回（loop forever）。</p>
</li>
<li><p>如果它能够结束，那么Santa_algo算法里面的那个if判断就会成立（因为God_algo(Santa_algo,Santa_algo)将会返回true），从而程序便进入那个包含一个无穷循环while(1);的if分支，于是这个Satan_algo(Satan_algo)调用便永远不会返回（结束）了。</p>
</li>
<li><p>如果不能结束（停机），则if判断就会失败，从而选择另一个if分支并返回true，即Satan_algo(Satan_algo)又能够返回（停机）。</p>
</li>
</ol>
<p>总之，我们有：</p>
<p>Satan_algo(Satan_algo)能够停机=&gt; 它不能停机</p>
<p>Satan_algo(Satan_algo)不能停机=&gt; 它能够停机</p>
<p>所以它停也不是，不停也不是，左右矛盾。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/26/linux命令sed和awk/">
                linux命令sed和awk
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/linux/">linux</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/26/linux命令sed和awk/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/linux命令sed和awk/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p>
<h3 id="常见应用">常见应用</h3><ol>
<li>抽区域</li>
<li>匹配正则表达式</li>
<li>比较域</li>
<li>增加，附加，替换</li>
</ol>
<h3 id="执行过程">执行过程</h3><p>sed一次处理一行或多行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行或多行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向或写入命令存储输出。</p>
<h3 id="调用方式">调用方式</h3><ul>
<li>命令行输入</li>
</ul>
<p>sed [选项] ‘sed命令’ 输入文件</p>
<ul>
<li>使用sed脚本<br>sed [选项] –f sed脚本文件 输入文件</li>
</ul>
<h3 id="常用选项">常用选项</h3><p>-n：不打印，不写编辑行到标准输出，缺省情况下打印所有行[编辑/未编辑]p命令可以打印编辑行</p>
<p>-c：下一命令是编辑命令，使用多项编辑时加入此选项</p>
<p>-f： 调用sed脚本 sed –f sedScriptFile targetFile</p>
<p>-i：将修改附加到源文件上</p>
<h3 id="使用技巧">使用技巧</h3><p>重定向sed结果输出<br>$sed ‘sed-command’ inputfile &gt; outputfile</p>
<p>定位内容的方式</p>
<p><code>x</code> 行x</p>
<p><code>x,y</code> 行x到行y</p>
<p><code>/pattern/</code> 模式</p>
<p><code>/pattern/pattern/</code> 两个模式</p>
<p><code>/pattern/,x</code>     模式+行【在给定行号上查询模式】</p>
<p><code>X,y</code> /pattern/ 通过行号和模式查询匹配行</p>
<p><code>X,y!</code> 不包含指定行号</p>
<h3 id="基本的sed命令">基本的sed命令</h3><p>P 打印匹配行 print</p>
<p>= 打印匹配行行号</p>
<p>a\ 定位行号后附加新文本信息 append</p>
<p>i\ 定位行号后插入   insert</p>
<p>d 删除定位行   delete</p>
<p>c\ 用新文本替换定位文本   change</p>
<p>s 使用替换模式替换相应模式 </p>
<p>r 从另一个文件中读文本  read</p>
<p>w 写文本到一个文件   write</p>
<p>q 第一个模式匹配完成后退出或立即退出</p>
<p>{} 定位执行命令组</p>
<p>n 从另一个文件中读文本下一行，并附加在下一行</p>
<p>g 将模式2黏贴到/pattern n/</p>
<p>y 传送字符</p>
<h3 id="实例：">实例：</h3><ul>
<li>显示文本</li>
</ul>
<p><code>$sed -n &#39;1,4p&#39; file</code></p>
<p>显示1-4行</p>
<p><code>$sed -n &#39;4,/Str/p&#39;</code></p>
<p>显示第4行到匹配到Str的一行，/str/代表匹配到的一行</p>
<ul>
<li>插入修改文本</li>
</ul>
<p><code>$sed &#39;/str/a\ &quot;inserted line&quot;&#39; file</code></p>
<p>在满足条件的行后，插入内容</p>
<p><code>sed &#39;/str/i\ &quot;appended line&quot;&#39; file</code></p>
<p>在满足条件的行前插入内容</p>
<p><code>$sed &#39;3 c\ &quot;changed line&quot;&#39; file</code></p>
<p>满足条件的行，整行替换掉</p>
<ul>
<li>删除文本</li>
</ul>
<p><code>$sed &#39;1,3d&#39; file</code></p>
<p>删除1-3行</p>
<p><code>$sed &#39;/str/d&#39; file</code></p>
<p>删除匹配行</p>
<p><code>$sed -n &#39;/Begin/,/End/p&#39; file | more</code></p>
<p>删除两个匹配行之间的数据</p>
<ul>
<li>替换文本</li>
</ul>
<p>格式：<code>[address[,address]] s/pattern-find/replacement-pattern/[g,p,w,n]</code></p>
<p>n    1到512之间的一个数字，表示对本模式中指定模式第n次出现的情况进行替换。</p>
<p>g    对模式空间所有出现的情况进行全局更改【缺省只替换首次出现的模式 】</p>
<p>p    打印模式空间的内容</p>
<p>w    file</p>
<p><code>$sed &#39;s/str/tostr/&#39; file</code> </p>
<p>替换每一行首次出现的str为tostr</p>
<p><code>$sed &#39;s/str/tostr/g&#39; file</code></p>
<p>替换所有的行内，出现的所有str为tostr</p>
<p><code>$sed &#39;s/str/tostr/w output&#39; file</code></p>
<p>替换后重定向到output</p>
<p>转换字符</p>
<p><code>sed &#39;y/cp/wd/&#39; test.txt</code></p>
<p>c转换成w，p转换成d</p>
<ul>
<li>Shell向sed传值</li>
</ul>
<p><code>echo $input | sed &#39;s/bb/&#39;$str&#39;/&#39;</code></p>
<p><code>echo $input | sed &quot;s/bb/$str/&quot;</code></p>
<h2 id="awk">awk</h2><h3 id="主要功能-1">主要功能</h3><p>awk是一种用于处理文本的工具，主要用于格式化报文，或从一个大文本中抽取数据。</p>
<h3 id="执行过程-1">执行过程</h3><p>awk每次读入一行，执行’ ‘中的内容，按模式匹配来采取动作</p>
<h3 id="格式">格式</h3><p><code>awk &#39;pattern+{action}&#39; file</code></p>
<p>pattern用于筛选查询匹配行，决定了动作何时触发，可以使用条件语句，正则表达式</p>
<p>action用于对筛选后的内容进行处理</p>
<p>BEGIN可以设置计数和打印头（可选）</p>
<p>END打印输出文本总数和结尾状态标识(可选)</p>
<h3 id="常用参数">常用参数</h3><p>-F 指定读取一行数据的分隔符，默认为空格<br>-f 指定处理程序的脚本文件，这个文件必须符合awk语法</p>
<h3 id="调用方式：">调用方式：</h3><p><code>awk –f awk-script-file input-files</code></p>
<h3 id="常用内置参数">常用内置参数</h3><p><code>$0,$1,....$n</code>   <code>$0</code>代表当前行的内容，<code>$i</code>代表当前行被分割后的第i个字段的内容</p>
<p>ARGC 命令行参数个数</p>
<p>ARGV 命令行参数排列</p>
<p>ENVIRON 支持队列中系统环境变量的使用</p>
<p>FILENAME 实际操作的文件名</p>
<p>FNR 浏览文件记录数，&lt;=NR</p>
<p>FS <strong>设置输入域分隔符，等价于命令行-F选项</strong> ，可在BEGIN中进行设置,然后执行的时候均以设置的符号为分隔符</p>
<p>NF <strong>浏览记录 域的个数</strong>，在记录被读取时设置【number of fields】一共有多少个域</p>
<p>NR <strong>已读取记录数</strong>【number of rows】</p>
<p>RS 控制记录分隔符，缺省：新行\n，Row Separator记录分隔符，可以根据具体数据需求，设置读取一条记录的区间</p>
<p>OFS <strong>输出域的分隔符</strong>，缺省空格，输出结果 print $1,$2默认加的是空格，可以在BEGIN中设置，改为其他分隔符</p>
<p>ORS 输出记录的分隔符，缺省：新行\n，整体记录的</p>
<h3 id="实例">实例</h3><ul>
<li>打印</li>
</ul>
<p>打印所有行</p>
<p><code>awk &#39;{print $0}&#39; file</code></p>
<p>打印包含头尾</p>
<p><code>awk &#39;BEGIN{print &quot;Name Age&quot;}{print $1,$2}END{print &quot;END_OF_REPORT&quot;}&#39;</code></p>
<ul>
<li>使用判断语句</li>
</ul>
<p><code>&lt;  &lt;=  &gt;  &gt;=  ==  !=</code>  </p>
<p>~匹配正则   !~不匹配正则</p>
<p><code>|| &amp;&amp; !</code> 或且非</p>
<p><code>awk &#39;{if($2!~/Rudy/) print $0}&#39; content</code></p>
<p><code>awk &#39;{if($1==&quot;001&quot; &amp;&amp; $2~/^Ru/) print $0}&#39; content</code></p>
<ul>
<li>使用内置的变量 </li>
</ul>
<p><code>awk &#39;BEGIN{OFS=&#39;\t&#39;}{print NF,NR,$0}END{print FILENAME}&#39; content &gt; output</code></p>
<p>设置输出的分隔符为’\t’，输出一些内置变量的信息</p>
<ul>
<li>AWK变量中的字符串和数字的转换</li>
</ul>
<p>字符串-&gt;整数</p>
<p><code>$ awk &#39;BEGIN{a=&quot;100&quot;;b=&quot;10test10&quot;;print (a+b+0);}&#39;</code></p>
<p><code>110</code></p>
<p>只需要将变量通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。</p>
<p>整数-&gt;字符串</p>
<p><code>awk &#39;BEGIN{a=100;b=100;c=(a&quot;&quot;b);print c}&#39;</code>      </p>
<p><code>100100</code></p>
<p>只需要将变量与””符号连接起来运算即可。</p>
<ul>
<li>使用内置的字符串函数</li>
</ul>
<p><code>gsub(r,s)</code> 在整个$0中<strong>用s代替r</strong></p>
<p><code>gsub(r,s,t)</code> 在整个t中用s替代r</p>
<p><code>index(s,t)</code> 返回s中字符串t的第一位置</p>
<p><code>length(s)</code> <strong>返回s长度</strong></p>
<p><code>match(s,r)</code> 测试s是否包含匹配r的字符串</p>
<p><code>split(s,a,fs)</code> 在fs上将s分成序列a.fs为分隔符</p>
<p><code>sprint(fmt,exp)</code> 返回经fmt格式化后的exp</p>
<p><code>sub(r,s)</code> 用$0中最左边最长的子串代替s</p>
<p><code>substr(s,p)</code> 返回字符串s中从p开始的后缀部分</p>
<p><code>substr(s,p,n)</code> 返回字符串s中从p开始长度为n的后缀部分</p>
<p>替换字符串</p>
<p><code>awk &#39;BEGIN{FS=&#39;\t&#39;}{gsub(/Rudy/,&quot;RUDY&quot;);{print $0}}&#39; content</code></p>
<ul>
<li>使用printf进行格式化输出</li>
</ul>
<p><code>%c</code> ASCII字符</p>
<p><code>%d</code> 整数</p>
<p><code>%e</code> 浮点数，可科学计数法</p>
<p><code>%f</code> 浮点数，小数形式</p>
<p><code>%g</code> 由awk决定使用哪种浮点数转换e或f</p>
<p><code>%o</code> 八进制</p>
<p><code>%s</code> 字符串</p>
<p><code>%x</code> 十六进制</p>
<p>格式化输出一个字符串</p>
<p><code>awk -F&#39;\t&#39; &#39;{printf(&quot;%s\t%s\n&quot;,$2,$1)}&#39; content</code></p>
<ul>
<li>向awk中传递参数</li>
</ul>
<p><code>awk &#39;{if($3&lt;=AGE){print $0}}&#39; AGE=20 content</code> </p>
<ul>
<li><p>写一个awk脚本</p>
<pre><code><span class="comment">#!bin/awk -f</span>
BEGIN{
        FS=<span class="string">"['\t']"</span>
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="string">"NUMBER"</span>,<span class="string">"NAME"</span>,<span class="string">"AGE"</span>)
}
{
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)
}
END{
        <span class="keyword">print</span> <span class="string">"END OF FILE"</span>
}
</code></pre></li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux命令/"> #linux命令 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/26/linux正则表达式和grep/">
                linux正则表达式和grep
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/linux/">linux</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/26/linux正则表达式和grep/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/linux正则表达式和grep/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk: 伪装成实用程序的强大编程语言，主要用于文本处理</li>
</ul>
<h3 id="常用符号">常用符号</h3><h4 id="基本元字符">基本元字符</h4><p><code>^</code> 行首定位符，表示以..开始</p>
<p><code>$</code> 行尾定位符，表示以..结束</p>
<p><code>.</code>  匹配单个字符</p>
<p><code>*</code> 匹配0个或任意多个字符</p>
<p><code>[]</code> 匹配[]中出现字符范围内的一个字符</p>
<p><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h4 id="扩展元字符">扩展元字符</h4><p><code>?</code> 匹配0个或者1个</p>
<p><code>+</code> 匹配1个或者多个</p>
<p><code>|</code> 或者</p>
<p><code>()</code>分组符号</p>
<h4 id="特殊匹配字符">特殊匹配字符</h4><p><code>[:alnum:]</code> 字母与数字字符</p>
<p><code>[:alpha:]</code> 字母</p>
<p><code>[:ascii:]</code> ASCII字符</p>
<p><code>[:blank:]</code> <strong>空格或制表符</strong></p>
<p><code>[:cntrl:]</code> ASCII控制字符</p>
<p><code>[:digit:]</code> 数字</p>
<p><code>[:graph:]</code> 非控制、空格字符</p>
<p><code>[:lower:]</code> 小写字母</p>
<p><code>[:print:]</code> 可打印字符</p>
<p><code>[:punct:]</code> 标点符号字符</p>
<p><code>[:space:]</code> <strong>空白字符，包括垂直制表符</strong></p>
<p><code>[:upper:]</code> 大写字母</p>
<p><code>[:xdigit:]</code> 十六进制数字</p>
<h3 id="实例">实例</h3><ul>
<li>^ $<br><code>ls -l | grep ^d</code></li>
</ul>
<p>匹配以d开头的所有内容</p>
<ul>
<li><code>ls -l | grep d$</code></li>
</ul>
<p>匹配以d结束的所有内容</p>
<ul>
<li><code>^$</code> </li>
</ul>
<p>匹配空行</p>
<ul>
<li><code>^.$</code></li>
</ul>
<p>只包含一个字符的</p>
<ul>
<li><code>* ？ +</code></li>
</ul>
<p><code>compu*ter</code> 匹配u，重复0次或多次</p>
<p><code>compu?ter</code> 匹配0个或者1个u</p>
<p><code>compu+ter</code> 匹配1个或多个u</p>
<p><strong>需要注意的是+和？是扩展字符，需要看具体使用正则表达式的环境<br>如果使用grep需要使用-E指定为扩展模式才能正常使用+和？</strong></p>
<ul>
<li><code>\</code>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
</ul>
<p><code>\.pass</code>  匹配<code>*.pass</code></p>
<ul>
<li><code>[]</code></li>
</ul>
<p><code>[1234]</code> 匹配1,2,3,4中的一个</p>
<p><code>[1-9]</code> 数字1-9中的一个</p>
<p><code>[A-Za-z]</code> 所有字母</p>
<p><code>[^0-9]</code> 一个非数字的字符</p>
<ul>
<li><code>\{\}</code></li>
</ul>
<p><code>A\{2\}B</code>   匹配AAB</p>
<p><code>A\{4,\}B</code>   匹配A出现至少4次B</p>
<p><code>A\{2,4\}B</code>  匹配A出现在2至4次之间</p>
<h2 id="grep">grep</h2><p>功能：grep是文本搜索工具，使用正则表达式搜索文本并打印匹配行</p>
<p>格式：<code>grep [options] PATTERN [Files]</code></p>
<p>注：</p>
<p>输入字符串<strong>作为参数，最好双引号括起</strong>  “mystr”</p>
<p>在<strong>调用变量时，也使用双引号括起</strong>  “$MYSTR”</p>
<p>使用<strong>正则[匹配模式]是，应使用单引号括起</strong>  ‘49[32]’</p>
<p>常用选项：</p>
<p><code>-c</code> 只输出匹配的行数,而不输出匹配的行</p>
<p><code>-i</code> 不区分大小写</p>
<p><code>-n</code> 显示匹配行及行号</p>
<p><code>-q</code>  安静模式，不输出任何东西，如果找到了返回0</p>
<p><code>-E</code> 启用扩展表达式，可使用扩展字符，如：+ ? | () {} , 或者直接使用egrep</p>
<p><code>-v</code> 显示不包含匹配文本的所有行</p>
<p>实例：</p>
<ol>
<li><p>在多个文件中查找<br><code>grep “sort” filea fileb</code>  在filea,fileb中查找</p>
</li>
<li><p>计算匹配行数<br><code>grep -c &quot;sort&quot; file</code></p>
</li>
<li><p>使用正则表达式查找<br><code>grep &#39;48[34]&#39; file</code></p>
</li>
<li><p>使用扩展元字符<br><code>grep -E &#39;aaa|bbb&#39; file</code></p>
</li>
<li><p>匹配空行<br><code>grep &#39;^$&#39; file</code></p>
</li>
<li><p>特殊匹配字符，grep 允许使用国际字符串模式匹配或匹配模式的类名<br><code>grep ‘5[[:upper:]] [[:upper:]]’</code> data  5开头，两个大写</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux命令/"> #linux命令 </a>
          
            <a href="/tags/正则表达式/"> #正则表达式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/24/HadoopStreaming/">
                Hadoop Streaming学习文档
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/Hadoop/">Hadoop</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/24/HadoopStreaming/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/24/HadoopStreaming/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架允许任何程序语言实现的程序（只要该程序支持标准输入输出即可），在Hadoop MapReduce中使用，方便已有程序向Hadoop平台移植。</p>
<h2 id="Streaming原理">Streaming原理</h2><p>使用Java实现了一个包装<strong>用户程序</strong>（mapper，reducer方法）的MapReduce程序，该程序调用MapReduce的Java接口，创建一个<strong>新的进程</strong>包装用户程序，将数据通过<strong>管道</strong>传递给包装的用户程序。</p>
<p><img src="http://i.imgur.com/dlebclb.jpg" alt=""></p>
<h2 id="考虑的问题">考虑的问题</h2><p>在实际的开发过程中，开发人员需要考虑下面几个方面的问题，其中1,2是必须实现的：</p>
<ol>
<li>Mapper程序：对输入key/value数据进行处理；</li>
<li>Reducer程序：对mapper的输出进行归并处理；</li>
<li>Combiner：在本地对一个计算节点上的mapper输出进行归并；</li>
<li>Partitioner：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li>InputFormat/OutputFormat：对输入数据进行切分，保存输出数据。</li>
</ol>
<h2 id="执行">执行</h2><pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “cat” \
    -reducer “cat” \
    -jobconf mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">1</span>\
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”dist-sort”
</code></pre><p>这是一个实现了分布式排序的程序。可以通过shell脚本，shell命令，或者其它语言的<strong>可执行程序</strong>来进行mapper和reducer程序的运行</p>
<h2 id="常用参数的使用">常用参数的使用</h2><p>例1：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">2</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"Python/bin/python $app/mapper.py"</span> \
    -reducer <span class="string">"Python/bin/python $app/reducer.py"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archive</span>
</code></pre><p>-D表示配置参数，剩余项是和输入输出相关的文件和可执行程序</p>
<p><code>-D mapred.job.name=&quot;jobname&quot; \</code>,作业名</p>
<p><code>-D mapred.job.priority=VERY_HIGH \</code> 作业优先级</p>
<p><code>-D mapred.job.map.capacity=500 \</code>,最多同时运行map任务数</p>
<p><code>-D mapred.job.reduce.capacity=300 \</code>最多同时运行reduce任务数</p>
<p><code>-D mapred.map.tasks=500 \</code>,map任务个数</p>
<p><code>-D mapred.reduce.tasks=300 \</code>,reduce任务个数</p>
<p>capacity是同时运行任务的个数，tasks是运行任务的总的个数，一般task更大，capacity是同时运行任务的上限</p>
<p><code>-D stream.num.map.output.key.fields=2 \</code>,表示在第2个分隔符（默认为\t）之前作为key，之后作为value，也可以使用参数<code>-D stream.map.output.field.separator=. \</code>指定分隔符为’.’或者其它字符。</p>
<p><code>-mapper &quot;Python/bin/python $app/mapper.py&quot; \</code>指定map任务，需要可执行，读入标准输入流，输出标准输出流</p>
<p><code>-reducer &quot;Python/bin/python $app/reducer.py&quot; \</code>指定reducer任务</p>
<p><code>-input $input \</code>指定输入文件</p>
<p><code>-output $output \</code>指定输出文件</p>
<p><code>-cacheArchive $archive</code>分发压缩包。<code>$archive</code>格式为<code>hdfs://host:port/path/to/archivefile#linkname</code>，表示hdfs上这个压缩包的路径为<code>hdfs://host:port/path/to/archivefile</code>,可以使用<code>linkname/children/path</code>访问这个压缩包的内容</p>
<p>例2：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">3</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.partitioner</span><span class="class">.options</span>=<span class="string">"-k1,1"</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.comparator</span><span class="class">.options</span>=<span class="string">"-k1,1 -k3,3nr"</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"cat"</span> \
    -reducer <span class="string">"cat"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archives</span>
</code></pre><p><code>-D mapred.text.key.partitioner.options=&quot;-k1,1&quot; \</code>表示对key进行分割，分割符默认为\t，取分割后的1,1部分作为主key，剩下的作为辅key</p>
<p><code>-D mapred.text.key.comparator.options=&quot;-k1,1 -k3,3nr&quot; \</code>指定排序依据，主key按第一部分排字母序，辅key按第三部分数字序倒序排</p>
<p>例3：</p>
<pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -D stream<span class="class">.map</span><span class="class">.output</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">4</span> \
    -D map<span class="class">.output</span><span class="class">.key</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D num<span class="class">.key</span><span class="class">.fields</span><span class="class">.for</span><span class="class">.partition</span>=<span class="number">2</span> \ 
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “mymapper.sh” -reducer “ myreducer.sh” \
    -partitioner org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.lib</span><span class="class">.KeyFieldBasedPartitioner</span> \
    -file /home/work/mymapper<span class="class">.sh</span> \
    -file /home/work/myreducer<span class="class">.sh</span> \
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”jobname”
</code></pre><p><code>-D stream.map.output.field.separator=. \</code><br><code>-D stream.num.map.output.key.fields=4 \</code><br>表示输出分隔符为’.’，并且第4个.之后为value，之前为key</p>
<p><code>-D map.output.key.field.separator=. \</code><br><code>-D num.key.fields.for.partition=2 \</code><br>表示key内的分隔符为’.’，第2个’.’之前作为主key，之后作为辅key</p>
<p><code>-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner \</code>指定要使用KeyFieldBasedPartitioner，也就是key域内的partioner。这样的话会把主key的内容作为partition的依据，相同的主key分配到同一个reducer中。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hadoop/"> #Hadoop </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/23/Hadoop基本原理/">
                Hadoop基本原理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-23
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/Hadoop/">Hadoop</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/23/Hadoop基本原理/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/23/Hadoop基本原理/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据处理速度快（Velocity） 数据真实性高（Veracity） 合起来被称为4V。</p>
<p>处理大数据是为了挖掘数据中的隐含价值</p>
<h4 id="如何处理大数据？">如何处理大数据？</h4><p>集中式计算VS分布式计算</p>
<p>集中式计算：通过不断增加处理器的个数来增强耽搁计算机的计算能力，从而提高处理的速度。需要的内存很大，计算的速度很快。</p>
<p>分布式计算：一组通过网络连接的计算机，形成一个分散的系统。将需要处理的大量数据分散成多个部分，交由系统中的耽搁计算机分别处理，最后将这些计算结果合并得到最终结果。（MapReduce的核心思想）</p>
<h3 id="Hadoop是怎么产生的">Hadoop是怎么产生的</h3><h4 id="技术基础">技术基础</h4><p>google三驾马车：GFS、MapReduce和BigTable。Hadoop是在google三驾马车基础上的开源实现。</p>
<ol>
<li>GFS（Google File System）分布式文件系统，对应Hadoop当中的HDFS。</li>
<li>MapReduce分布式计算框架，也是Hadoop处理大数据的核心思想。</li>
<li>BigTable是基于GFS的数据存储系统，对应Hadoop的HBase。</li>
</ol>
<h4 id="三大分布式计算系统">三大分布式计算系统</h4><p>Hadoop，Spark，Storm是主流的三大分布式计算系统</p>
<p>Spark VS Hadoop</p>
<p>Hadoop使用硬盘来存储数据，而Spark是将数据存在内存中的，因此Spark何以提供超过Hadoop 100倍的计算速度。内存断电后会丢失，所以Spark不<br>适用于需要长期保存的数据。</p>
<p>Storm VS Hadoop</p>
<p>Storm在Hadoop基础上提供了实时运算的特性，可以实时处理大数据流。不同于Hadoop和Spark，Storm不尽兴数据的手机和存储工作，直接通过网络接受并实时处理数据，然后直接通过网络实时传回结果。</p>
<p>所以三者适用于的应用场景分别为：</p>
<ol>
<li>Hadoop常用于离线的复杂的大数据处理</li>
<li>Spark常用于离线的快速的大数据处理</li>
<li>Storm常用于在线实时的大数据处理</li>
</ol>
<h3 id="Hadoop定义">Hadoop定义</h3><h4 id="Hadoop是什么">Hadoop是什么</h4><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架</p>
<h4 id="Hadoop特点">Hadoop特点</h4><ol>
<li>可靠。Hadoop假设计算元素和存储会失败，所以会维护多个工作数据的副本，对失败的节点会重新处理</li>
<li>高效。通过并行方式工作，加快处理速度。</li>
<li>可伸缩。可以处理PB级的数据。</li>
<li>高扩展。可以方便地扩展到数以千计的节点。</li>
<li>低成本。Hadoop是开源的，Hadoop节点可以是很便宜的机器。</li>
</ol>
<h4 id="应用场景">应用场景</h4><p>Hadoop适用于：海量数据，离线数据，复杂数据</p>
<p>场景1：数据分析，如海量日志分析，商品推荐，用户行为分析</p>
<p>场景2：离线计算，（异构计算+分布式计算）天文计算</p>
<p>场景3：海量数据存储，如Facebook的存储集群。</p>
<p><a href="http://cloud.zol.com.cn/441/4415033_all.html" target="_blank" rel="external">更多应用场景</a></p>
<h3 id="Hadoop原理">Hadoop原理</h3><h4 id="HDFS">HDFS</h4><p>HDFS（Hadoop File System），是Hadoop的分布式文件存储系统</p>
<ol>
<li>将大文件分解为多个Block，每个Block保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。</li>
<li>默认每个Block保存3个副本，64M为1个Block。</li>
<li>将Block按照key-value映射到内存当中。</li>
</ol>
<p>HDFS架构图如下：</p>
<p><img src="http://i.imgur.com/ZliSEXb.png" alt=""></p>
<h5 id="NameNode">NameNode</h5><p>HDFS使用主从结构，NameNode是Master节点，是领导。所有的客户端的读写请求，都需要首先请求NameNode。</p>
<p>NameNode存储</p>
<ol>
<li>fsimage：元数据镜像文件（文件系统的目录树，文件的<strong>元数据</strong>信息）。元数据信息包括文件的信息，文件对应的block信息（版本信息，类型信息，和checksum），以及每一个block所在的DataNode的信息。</li>
<li>edits：元数据的操作日志</li>
</ol>
<h5 id="DataNode">DataNode</h5><p>DataNode是Slave，负责真正存储所有的block内容，以及数据块的读写操作</p>
<p>NameNode，DataNode，rack只是一些逻辑上的概念。NameNode和DataNode可能是一台机器也可能是，相邻的一台机器，很多DataNode可能处于同一台机器。rack是逻辑上比DataNode更大的概念，可能是一台机器，一台机柜，也可能是一个机房。通过使文件的备份更广泛地分布到不同的rack，DataNode上可以保证数据的可靠性。</p>
<h5 id="HDFS写入数据">HDFS写入数据</h5><ol>
<li>Client拆分文件为64M一块。</li>
<li>Client向NameNode发送写数据请求。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode。</li>
<li>Client向DataNode发送block1,2,3….；发送过程是以流式写入。流式写入，数据流向为DataNode1-&gt;DataNode2-&gt;DataNode3(1,2,3为通过规则选出来的可用的DataNode)</li>
<li>发送完毕后告知NameNode</li>
<li>NameNode告知Client发送完成</li>
</ol>
<p>在写数据的时候：</p>
<ul>
<li>写1T文件，我们需要3T的存储，3T的网络流量贷款。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ul>
<h5 id="HDFS读取数据">HDFS读取数据</h5><ol>
<li>Client向NameNode发送读请求</li>
<li>NameNode查看MetaData信息，返回文件的block位置</li>
<li>根据一定规则（优先选择附近的数据），按顺序读取block</li>
</ol>
<p><a href="http://www.weixuehao.com/archives/596" target="_blank" rel="external">更多内容</a></p>
<h4 id="MapReduce">MapReduce</h4><p>Map是把一组数据一对一的<strong>映射</strong>为另外的一组数据，其映射的规则由一个<strong>map函数</strong>来指定。Reduce是对一组数据进行<strong>归约</strong>，这个归约的规则由一个<strong>reduce函数</strong>指定。</p>
<p>整个的MapReduce执行过程可以表示为：</p>
<p><code>(input)&lt;k1, v1&gt; =&gt; map =&gt; &lt;k2, v2&gt; =&gt; combine =&gt; &lt;k2, v2’&gt; =&gt; reduce =&gt; &lt;k3, v3&gt;(output)</code></p>
<p>也可以表示为流程图：</p>
<p><img src="http://i.imgur.com/yRsLgoK.png" alt=""></p>
<ol>
<li><strong>分割</strong>：把输入数据分割成不相关的若干键/值对（key1/value1）集合，作为input</li>
<li><strong>映射</strong>：这些键/值对会由多个map任务来<strong>并行地处理</strong>。输出一些中间键/值对key2/value2集合</li>
<li><strong>排序</strong>：MapReduce会对map的输出（key2/value2）按照key2进行排序（便于归并）</li>
<li><strong>conbine</strong>：属于同一个key2的所有value2组合在一起作为reduce任务的输入（相当于提前reduce，减小key2的数量，减小reduce的负担）</li>
<li><strong>Partition</strong>：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li><strong>规约</strong>：由reduce任务计算出最终结果并输出key3/value3。</li>
</ol>
<h4 id="程序员需要做的">程序员需要做的</h4><ul>
<li>单机程序需要处理数据读取和写入、数据处理</li>
<li>Hadoop程序需要实现map和reduce函数</li>
<li>map和reduce之间的数据传输、排序，容错处理等由Hadoop MapReduce和HDFS自动完成。</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hadoop/"> #Hadoop </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/04/22/一步一步写一个PHP框架2/">
                一步一步写一个PHP框架（二）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-22
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/web开发/">web开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/04/22/一步一步写一个PHP框架2/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/22/一步一步写一个PHP框架2/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%B8%80/">这位大哥</a>,的内容和Codeigniter框架的源码。</p>
<h2 id="程序框架的搭建">程序框架的搭建</h2><p>前提：已经搭建好了一个apache+PHP的开发环境，我使用的是Apache+mod_php5的方式。</p>
<p>在根目录<code>simplemvc</code>下新建以下文件夹</p>
<ul>
<li><code>config</code> 用来存放配置文件</li>
<li><code>controller</code>用来存放控制器</li>
<li><code>lib</code>用来存放引入的库文件</li>
<li><code>model</code>用来存放模型</li>
<li><code>system</code>用来存放系统文件<ul>
<li><code>core</code>核心文件，包括核心controller控制器等，所有的controller都要继承于他</li>
<li><code>lib</code>存放核心的库文件，包括route等</li>
<li><code>app.php</code>应用程序驱动类</li>
</ul>
</li>
<li><code>view</code>用来存放视图</li>
<li><code>index.php</code>项目的入口文件，程序是从这里开始执行的。</li>
</ul>
<h2 id="定义系统路径">定义系统路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#39044;&#23450;&#20041;&#10;define(&#39;SYSTEM_PATH&#39;, dirname(__FILE__).&#39;/system&#39;);&#10;define(&#39;ROOT_PATH&#39;,  substr(SYSTEM_PATH, 0,-7));&#10;define(&#39;SYS_LIB_PATH&#39;, SYSTEM_PATH.&#39;/lib&#39;);&#10;define(&#39;APP_LIB_PATH&#39;, ROOT_PATH.&#39;/lib&#39;);&#10;define(&#39;SYS_CORE_PATH&#39;, SYSTEM_PATH.&#39;/core&#39;);&#10;define(&#39;CONTROLLER_PATH&#39;, ROOT_PATH.&#39;/controller&#39;);&#10;define(&#39;MODEL_PATH&#39;, ROOT_PATH.&#39;/model&#39;);&#10;define(&#39;VIEW_PATH&#39;, ROOT_PATH.&#39;/view&#39;);</span><br></pre></td></tr></table></figure>
<p>预定义一些常量，在之后的程序中我们会使用这些路径。</p>
<h2 id="加载配置文件，和应用程序驱动类">加载配置文件，和应用程序驱动类</h2><h3 id="配置文件">配置文件</h3><p>在config文件夹下的<code>config.php</code><br>··<br>$CONFIG[‘system’][‘db’]</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PHP/"> #PHP </a>
          
            <a href="/tags/PHP框架/"> #PHP框架 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/04/20/一步一步写一个PHP框架1/">
                一步一步写一个PHP框架（一）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-20
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/web开发/">web开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/04/20/一步一步写一个PHP框架1/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/20/一步一步写一个PHP框架1/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
<p>为了更好地理解PHP里面框架的设计，目标是自己写一个简单的PHP MVC框架，一方面可以更深入地学习PHP，一方面也能够更深入地理解框架设计里面的思想。</p>
<h2 id="Apache的工作流程">Apache的工作流程</h2><p>Apache是一个Web服务器，也可以叫做http服务器，因为Apache只能处理http请求。常见的web服务器还有Nginx</p>
<p>Apache的工作流程如下：</p>
<ol>
<li>浏览器向服务器发出HTTP请求(Request)。</li>
<li>服务器收到浏览器的请求数据，经过分析处理，向浏览器输出响应数据（Response）。</li>
<li>浏览器收到服务器的响应数据，经过分析处理，将最终结果显示在浏览器中。</li>
</ol>
<p>Apache和Nginx都属于Web服务器，两者都实现了HTTP 1.1协议。</p>
<p>所以如果有人问FTP协议可以在Apache上工作吗？答案是用Apache FTP Server可以，Apache web服务器不可以。</p>
<p>Apache是用C语言写的，服务器当然要追求高效率。</p>
<h2 id="PHP原理">PHP原理</h2><p>PHP的核心解释器是用C语言写的，相当于我们写了PHP代码，会有一个C语言写好的解释工具一边解释，一边执行。实际上在写PHP的时候就是在使用一个C语言写好的工具，我们的PHP代码就是指挥这个工具的命令。</p>
<p>PHP包括四层体系：</p>
<ol>
<li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分。负责翻译PHP代码，是一切的核心。</li>
<li>Extensions：围绕Zend引擎，通过组件方式提供基础服务。常见内置函数如array是由extension实现的。</li>
<li>Sapi通过一系列的<strong>钩子函数</strong>，使得PHP可以和外围交互数据。如Apache</li>
<li>上层应用：平时写的PHP程序</li>
</ol>
<blockquote>
<p>如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路， 车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。</p>
</blockquote>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p><strong>hashtable</strong>是PHP的核心数据结构，数组就是典型的应用。Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表（解决冲突），提供了正向、反向遍历数组的功能。</p>
<p>更详细的内容参考<a href="!http://www.cnblogs.com/zcy_soft/archive/2013/03/14/2959396.html">这里</a></p>
<h2 id="PHP在Apache上运行">PHP在Apache上运行</h2><h3 id="以模块加载的方式运行">以模块加载的方式运行</h3><p>这种方式使用了Apache的Hook机制。所谓Hook机制，就是在自己的程序运行的时候允许别的模块插上一腿。当我们配置Apache服务器的<code>http.config</code>文件时，写入<code>mod_php5.so/php5apache2.dll</code>就是将自定义的函数注入到Apache的请求处理循环当中。在模块化的运行方式中，PHP与Web服务器一起启动并且运行，通过Apache自身的进程线程管理来处理并发的请求。</p>
<h3 id="以CGI，FastCGI方式运行">以CGI，FastCGI方式运行</h3><p>CGI英文叫做公共网关接口，CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。Apache在Http请求的时候会将请求提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。</p>
<p>CGI VS FastCGI</p>
<p>FastCGI是CGI的加强版本，CGI是单进程，多线程的运行方式，程序执行完成之后就会销毁。FastCGI是常驻(long-live)型的CGI.有自身的进程管理器，不必每一次都fork一个进程（CGI解释器）去执行。常见的PHP-FPM是一个PHP FastCGI管理器。</p>
<p>关于更多的对比可以看<a href="http://fifiole.blog.163.com/blog/static/169459225201222962651804/" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>目前在HTTPServer这块基本可以看到有三种stack比较流行：</p>
<p>（1）Apache+mod_php5</p>
<p>（2）lighttp+spawn-fcgi</p>
<p>（3）nginx+PHP-FPM</p>
<p>三者后两者性能可能稍优，但是Apache由于有丰富的模块和功能，目前来说仍旧是老大。有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PHP/"> #PHP </a>
          
            <a href="/tags/PHP框架/"> #PHP框架 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/04/07/如何完成一个在线考试的功能/">
                如何完成一个在线考试的功能
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/web开发/">web开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/04/07/如何完成一个在线考试的功能/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/07/如何完成一个在线考试的功能/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2><h3 id="考卷生成">考卷生成</h3><p>卷子总是由试题组成的，试题包括内容，选项之类的<strong>文本</strong>，以及相关的<strong>图片</strong>。每个试题在数据库中当然只能存一份，否则就浪费了存储空间。很多的OJ题目是随机生成的，一句特定的内容随机生成考题，并且答题结果也是每人一份的，这时候很容易就想到需要中间表来存储这个内容了。</p>
<h3 id="保存现场">保存现场</h3><p>如果使用一个大form，在用户提交考试结果的时候把所有数据提交到server，那中间如果用户不小心退出了，所有的答题内容就<strong>丢失</strong>了。所以需要在用户答题的过程中不断<strong>异步存储</strong>用户答题的结果，使得用户在任何一个时候退出，我们都能够统计出他已经答过的题并且给出分数（或者结果）的。</p>
<h3 id="断线处理">断线处理</h3><p>当用户断线的时候，或者不小心退出了浏览器，系统需要允许用户重新登录，<strong>继续考试</strong>。</p>
<h3 id="倒计时">倒计时</h3><p>倒计时运行在client上，你永远也无法控制client端的人会对代码做什么。在js中添加断点可以停止倒计时空间的运行，所以关于时间必须在server端进行校验，才能规避在时间上作弊的行为。</p>
<h3 id="结算分数">结算分数</h3><p>你永远也无法控制client端的人会对代码做什么，同时开多个窗口可以多次提交结果，甚至可以操纵client端的数据以各种方式提交数据。在server端要考虑到这种行为并且做出相应的对策，对策就是分数永远只结算一次。</p>
<h2 id="实现">实现</h2><h3 id="数据库">数据库</h3><p>根据我做的项目的系统需求，有如下几个关键概念：</p>
<ul>
<li>模块（module）<br>课程分为若干个模块（module），每个模块对应一次考试。每次有限定的时间。</li>
<li>考点（test_point）<br>每个模块包括若干个考点，每次考试从考点中随机抽取题目。</li>
<li>题目(question)<br>题目都是选择题，最多四个，单选题，题干和每个选项都可能对应图片。基于题目题型是固定的，我把这些内容都放到了一个表里，如果考题类型丰富需要更灵活的设计。</li>
<li>考卷（report）<br>每次考试的考卷，上面会有分数。考卷和题目有着多对多的关系，需要一个中间表来存储。</li>
</ul>
<p>出去其他需求，考试部分的数据表简单设计如下：<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqw7h465uvj20pz0ibgmo.jpg" alt="enter image description here"></p>
<h3 id="考卷生成-1">考卷生成</h3><p>每个考试（模块）都对应三种状态：</p>
<ol>
<li>没有考过试的模块 ——— 对应 ——— 生成考题，去考试</li>
<li>已经开始考试还没结束的模块 ——— 对应 ——— 使用已经生成的考题，继续考试</li>
<li>已经结束的模块 ——— 对应 ——— 查看考试成绩</li>
</ol>
<p>当系统没有这个模块的report信息的时候，根据考点随机抽取题目，生成考题和report，<br>report状态变成<strong>进行中</strong>，分数还没有结算。</p>
<p>关键函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#32452;&#21367;&#65292;&#23558;&#32452;&#21367;&#30340;&#20869;&#23481;&#25918;&#20837;report&#34920;&#65292;question_in_report&#34920;&#65292;&#32452;&#21367;&#23545;&#21516;&#19968;&#20010;&#32771;&#35797;&#19981;&#20250;&#32452;&#20004;&#27425;&#10;     * @param  [type] $student_id     [description]&#10;     * @param  [type] $module_id      [description]&#10;     * @param  [type] $logic_class_id [description]&#10;     * @return [type]                 [description]&#10;     */&#10;    function get_questions($student_id,$module_id,$logic_class_id)&#10;    &#123;&#10;        /*&#38656;&#35201;&#25552;&#21069;&#20570;&#30340;&#26816;&#26597;:&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#24050;&#32463;&#22312;&#36825;&#20010;&#36923;&#36753;&#29677;&#19979;&#32771;&#36807;&#36825;&#20010;&#27169;&#22359;&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#26159;&#29992;&#25143;&#33258;&#24049;&#10;        &#36825;&#20010;&#23398;&#29983;&#26159;&#21542;&#23646;&#20110;&#36825;&#20010;&#36923;&#36753;&#29677;&#10;        &#36825;&#20010;&#36923;&#36753;&#29677;&#20013;&#26159;&#21542;&#26377;&#36825;&#38376;&#35838;*/&#10;        &#10;        //&#36941;&#21382;&#25152;&#26377;&#32771;&#28857;&#65292;&#20174;&#27599;&#20010;&#32771;&#28857;&#20013;&#38543;&#26426;&#25277;&#20986;&#19968;&#36947;&#39064;&#23384;&#20837;$test_questions&#10;&#10;        //&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;&#10;        $datetime=date(&#34;Y-m-d H:i:s&#34;);&#10;        &#10;        //&#23558;&#32467;&#26524;&#23384;&#20837;report&#34920;&#10;        $this-&#62;report_model-&#62;add($report_item);&#10;        &#10;        //&#23558;&#32452;&#39064;&#20449;&#24687;&#20889;&#20837;question_in_report &#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="保存现场-1">保存现场</h3><p>使用一个简单的jquery ajax，异步提交用户每次点击的选项，都在后台存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function save_choose(question_id,choose)&#10;&#123;&#10;    myUrl=&#34;&#60;?php echo site_url(&#39;student_test/ajax_save_user_choose&#39;)?&#62;/&#34;+&#60;?php echo $report_id ?&#62;+&#34;/&#34;+question_id+&#34;/&#34;+choose;&#10;    $.ajax(&#123;&#10;        type:&#34;post&#34;,&#10;        url:myUrl,&#10;        success:function(resp)&#123;&#125;&#10;    &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>后台接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#24322;&#27493;ajax&#23384;&#20648;&#29992;&#25143;&#30340;&#36873;&#25321;&#10; * @param  [type] $report_id   [description]&#10; * @param  [type] $question_id [description]&#10; * @return [type]              [description]&#10; */&#10;function ajax_save_user_choose($report_id,$question_id,$choose)&#10;&#123;&#10;    //&#20808;&#21028;&#26029;&#26102;&#38388;&#26159;&#21542;&#27491;&#30830;     &#10;    $now=date(&#34;Y-m-d H:i:s&#34;);&#10;    $this-&#62;load-&#62;helper(&#39;compare_time&#39;);&#10;    $time_past=compare_time_of_minute($report[&#39;datetime&#39;],$now);&#10;    &#10;    if($time_past&#60;=($module[&#39;time_limit&#39;]))&#123;&#10;        //&#26356;&#26032;&#20449;&#24687;&#10;        );  &#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="断线处理-1">断线处理</h3><p>当用户掉线重新进入，需要通过比对<strong>report状态</strong>+<strong>时间</strong>，确定用户是否可以继续考试。</p>
<ul>
<li>如果report状态为结束，则不能继续考试</li>
<li>如果report状态为进行中，时间超过截止时间，不能继续考试</li>
<li>如果report状态为进行中，时间还有，继续考试</li>
</ul>
<p>继续考试通过reportid得到已经<strong>组好的试题信息</strong>，和<strong>用户的答题情况</strong>，返回数据<br>关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#26597;&#25214;&#25968;&#25454;&#24211;&#20013;&#30340;&#24050;&#32463;&#32452;&#22909;&#21367;&#30340;&#20449;&#24687;&#10;     * @param  [type] $report_id [description]&#10;     * @return [type]            [description]&#10;     */&#10;    function get_exist_questions($report_id)&#10;    &#123;       &#10;        //&#23384;&#20648;&#25152;&#26377;&#32771;&#21367;&#39064;&#30446;&#30340;&#25968;&#32452;&#10;        $test_questions = array();&#10;        &#10;        //&#20174;question_in_report&#20013;&#26597;&#25214;&#25152;&#26377;&#28385;&#36275;&#26465;&#20214;&#30340;&#38382;&#39064;&#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="倒计时-1">倒计时</h3><p>客户端的倒计时使用js，最简单的可以使用<code>window.setInterval()</code>函数，每隔1s时间修改html的内容。结果在stackoverflow上询问倒计时解决方法的时候被“鄙视”了一下：</p>
<blockquote>
<p>You’re design is bad, you should base your time measurement using the date object. Each time a loop will get triggered, check the current date with new Date() and keep track of the last date.</p>
<p>Keep in mind that even if you set an interval of 1000ms, it doesn’t mean that on the function will get called every seconds. It only means that it will never get called before 1000ms. As Javascript runs in one thread, any blocking process may delay calling methods that will remain in the event queue (setInterval in this case).</p>
</blockquote>
<p>大体意思是<code>setInterval</code>能保证运行的时间一定比传入的参数多，但是js是单线程的，别的操作有可能会阻塞这个方法，所以最好使用<code>Date()</code>方法来比对客户端的时间。</p>
<p>所以我的实现是使用了<a href="https://github.com/tomgrohl/jCountdown" target="_blank" rel="external">jcountdown插件</a>，通过计算出截止日期，进行倒计时。方法很简单，只需要在<code>id</code>为<code>time</code>的div上使用插件里的函数就可以了。通过template可以指定显示时间的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#34;#time&#34;).countdown(&#123;&#10;            minSingularText: &#39;&#20998;&#39;,&#10;            secSingularText: &#39;&#31186;&#39;,&#10;            &#34;date&#34; : d,&#10;            template: &#34;&#60;div class=&#39;time-item&#39;&#62;&#60;strong&#62;%i %s&#60;/strong&#62;&#60;/div&#62;&#34;,&#10;            onComplete : function()&#123;$(&#34;#test&#34;).submit();&#125;&#10;        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>不管倒计时做的多么炫酷，client is client，我永远无法控制它最终怎么运行，有没有被篡改。所以，每一次用户答题提交ajax请求，以及最终提交考卷的时候，都要<strong>比对时间</strong>，只保存合理的请求。这样就保证了整个考试系统在时间上的正确性。</p>
<h3 id="结算分数-1">结算分数</h3><p>结算分数有以下几个时间点</p>
<ol>
<li>用户答题完成，提交所有数据</li>
<li>用户在时间结束时由浏览器自动提交数据</li>
<li>用户没有通过浏览器提交数据（半路关闭浏览器），下次登录时系统自动算分</li>
</ol>
<p>1,2类似，正常提交表单就可以，需要注意的是：</p>
<ol>
<li>在所有这些过程中，<strong>网络可能有延时</strong>，所以在比对用户提交的时间的时候，可以宽限一定时间。</li>
<li>提交后修改report的状态，这个操作只有一次，拒绝之后的所有修改（form的数据，ajax请求）。</li>
</ol>
<p>3对应着意外退出，时间过了才重新登录的情况。这个时候的考试状态是，<code>report</code>的状态还是进行中，但是时间已经超过。这时候通过保存现场的数据计算分数即可。</p>
<h2 id="结束语">结束语</h2><p>我通过这样的设计，完成了一个体验相对良好，逻辑上没有问题，避免了用户在时间和数据上做手脚的在线考试功能。但因为是第一次做，也许有的地方还是考虑不周全，或者有更好的设计，希望大家多多指正。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/04/06/网站应对大数据量高并发的挑战/">
                网站应对大数据量高并发的挑战
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-04-06
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/web开发/">web开发</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/04/06/网站应对大数据量高并发的挑战/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/06/网站应对大数据量高并发的挑战/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使用不同的架构和解决方案。架构的改变和升级，往往意味着成本，所有没有最好的架构，只有最适合的架构。</p>
<p>应对数据量和负载的压力，可以从以下几个方面入手:</p>
<ul>
<li>硬件性能挖掘</li>
<li>数据库和存储</li>
<li>应用程序架构<br>每一个方面里都有非常多的技术</li>
</ul>
<h2 id="硬件性能挖掘">硬件性能挖掘</h2><p>硬件性能是有上限的，超过了就必须升级硬件，所以硬件是基础。</p>
<p>但是并不是一味的堆积硬件就可以了，要理解硬件的细节，如mysql的多线程写入机制，cpu寻址方式，顺序写和随机写的存储分布。不仅仅是购买硬件而已，但是核心是，理解硬件，理解系统级的处理机制，来做优化。</p>
<p>这样才能最大限度地挖掘硬件本省的性能，提供更好的服务。</p>
<h2 id="数据库和存储">数据库和存储</h2><p>大文件，或者大量的静态文件，使用静态存储，云存储</p>
<h3 id="建立恰当的索引">建立恰当的索引</h3><h3 id="数据库连接线程池缓存">数据库连接线程池缓存</h3><h3 id="分库/分表/分区">分库/分表/分区</h3><p>MySQL数据库表一般承受数据量在百万级别，再往上增长，各项性能将会出现大幅度下降，因此，当我们预见数据量会超过这个量级的时候，建议进行分库/分表/分区等操作。<br>一个主库一个从库、到一个主库多个从库、 然后到多个主库多个从库。从库做备份，或者作为读写分离的库。<br>多个库之间使用日志同步。</p>
<h3 id="拆分方式：水平拆分VS垂直拆分">拆分方式：水平拆分VS垂直拆分</h3><ul>
<li>垂直拆分 ：是指按功能模块拆分，比如可以将群组相关表和照片相关表存放在不同的数据库中，这种方式多个数据库之 间的表结构不同 。（豆瓣 的 各核心业务/模块（书籍、电影、音乐）相对独立，数据的增加速度也比较平稳。适合垂直拆分）</li>
<li>水平拆分 ：而水平拆分是将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构 完全相同 。</li>
</ul>
<h3 id="按索引_/_映射表对应">按索引 / 映射表对应</h3><p>建立一个索引表，保存每个用户的ID和数据库ID的对应关系，每次读写用户数据时先从这个表获取对应数据库。新用户注册后，在所有可用 的数据库中随机挑选一个为其建立索引。</p>
<h3 id="读写分离">读写分离</h3><p>读写分离，主库写，从库读。</p>
<h3 id="减少数据库写">减少数据库写</h3><p>先将修改请求生效在cache中，让外界查询显示正常，然后将这些sql修改放入到一个队列中存储起来，队列满或者每隔一段时间，合并为一个请求到数据库中更新数据库</p>
<h2 id="应用程序架构">应用程序架构</h2><h3 id="负载均衡">负载均衡</h3><p>Web负载均衡（Load Balancing），作用在Web系统的外部网络环境，简单地说就是给我们的服务器集群分配“工作任务”，而采用恰当的分配方式。对于保护处于后端的Web服务器来说，非常重要。策略有很多</p>
<h4 id="HTTP重定向">HTTP重定向</h4><p>Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。<br>应用：重定向到距离近的镜像去下载。</p>
<h4 id="反向代理负载均衡">反向代理负载均衡</h4><p>反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。把HTTP请求分配道不同的服务器上</p>
<h4 id="IP负载均衡">IP负载均衡</h4><p>IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。这种方式，也被称为“四层负载均衡”。</p>
<h4 id="DNS负载均衡">DNS负载均衡</h4><p>DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。</p>
<h4 id="DNS/GSLB负载均衡">DNS/GSLB负载均衡</h4><p>我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在<strong>同一个域名映射为多IP</strong>的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。<strong>一般情况下都是按照地理位置，将离用户近的IP返回给用户</strong>，减少网络传输中的路由节点之间的跳跃消耗。<br><strong>应用</strong>：CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。</p>
<h3 id="在Web服务器和数据库之间建立缓存">在Web服务器和数据库之间建立缓存</h3><p>80%的请求只关注在20%的热点数据上。因此，我们应该建立Web服务器和数据库之间的缓存机制。用磁盘作为缓存，也可以用内存缓存的方式。通过它们，<strong>将大部分的热点数据查询，阻挡在数据库之前</strong>。 </p>
<h4 id="页面静态化">页面静态化</h4><p>页面上的大部分内容在很长一段时间内，可能都是没有变化的。生成的静态html页面缓存到Web服务器的磁盘本地。直接将本地磁盘文件返回给用户。</p>
<h4 id="单台/集群内存缓存">单台/集群内存缓存</h4><p>一旦Web系统规模变大，例如当我有100台的Web服务器的时候。那样这些磁盘文件，将会有100份，这个是资源浪费，也不好维护。这个时候有人会想，可以集中一台服务器存起来<br>内存缓存的选择，主要有<strong>redis/memcache</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">72</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
