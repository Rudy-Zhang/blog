<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/12/找工作总结-正则表达式/">
                正则表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/12/找工作总结-正则表达式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/找工作总结-正则表达式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="简介">简介</h2><p>描述了一种字符串匹配的模式，常用于：<br>grep:从特定的文件中或从标准输入中查找含有某个字符串的行<br>sed :从输入中读取信息，经过编辑后输出<br>awk: 伪装成实用程序的强大编程语言，主要用于文本处理<br>编程语言：如python</p>
<h2 id="符号">符号</h2><h3 id="基本符号">基本符号</h3><p><code>^</code> 行首定位符，表示以..开始<br><code>$</code> 行尾定位符，表示以..结束<br><code>.</code> 匹配单个字符<br><code>*</code> 匹配0个或任意多个字符<br><code>[]</code> 匹配[]中出现字符范围内的一个字符<br><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h3 id="扩展元字符">扩展元字符</h3><p>grep支持基本元字符，通过<code>egrep</code>或者<code>grep -e</code>可以启用扩展元字符。</p>
<p><code>?</code> 匹配0个或者1个<br><code>+</code> 匹配1个或者多个<br><code>|</code> 或者<br><code>()</code>分组符号<br><code>{i}</code>表示出现了i次，{i,j}表示出现了i到j次</p>
<p><code>\n</code> 匹配一个换行符。<br><code>\t</code> 匹配一个制表符。<br><code>\d</code> 匹配一个数字，等价于[0-9]<br><code>\D</code> 匹配一个非数字，等价于[^0-9]<br><code>\s</code> 匹配任何<strong>空白字符</strong>，包括空格、制表符、换页符等等。等价于<code>[ \f\n\r\t\v]</code>。<code>[^\s]</code>表示任何非空白字符<br><code>\S</code> 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</p>
<p><code>\w</code> 匹配包括下划线的<strong>任何单词</strong>字符。等价于<code>“[A-Za-z0-9_]”</code>。<br><code>\W</code> 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。[^\w]<br>注意<code>\S</code>比<code>\w</code>包括<code>@#￥</code>等更多特殊字符</p>
<h2 id="简单实例">简单实例</h2><ul>
<li><code>^ $</code><pre><code><span class="keyword">ls</span> -<span class="keyword">l</span> | grep ^<span class="keyword">d</span> 匹配以<span class="keyword">d</span>开头的所有内容
<span class="keyword">ls</span> -<span class="keyword">l</span> | grep <span class="keyword">d</span>$ 匹配以<span class="keyword">d</span>结束的所有内容
^$ 匹配空行
^.$只包含一个字符的
</code></pre></li>
<li><code>* ？ +</code><pre><code>compu*ter 匹配<span class="keyword">u</span>，重复0次或多次
compu?ter 匹配0个或者1个<span class="keyword">u</span>
compu+ter 匹配1个或多个<span class="keyword">u</span>
</code></pre></li>
<li><code>\</code><br>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
<li><p><code>[]</code></p>
<pre><code><span class="attr_selector">[1234]</span> 匹配1,2,3,4中的一个
<span class="attr_selector">[1-9]</span> 数字1<span class="tag">-9</span>中的一个
<span class="attr_selector">[A-Za-z]</span> 所有字母
<span class="attr_selector">[^0-9]</span> 一个非数字的字符
</code></pre></li>
<li><p><code>{}</code></p>
<pre><code><span class="literal">A</span>{<span class="number">2</span>}B   匹配AAB
<span class="literal">A</span>{<span class="number">4</span>,}B   匹配<span class="literal">A</span>出现至少<span class="number">4</span>次B
<span class="literal">A</span>{<span class="number">2</span>,<span class="number">4</span>}B  匹配<span class="literal">A</span>出现在<span class="number">2</span>至<span class="number">4</span>次之间
</code></pre></li>
</ul>
<h2 id="匹配实例">匹配实例</h2><h3 id="匹配html标签">匹配html标签</h3><pre><code><span class="variable">&lt;(\w*)&gt;</span>.<span class="keyword">*</span>?<span class="variable">&lt;\1&gt;</span>
</code></pre><p><code>.*</code>贪婪匹配，尽可能匹配多<br><code>.*?</code>最小匹配，尽可能匹配少</p>
<h3 id="匹配url">匹配url</h3><pre><code>(<span class="keyword">http</span>|<span class="keyword">https</span>|<span class="keyword">ftp</span>)://[\S]*
</code></pre><h3 id="匹配邮箱">匹配邮箱</h3><pre><code><span class="command">\w</span>+(-+.<span class="command">\w</span>+)*@<span class="command">\w</span>+(-+.<span class="command">\w</span>+)*
</code></pre><p><strong>注意邮箱中可能存在的.-+</strong></p>
<h3 id="匹配空行,可能有\t空格等空字符">匹配空行,可能有\t空格等空字符</h3><pre><code>^\s<span class="keyword">*</span>$
</code></pre><h3 id="匹配国内电话">匹配国内电话</h3><pre><code>\d<span class="list">{3,4}</span>-\d<span class="list">{8}</span>
</code></pre><h3 id="匹配身份证号">匹配身份证号</h3><pre><code><span class="list">(\d<span class="collection">{<span class="number">15</span>}</span>|\d<span class="collection">{<span class="number">17</span>}</span><span class="list">(\d|x)</span>)</span>
</code></pre><h3 id="匹配ip地址">匹配ip地址</h3><pre><code><span class="command">\d</span><span class="special">{</span>1,3<span class="special">}</span><span class="command">\.</span><span class="command">\d</span><span class="special">{</span>1,3<span class="special">}</span><span class="command">\.</span><span class="command">\d</span><span class="special">{</span>1,3<span class="special">}</span><span class="command">\.</span><span class="command">\d</span><span class="special">{</span>1,3<span class="special">}</span>
</code></pre><h2 id="应用">应用</h2><h3 id="在vi中修改参数，foo(a,b,c)的实例改为foo(b,a,c)">在vi中修改参数，foo(a,b,c)的实例改为foo(b,a,c)</h3><pre><code>：s/<span class="function"><span class="title">foo</span><span class="params">(\([^,]*\)</span></span>,\([^,]*\),\([^,]*\))/<span class="function"><span class="title">foo</span><span class="params">(\<span class="number">2</span>,\<span class="number">1</span>,\<span class="number">3</span>)</span></span>/gc
</code></pre><h3 id="sed中的应用">sed中的应用</h3><p>删除所有空行</p>
<pre><code>sed <span class="string">'/^$/d'</span> <span class="built_in">test</span>
</code></pre><h3 id="在awk中应用">在awk中应用</h3><p>打印正则匹配到的部分</p>
<pre><code><span class="keyword">cat</span> <span class="keyword">test</span> | awk '<span class="label">$2</span>~/ee/{<span class="keyword">print</span>}'
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/正则表达式/"> #正则表达式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/12/找工作总结-SQL语句/">
                SQL语句
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/12/找工作总结-SQL语句/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/找工作总结-SQL语句/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="表结构">表结构</h2><table>
<thead>
<tr>
<th style="text-align:left">student</th>
<th style="text-align:left">sc</th>
<th style="text-align:left">course</th>
<th style="text-align:left">tesacher</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sid</td>
<td style="text-align:left">sid</td>
<td style="text-align:left">-</td>
<td style="text-align:left">tname</td>
</tr>
<tr>
<td style="text-align:left">sname</td>
<td style="text-align:left">cid</td>
<td style="text-align:left">cid</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">sage</td>
<td style="text-align:left">score</td>
<td style="text-align:left">cname</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">ssex</td>
<td style="text-align:left">-</td>
<td style="text-align:left">tid</td>
<td style="text-align:left">tid</td>
</tr>
</tbody>
</table>
<h2 id="增删改操作">增删改操作</h2><h3 id="建表">建表</h3><pre><code>create <span class="tag">table</span> student(
    sid <span class="function"><span class="title">varchar</span><span class="params">(<span class="number">20</span>)</span></span>,
    sname <span class="function"><span class="title">varchar</span><span class="params">(<span class="number">20</span>)</span></span>,
    sage number,
    ssex <span class="function"><span class="title">varchar</span><span class="params">(<span class="number">20</span>)</span></span>
)
</code></pre><h3 id="插入">插入</h3><pre><code>insert into <span class="function"><span class="title">student</span><span class="params">(sid, sname, sage, ssex)</span></span>
    <span class="function"><span class="title">values</span><span class="params">(<span class="string">'001'</span>, <span class="string">'kangyue'</span>, <span class="number">29</span>, <span class="string">'male'</span>)</span></span>
</code></pre><h3 id="修改">修改</h3><pre><code><span class="keyword">update</span> <span class="keyword">sc</span>
<span class="keyword">set</span> <span class="keyword">sc</span>.<span class="keyword">score</span> = '60'
where <span class="keyword">sc</span>.sid = '001'
</code></pre><h3 id="删除">删除</h3><p>删除叶平老师的sc记录</p>
<pre><code>delete sc
from sc, teacher as t, course as c
where sc<span class="class">.cid</span> = c<span class="class">.cid</span> and t<span class="class">.tid</span> = c<span class="class">.tid</span> and t<span class="class">.tname</span> = <span class="string">'叶平'</span>
</code></pre><h2 id="查询">查询</h2><h3 id="查询”001”课程比”002”课程成绩高的所有学生的学号">查询”001”课程比”002”课程成绩高的所有学生的学号</h3><pre><code>select s<span class="class">.sid</span>
from 
(select sid,score from sc where sc<span class="class">.cid</span> = <span class="string">'001'</span>) as <span class="tag">a</span>,
(select sid,score from sc where sc<span class="class">.cid</span> = <span class="string">'002'</span>) as <span class="tag">b</span>
where <span class="tag">a</span><span class="class">.sid</span> = <span class="tag">b</span><span class="class">.sid</span>  and <span class="tag">a</span><span class="class">.score</span> &gt; <span class="tag">b</span>.score
</code></pre><h3 id="查询平均成绩大于60分的同学的学号和平均成绩">查询平均成绩大于60分的同学的学号和平均成绩</h3><pre><code>select sc<span class="class">.sid</span>, <span class="function"><span class="title">avg</span><span class="params">(sc.age)</span></span>
from sc
group by sc<span class="class">.sid</span> 
having <span class="function"><span class="title">avg</span><span class="params">(sc.score)</span></span> &gt; <span class="number">60</span>
</code></pre><h4 id="sql中的分组">sql中的分组</h4><ul>
<li>where 对分组前的属性进行筛选</li>
<li>having<br>对分组后的属性进行筛选<br>使用聚合函数判断<br>不是用group by默认整个表为一组</li>
</ul>
<h3 id="查询姓李的老师的个数">查询姓李的老师的个数</h3><pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(t.tid)
<span class="keyword">from</span> teacher <span class="keyword">as</span> t
<span class="keyword">where</span> t.tname <span class="keyword">like</span> <span class="string">"李%"</span></span>
</code></pre><h4 id="sql中的通配符">sql中的通配符</h4><p>_    匹配单字符-&gt; ‘_im’ 匹配 Tim Jim<br>%    匹配一个或多个字符 -&gt; ‘李%’<br>[]    匹配单字符 -&gt; ‘[JT]im’<br>[^]    反向匹配 -&gt; ‘m[^c]%’<br>也可以使用REGEX()函数匹配正则</p>
<h3 id="查询所有同学的学号，姓名，选课书，总成绩">查询所有同学的学号，姓名，选课书，总成绩</h3><pre><code>select s<span class="class">.sid</span>, s<span class="class">.sname</span>, <span class="function"><span class="title">count</span><span class="params">(sc.id)</span></span>, <span class="function"><span class="title">sum</span><span class="params">(sc.score)</span></span>
from student as s, sc
where s<span class="class">.sid</span> = sc<span class="class">.sid</span>
group by sc.sid
</code></pre><p>使用左连接：<br>    select s.sid, s.sname, count(sc.id), sum(sc.score)<br>    from student as s left join sc on s.sid = sc.sid<br>    group by s.sid</p>
<h4 id="内连接，外连接，左连接，右连接">内连接，外连接，左连接，右连接</h4><ul>
<li>内连接 inner join = join 两边有匹配才选择</li>
<li>外连接<ul>
<li>左连接 left join 左边都选择</li>
<li>右连接 right join 右边都选择</li>
</ul>
</li>
</ul>
<h3 id="查询没学过叶平老师课的学生的学生，姓名">查询没学过叶平老师课的学生的学生，姓名</h3><pre><code>select st<span class="class">.sid</span>, st<span class="class">.sname</span>
from student as st
where st<span class="class">.sid</span> not <span class="keyword">in</span>
(select s<span class="class">.sid</span>
from sc, course as c, teacher as t
where sc<span class="class">.cid</span> = c<span class="class">.cid</span> and c<span class="class">.tid</span> = t<span class="class">.tid</span> and t<span class="class">.tname</span> = <span class="string">'叶平'</span>)
</code></pre><p><strong>子查询，not in取反</strong></p>
<h3 id="查询所有课程成绩小于60分的同学的学号姓名">查询所有课程成绩小于60分的同学的学号姓名</h3><pre><code>select s<span class="class">.sid</span>,s<span class="class">.sname</span>
from student as s
where s<span class="class">.sid</span> not <span class="keyword">in</span>
(select sc<span class="class">.sid</span>
from sc
where sc<span class="class">.score</span> &gt;= <span class="number">60</span>)
</code></pre><h3 id="查询每门课程平均成绩，结果按平均成绩升序，平均成绩相同按课程号降序">查询每门课程平均成绩，结果按平均成绩升序，平均成绩相同按课程号降序</h3><pre><code>select avg(<span class="keyword">sc</span>.sccore)
from <span class="keyword">sc</span>
group <span class="keyword">by</span> <span class="keyword">sc</span>.cid
<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sc</span>. avg(<span class="keyword">sc</span>.<span class="keyword">score</span>) asc, <span class="keyword">sc</span>.cid <span class="keyword">desc</span>
</code></pre><p><strong>排序，升序，降序</strong></p>
<h3 id="查询任何一门课程成绩在70分以上的姓名，课程名，分数">查询任何一门课程成绩在70分以上的姓名，课程名，分数</h3><pre><code><span class="type">SELECT</span> <span class="keyword">distinct</span> s.sid,s.sname
<span class="type">FROM</span> student <span class="keyword">as</span> s,sc
where s.sid = sc.sid <span class="keyword">and</span> sc.score &gt; <span class="number">70</span>
</code></pre><p><strong>distinct去重</strong></p>
<h3 id="查找001课程第三高的学生学号">查找001课程第三高的学生学号</h3><pre><code>select top 1 sid
from
(select top 3 <span class="keyword">sc</span>.sid, <span class="keyword">sc</span>.<span class="keyword">score</span>
from <span class="keyword">sc</span>
where <span class="keyword">sc</span>.cid = '001'
<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sc</span>.<span class="keyword">score</span> <span class="keyword">desc</span>
)
<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">score</span> asc
</code></pre><h4 id="查询第n高">查询第n高</h4><p>先降序排取前n个，后升序排取第一个。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/"> #数据库 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/12/找工作总结-设计模式/">
                设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/12/找工作总结-设计模式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/找工作总结-设计模式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="UML说明">UML说明</h2><p><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1ewxhltbbtdj20qy0d43zm.jpg" alt=""></p>
<h2 id="创建型模式">创建型模式</h2><h3 id="工厂模式-简单工厂">工厂模式-简单工厂</h3><p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewxia9uhulj20gr0emq3e.jpg" alt=""></p>
<h3 id="工厂模式-工厂方法模式">工厂模式-工厂方法模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewxite169fj20uo0c5q3p.jpg" alt=""></p>
<h3 id="工厂模式-抽象工厂">工厂模式-抽象工厂</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewxj6nh6fwj20v30h7dh0.jpg" alt=""></p>
<h3 id="Builder_模式，建造者模式">Builder 模式，建造者模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewy3ppzlfjj20uj0gbwfr.jpg" alt=""></p>
<h3 id="单例模式">单例模式</h3><p><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1ewy3ssxt7gj20bi04wglo.jpg" alt=""></p>
<h2 id="结构型模式">结构型模式</h2><h3 id="适配器模式">适配器模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy441hmlhj20hq0f3aar.jpg" alt=""></p>
<h3 id="桥接模式">桥接模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewy4lptm1aj20s00dymy3.jpg" alt=""></p>
<h3 id="外观模式">外观模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy53du88tj20ls0dq751.jpg" alt=""></p>
<h3 id="装饰者模式">装饰者模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewy96u7diej20tn0d30tq.jpg" alt=""></p>
<h3 id="代理模式">代理模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy9f8gw9sj20nz0dhmy3.jpg" alt=""></p>
<h3 id="享元模式">享元模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewya256t6rj20mo0bxq42.jpg" alt=""></p>
<h2 id="行为模式">行为模式</h2><h3 id="命令模式">命令模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewyaqv6oo7j20nz0e8dgz.jpg" alt=""></p>
<h3 id="中介者模式">中介者模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewybdmdrynj20nw0czt9x.jpg" alt=""></p>
<h3 id="观察者模式">观察者模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewyc3lzfo9j20ur0at0tp.jpg" alt=""></p>
<h3 id="策略模式">策略模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewyc8eguuij20ni0awmxu.jpg" alt=""></p>
<h3 id="状态模式">状态模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewyjbaj60kj20my0b40th.jpg" alt=""></p>
<h3 id="责任链模式">责任链模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewyjd2f4lhj20o50c7758.jpg" alt=""></p>
<h3 id="模板方法模式">模板方法模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewyk470amyj20j80daab3.jpg" alt=""></p>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/creational.html" target="_blank" rel="external">跟多关于设计模式的参考</a></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/"> #设计模式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-动态规划专题/">
                动态规划
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-动态规划专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-动态规划专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>动态规划的关键是写出状态转移方程</p>
<h3 id="青蛙跳台阶_VS_斐波那契数列">青蛙跳台阶 VS 斐波那契数列</h3><h4 id="问题描述">问题描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="解法">解法</h4><p>状态转移方程：</p>
<pre><code><span class="tag">a</span>[n] = <span class="tag">a</span>[n-<span class="number">1</span>] + <span class="tag">a</span>[n-<span class="number">2</span>]
</code></pre><h4 id="代码">代码</h4><p>递归，使用vector存储每一步的结果，防止重复计算</p>
<pre><code><span class="keyword">class</span> Solution {
public:
    int jumpFloor(int number) {
        <span class="keyword">if</span>(number &lt;= 0) <span class="keyword">return</span> 0;
        vector&lt;int&gt; <span class="literal">vec</span>(number + 1, 0);
        <span class="keyword">count</span>(number, <span class="keyword">vec</span>);
        <span class="keyword">return</span> <span class="keyword">vec</span>[number];
    }
    int <span class="keyword">count</span>(int <span class="keyword">n</span>, vector&lt;int&gt;&amp; <span class="keyword">vec</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">n</span> == 0 || <span class="keyword">n</span> == 1 || <span class="keyword">n</span> == 2)
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">n</span>;
        <span class="keyword">if</span>(<span class="keyword">vec</span>[<span class="keyword">n</span>] != 0)
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        <span class="keyword">else</span>
        {
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">count</span>(<span class="keyword">n</span> - 1, <span class="keyword">vec</span>) + <span class="keyword">count</span>(<span class="keyword">n</span> - 2, <span class="keyword">vec</span>);
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        }
    }
};
</code></pre><p>非递归：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> jumpFloor(<span class="built_in">int</span> <span class="keyword">number</span>) {
        <span class="keyword">if</span>(<span class="keyword">number</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;
        <span class="built_in">int</span> temp1 = <span class="number">1</span>, temp2 = <span class="number">2</span>, ans = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= <span class="keyword">number</span>; i++)
        {
            ans = temp1 + temp2;
            temp1 = temp2;
            temp2 = ans;
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="House_Robber">House Robber</h3><h4 id="问题描述-1">问题描述</h4><p>强盗偷东西，不能连续抢两家，求最多可以打劫到的金钱数。</p>
<h4 id="解法-1">解法</h4><p>状态转移方程：</p>
<pre><code>dp[i] = max<span class="comment">(dp[i-1], dp[i-2]+num[i])</span>
</code></pre><p>表示当前位置最大的金钱数，等于i位置不打劫和i位置打劫的更大值。</p>
<h4 id="代码-1">代码</h4><p>递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//动态规划，状态转移方程：S(n)=max{S(n-1),S(n-2)+a[n]}</span>
<span class="comment">//直接使用递归超时，需要额外存储换时间</span>
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; res(<span class="built_in">num</span>.size(), -<span class="number">1</span>);
        <span class="keyword">return</span> S(<span class="built_in">num</span>.size() - <span class="number">1</span>, <span class="built_in">num</span>, res) ;
    }

    <span class="built_in">int</span> S(<span class="built_in">int</span> i, vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">num</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; res)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
            res[i] = <span class="built_in">num</span>[i];
        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)
            res[i] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
        <span class="keyword">else</span> <span class="keyword">if</span>(res[i] != -<span class="number">1</span>) 
            <span class="keyword">return</span> res[i];
        <span class="keyword">else</span>
        {
            <span class="built_in">int</span> S1=S(i-<span class="number">1</span>, <span class="built_in">num</span>, res);
            <span class="built_in">int</span> S2=S(i-<span class="number">2</span>, <span class="built_in">num</span>, res) + <span class="built_in">num</span>[i];
            res[i] = S1 &gt;= S2 ? S1 : S2;
        }
        <span class="keyword">return</span> res[i];
    }
};
</code></pre><p>非递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="built_in">int</span> n = <span class="built_in">num</span>.size();
        <span class="keyword">if</span>(n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)
            <span class="keyword">return</span> <span class="built_in">num</span>[<span class="number">0</span>];
        <span class="keyword">else</span>
        {
            vector&lt;<span class="built_in">int</span>&gt; maxV(n, <span class="number">0</span>);
            maxV[<span class="number">0</span>] = <span class="built_in">num</span>[<span class="number">0</span>];
            maxV[<span class="number">1</span>] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i ++)
                maxV[i] = max(maxV[i - <span class="number">2</span>] + <span class="built_in">num</span>[i], maxV[i - <span class="number">1</span>]);
            <span class="keyword">return</span> maxV[n - <span class="number">1</span>];
        }
    }
};
</code></pre><h3 id="House_Robber_II">House Robber II</h3><h4 id="题目描述">题目描述</h4><p>街道变成环，其他条件不变</p>
<h4 id="解法-2">解法</h4><p>res = max（抢第一家到倒数第二家， 抢第二家到最后一家）</p>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">int</span> rob(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">1</span>)
            <span class="keyword">return</span> nums[<span class="number">0</span>];
        <span class="keyword">return</span> <span class="keyword">max</span>(robber(nums, <span class="number">0</span>, nums.<span class="keyword">size</span>()-<span class="number">2</span>), robber(nums, <span class="number">1</span>, nums.<span class="keyword">size</span>()-<span class="number">1</span>));
    }

    <span class="keyword">int</span> robber(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)
    {
        <span class="keyword">int</span> temp1 = <span class="number">0</span>, temp2 = <span class="number">0</span>,res = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)
        {
            res = <span class="keyword">max</span>(temp1 + nums[i], temp2);
            temp1 = temp2;
            temp2 = res;
        }
        <span class="keyword">return</span> res;
    }
};
</code></pre><h3 id="最大连续子序列">最大连续子序列</h3><h4 id="最大连续子序列和">最大连续子序列和</h4><p>遍历如果currentSum&lt;0 丢弃前面的数，否则currentSum+=num[i]。记录max</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> greatest = <span class="built_in">array</span>[<span class="number">0</span>];
        <span class="keyword">int</span> currentSum = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
        {
            <span class="keyword">if</span>(currentSum &lt;= <span class="number">0</span>)
                currentSum = <span class="built_in">array</span>[i];
            <span class="keyword">else</span>
                currentSum += <span class="built_in">array</span>[i];

            <span class="keyword">if</span>(currentSum &gt; greatest)
                greatest = currentSum;
        }
        <span class="keyword">return</span> greatest;
    }
};
</code></pre><h4 id="最大连续子序列乘积">最大连续子序列乘积</h4><pre><code><span class="keyword">class</span> Solution {
//思路：动态规划，计算字数组和的时候sub[i+<span class="number">1</span>]=<span class="built_in">max</span>(sub[i]+A[i+<span class="number">1</span>],A[i+<span class="number">1</span>]),在计算子数组乘积的时候，
/*
<span class="built_in">max</span>[i]=<span class="built_in">max</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
<span class="built_in">min</span>[i]=<span class="built_in">min</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
*/
<span class="keyword">public</span>:
    <span class="built_in">int</span> maxProduct(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> maxcur,mincur;
        <span class="built_in">int</span> <span class="built_in">maxval</span> = nums[<span class="number">0</span>];
        <span class="built_in">int</span> minpre = nums[<span class="number">0</span>];
        <span class="built_in">int</span> maxpre = nums[<span class="number">0</span>];
        for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)
        {
            maxcur = <span class="built_in">max</span>(<span class="built_in">max</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            mincur = <span class="built_in">min</span>(<span class="built_in">min</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            <span class="built_in">maxval</span> = <span class="built_in">max</span>(<span class="built_in">maxval</span>, maxcur);
            minpre = mincur;
            maxpre = maxcur;
        }
        <span class="keyword">return</span> <span class="built_in">maxval</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-图遍历/">
                图，回溯，遍历
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-图遍历/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-图遍历/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer_66_矩阵中的路径">剑指offer 66 矩阵中的路径</h3><h4 id="问题描述">问题描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h4 id="解法">解法</h4><p>使用<code>vector&lt;vector&lt;bool&gt;&gt; visited</code>记录位置是否被访问过。每个节点指向周围四个点，从而形成一个有向图。然后使用递归进行有向图的深度优先遍历。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span>
    </span>{
        <span class="keyword">if</span>(matrix == NULL || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vec(cols, <span class="keyword">false</span>);
            visited.push_back(vec);
        }
        <span class="keyword">int</span> step = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)
            {
                <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, i, j, str, step, visited))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j,
                     <span class="keyword">char</span>* str, <span class="keyword">int</span> &amp;step, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;visited)</span>
    </span>{
        <span class="keyword">if</span>(str[step] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">bool</span> hasPath = <span class="keyword">false</span>;
        <span class="keyword">if</span>(i &gt;=<span class="number">0</span> &amp;&amp; i&lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp;
          matrix[i*cols + j] == str[step] &amp;&amp; !visited[i][j])
        {
            step++;
            visited[i][j] = <span class="keyword">true</span>;
            hasPath = hasPathCore(matrix, rows, cols, i-<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i+<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j-<span class="number">1</span>, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j+<span class="number">1</span>, str, step, visited);
            <span class="keyword">if</span>(!hasPath)
            {
                step--;
                visited[i][j] = <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> hasPath;          
    }
};
</code></pre><h3 id="剑指offer_67_机器人的运动范围">剑指offer 67 机器人的运动范围</h3><h4 id="问题描述-1">问题描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h4 id="解法-1">解法</h4><p>模拟，进行图的深度优先遍历，每走一步是否满足条件。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span>
    </span>{
        <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows*cols;i++)
            visited[i] = <span class="keyword">false</span>;
        <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);
        <span class="keyword">delete</span> [] visited;
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">if</span>(check(threshold, rows, cols, i, j, visited))
        {
            visited[i * cols + j] = <span class="keyword">true</span>;
            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, i-<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i+<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i, j-<span class="number">1</span>, visited)
                + movingCountCore(threshold, rows, cols, i, j+<span class="number">1</span>, visited);
        }
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp; !visited[i*cols + j]
          &amp;&amp; getDigitSum(i)+getDigitSum(j) &lt;= threshold
          )  
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span>
    </span>{
        <span class="keyword">int</span> sum = <span class="number">0</span>;
        <span class="keyword">while</span>(number)
        {
            sum += number%<span class="number">10</span>;
            number /= <span class="number">10</span>;
        }
        <span class="keyword">return</span> sum;
    }    
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/图/"> #图 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-递归专题/">
                递归
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-递归专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-递归专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer11_数值的整数次方">剑指offer11 数值的整数次方</h3><h4 id="问题描述">问题描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h4 id="解法">解法</h4><p>求a的b次方</p>
<ul>
<li>如果b是奇数，result=a*a^(b-1)</li>
<li>如果b是偶数，temp=a^(b/2),result=temp*temp</li>
</ul>
<p>避免多次乘法。</p>
<h4 id="注意点">注意点</h4><ul>
<li>判断输入数据是否合法，0的负数次方不合法，0的0次方返回1.0</li>
<li>浮点数相等的判断</li>
<li><p>负数次方转化为整数次方</p>
<h4 id="代码">代码</h4><p>  class Solution {<br>  public:</p>
<pre><code><span class="keyword">bool</span> invalidInput=<span class="keyword">false</span>;
<span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>) </span>{
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)
    {
        invalidInput = <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="number">0.0</span>;
    }
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1.0</span>;
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>,<span class="number">0.0</span>))
        <span class="keyword">return</span> <span class="number">0.0</span>;
    <span class="keyword">int</span> absExponent;
    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)
        absExponent =- exponent;
    <span class="keyword">else</span>
        absExponent = exponent;

    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, absExponent);
    <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)
        <span class="keyword">return</span> temp;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">1.0</span> / temp;
}

<span class="function"><span class="keyword">double</span> <span class="title">powerPositive</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exp</span>)
</span>{
    <span class="keyword">if</span>(exp == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">if</span>(exp == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">base</span>;
    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, exp &gt;&gt; <span class="number">1</span>);
    <span class="keyword">if</span>((exp&amp;<span class="number">1</span>) == <span class="number">1</span>)
        <span class="keyword">return</span> temp * temp * <span class="keyword">base</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> temp * temp;

}

<span class="function"><span class="keyword">bool</span> <span class="title">doubleEqual</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)
</span>{
    <span class="keyword">if</span>(a - b &gt; -<span class="number">0.0000001</span> &amp;&amp; a - b &lt; <span class="number">0.0000001</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>  };</p>
</li>
</ul>
<h3 id="全排列问题（剑指offer_28_字符串的全排列）">全排列问题（剑指offer 28 字符串的全排列）</h3><h4 id="问题描述-1">问题描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。</p>
<h4 id="解法-1">解法</h4><p>使用递归进行深度优先遍历，可以画出递归树，然后对这个树（图）进行深度优先遍历。递归函数表示当前位置的元素(index)和之后(包括自己)的元素进行交换。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>元素交换后还需要换回来</li>
<li>排列的序列中如果有重复元素需要判断。</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
  vector&lt;string&gt; Permutation(string <span class="keyword">str</span>) {
    vector&lt;string&gt; vec;
    <span class="keyword">if</span>(<span class="keyword">str</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> vec;
    PermutationR(<span class="keyword">str</span>,<span class="number">0</span>,vec);
    sort(vec.begin(),vec.end());
    <span class="keyword">return</span> vec;
  }

    <span class="keyword">void</span> PermutationR(string&amp; <span class="keyword">str</span>, <span class="keyword">int</span> <span class="keyword">index</span>, vector&lt;string&gt;&amp; vec)
    {
        <span class="keyword">if</span>(<span class="keyword">index</span> == <span class="keyword">str</span>.size() - <span class="number">1</span>)
            vec.push_back(<span class="keyword">str</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">index</span>; i &lt; <span class="keyword">str</span>.size(); i++)
        {
            <span class="keyword">if</span>(i != <span class="keyword">index</span> &amp;&amp; <span class="keyword">str</span>[<span class="keyword">index</span>] == <span class="keyword">str</span>[i]) 
                <span class="keyword">continue</span>;
            <span class="keyword">char</span> temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
            PermutationR(<span class="keyword">str</span>, <span class="keyword">index</span> + <span class="number">1</span>, vec); 
            temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
        }
    }
};
</code></pre><h3 id="剑指offer_53_正则表达式匹配">剑指offer 53 正则表达式匹配</h3><h4 id="问题描述-2">问题描述</h4><p>请实现一个函数用来匹配包括’.’和<code>&#39;*&#39;</code>的正则表达式。模式中的字符’.’表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和<code>&quot;ab*ac*a&quot;</code>匹配，但是与”aa.a”和<code>&quot;ab*a&quot;</code>均不匹配</p>
<h4 id="解法-2">解法</h4><p>考虑<code>bool match(char* str, char* pattern)</code><br>因为str中可能出现_*这种形式，所以每次需要扫描pattern的后一个元素。讨论以下几种情况：</p>
<ul>
<li><p><code>_*</code></p>
<ul>
<li><p>如果能匹配上 <code>*p == *str</code>或者 <code>*p == &#39;.&#39;</code></p>
<ul>
<li>next state -&gt; str+1, p+2</li>
<li>current state -&gt; str+1, p</li>
<li>ignore this -&gt; str p+2</li>
</ul>
</li>
<li><p>如果匹配不上 ignore this -&gt; str, p+2</p>
</li>
</ul>
</li>
<li><code>*str == *p</code> -&gt; str+1, p+1</li>
<li><code>*p == &#39;.&#39;</code> -&gt; str+1, p+1</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool match(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">char</span>* pattern)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || pattern == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, pattern);
    }
    bool matchCore(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">char</span> *p)
    {
        <span class="keyword">if</span>(*<span class="keyword">str</span>  == <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*(p+<span class="number">1</span>) == <span class="string">'*'</span>)
        {
            <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">2</span>) || matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p) || matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
            <span class="keyword">else</span>
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
        }
        <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
            <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">1</span>);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-常用函数专题/">
                常用函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-常用函数专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-常用函数专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="C语言常用库函数">C语言常用库函数</h2><p>需要引用断言函数库</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span>
</code></pre><h3 id="注意点">注意点</h3><ul>
<li>需要声明断言</li>
<li>字符串操作结尾需要’\0’</li>
<li>不改变的内容需要声明const</li>
<li>对于<code>void*</code>类型，使用<code>(char*)dst</code>按字节赋值</li>
</ul>
<h3 id="strlen">strlen</h3><pre><code>size_t strlen(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    size_t len = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> != <span class="string">'\0'</span>)
    {
        <span class="built_in">str</span>++;
        len++;
    }
    <span class="keyword">return</span> len;
}
</code></pre><h3 id="strcpy">strcpy</h3><pre><code><span class="keyword">char</span>* strcpy(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">char</span>* <span class="keyword">ret</span> = dst;
    <span class="keyword">while</span>(*src != '\0')
    {
<span class="comment">        *dst = *src;</span>
        dst++;
        src++;
    }
<span class="comment">    *dst = '\0';</span>
    <span class="keyword">return</span> <span class="keyword">ret</span>;
}
</code></pre><h3 id="memcpy">memcpy</h3><pre><code><span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, size_t <span class="built_in">size</span>)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="built_in">size</span>--)
    {
        *(<span class="built_in">char</span>*)dst = *(<span class="built_in">char</span>*)src;
        dst = (<span class="built_in">char</span>*)dst + <span class="number">1</span>;
        src = (<span class="built_in">char</span>*)src + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="memset">memset</h3><pre><code><span class="keyword">void</span>* memset(<span class="keyword">void</span>* dst, <span class="keyword">int</span> val, size_t <span class="keyword">size</span>)
{
    assert(dst != <span class="keyword">NULL</span>);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="keyword">size</span>--)
    {
        *(<span class="keyword">char</span>*)dst = val;
        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="strcmp">strcmp</h3><pre><code><span class="label">int</span> <span class="keyword">strcmp(const </span>char* <span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">assert</span>(<span class="keyword">str2 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&gt; *<span class="keyword">str2)
</span>            return <span class="number">1</span><span class="comment">;</span>
        <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&lt; <span class="keyword">str2)
</span>            return -<span class="number">1</span><span class="comment">;</span>
        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        return <span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
        return -<span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span>
        return <span class="number">0</span><span class="comment">;</span>
}
</code></pre><h3 id="strcat">strcat</h3><pre><code><span class="label">char</span>* <span class="keyword">strcat(char* </span><span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    char* ret = <span class="keyword">str1;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        <span class="keyword">str1++;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        *<span class="keyword">str1 </span>= *<span class="keyword">str2;
</span>        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    *<span class="keyword">str1 </span>= <span class="string">'\0'</span><span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><h2 id="atoi和itoa">atoi和itoa</h2><h3 id="atoi">atoi</h3><p>把字符串(<code>char*</code>或者<code>string</code>)转化为整数</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>删除字符串前面的空值</li>
<li>考虑字符传中可能出现的+,-</li>
<li>考虑溢出的情况</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="built_in">int</span> atoi(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    <span class="keyword">while</span>(*<span class="built_in">str</span> == <span class="string">' '</span>)
        <span class="built_in">str</span>++;
    bool isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'-'</span>)
    {
        isNeg = <span class="keyword">true</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'+'</span>)
        <span class="built_in">str</span>++;
    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> !=<span class="string">'\0'</span> &amp;&amp; *<span class="built_in">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="built_in">str</span> &lt;= <span class="string">'9'</span>)
    {
        num = num * <span class="number">10</span> + (*<span class="built_in">str</span> - <span class="string">'0'</span>);
        <span class="keyword">if</span>(isNeg &amp;&amp; -num &lt; INT_MIN)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(!isNeg &amp;&amp; num &gt; INT_MAX)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">return</span> -num;
    <span class="keyword">else</span>
        <span class="keyword">return</span> num;
}
</code></pre><h3 id="itoa">itoa</h3><h4 id="注意点-2">注意点</h4><ul>
<li>正负数</li>
<li>反转字符串</li>
<li>最后的’\0’</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">char</span>* itoa(<span class="keyword">int</span> num, <span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">bool</span> isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)
    {
        isNeg = <span class="keyword">true</span>;
        num = -num;
    }
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(num)
    {
        <span class="keyword">str</span>[i] = num % <span class="number">10</span>;
        num /= <span class="number">10</span>;
        i++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">str</span>[i++] = <span class="string">'-'</span>;
    <span class="keyword">for</span>(j = <span class="number">0</span>, k = i-<span class="number">1</span>; j &lt; k; j++, k--)
    {
        <span class="keyword">char</span> ch = <span class="keyword">str</span>[j];
        <span class="keyword">str</span>[j] = <span class="keyword">str</span>[k];
        <span class="keyword">str</span>[k] = ch;
    }
    <span class="keyword">str</span>[i] = <span class="string">'\0'</span>;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><h2 id="自己实现一个String">自己实现一个String</h2><h3 id="注意点-3">注意点</h3><ul>
<li>参数不修改使用const</li>
<li>构造函数<ul>
<li>为m_data申请空间，包括字符串结束符’\0’</li>
<li><code>const char* str</code>,判断传入<code>char* str</code>参数是否为空</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>复制一个对象，一定需要申请新的空间</li>
<li><code>strlen(other.m_data)</code>在类中获取m_data指针</li>
<li>使用字符串函数strcpy</li>
</ul>
</li>
<li>析构函数<ul>
<li><code>delete [] m_data;</code></li>
</ul>
</li>
<li>赋值函数<ul>
<li>判断this == &amp;rhs</li>
<li>先申请空间，再释放原空间，再赋值(避免申请失败造成不了后果)</li>
</ul>
</li>
<li>重载操作符<ul>
<li>考虑返回引用(operator=)or值(operator+)</li>
<li>一般单目运算符使用成员函数重载，双目运算符使用友元</li>
<li>MyString&amp; other参数是否和this相等</li>
<li>重载operator+,判断源字符串为空</li>
<li>重载operator==，使用strcmp</li>
</ul>
</li>
</ul>
<h3 id="代码-2">代码</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">class</span> MyString
{
<span class="keyword">public</span>:
    MyString();
    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str);
    MyString(<span class="keyword">const</span> MyString&amp; other);
    ~MyString();
    MyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs);
    MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index);
    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs);
<span class="keyword">private</span>:
    <span class="keyword">char</span>* m_data;
};

MyString::MyString()
{
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
    *m_data = <span class="string">'\0'</span>;
}

MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)
{
    <span class="keyword">if</span>(str == NULL)
    {
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
        *m_data = <span class="string">'\0'</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(m_data, str);
    }
}

MyString::MyString(<span class="keyword">const</span> MyString&amp; other)
{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
    <span class="built_in">strcpy</span>(m_data, other.m_data);
}

MyString::~MyString()
{
    <span class="keyword">delete</span> [] m_data;
}

MyString&amp; MyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)
    {
        <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(temp, rhs.m_data);
        <span class="keyword">delete</span> [] m_data;
        m_data = NULL;
        m_data = temp;
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}

MyString MyString::<span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs)
{
    MyString newStr;
    <span class="keyword">if</span>(rhs.m_data == NULL)
        newStr = *<span class="keyword">this</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(m_data == NULL)
        newStr = rhs;
    <span class="keyword">else</span>
    {
        newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(newStr.m_data, m_data);
        <span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);
    }
    <span class="keyword">return</span> newStr;
}

<span class="keyword">char</span> MyString::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index)
{
    <span class="keyword">return</span> m_data[index];
}

<span class="keyword">bool</span> MyString::<span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">int</span> result = <span class="built_in">strcmp</span>(m_data, rhs.m_data);
    <span class="keyword">return</span> (<span class="number">0</span> == result);
}

ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs)
{
    output &lt;&lt; rhs.m_data;
    <span class="keyword">return</span> output;
}
</code></pre><h2 id="Singleton">Singleton</h2><h3 id="简单写法">简单写法</h3><pre><code>class Singleton
{<span class="keyword">
public</span>:
   <span class="keyword"> static</span> Singleton*<span class="function"> getInstance(</span><span class="function">)</span>;
    virtual<span class="function"> ~Singleton(</span><span class="function">)</span>;<span class="keyword">
private</span>:
   <span class="function"> Singleton(</span><span class="function">)</span>;
   <span class="keyword"> static</span> Singleton *instance;
};

Singleton* Singleton::instance = NU<span class="class">LL;</span>//如果允许在这里直接new出来可以避免多线程的影响
Singleton::Singleton(<span class="function">)</span>{}
Singleton::~Singleton(<span class="function">)</span>
{
    delete instance;
   <span class="instruction"> instance </span>= NU<span class="class">LL;</span>
}

Singleton*<span class="function"> Singleton::getInstance(</span><span class="function">)</span>
{
   <span class="function"> if(</span>instance == NULL<span class="function">)</span>
    {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
    }
   <span class="instruction"> return </span>instance;
}
</code></pre><h3 id="模板+资源管理+线程安全">模板+资源管理+线程安全</h3><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Singleton</span>
{
private:
    <span class="type">Singleton</span>(){};
    <span class="keyword">static</span> auto_ptr&lt;T&gt; <span class="keyword">ptr</span>;
public:
    <span class="keyword">static</span> auto_ptr&lt;T&gt; getInstance()
    {
        <span class="type">Mutex</span> mutex;
        mutex.lock();
        <span class="keyword">if</span>(! <span class="keyword">ptr</span>.get())
        {
            auto_ptr&lt;T&gt; temp(new T);
            <span class="keyword">ptr</span> = temp;
        }
        <span class="keyword">return</span> <span class="keyword">ptr</span>;
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/常用函数/"> #常用函数 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-一般题目/">
                二叉树专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/">
                二叉树专题-二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-二叉查找树/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-基础/">
                二叉树专题-基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
