<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/12/找工作总结-面向对象和设计模式/">
                面向对象和设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/12/找工作总结-面向对象和设计模式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/12/找工作总结-面向对象和设计模式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="UML说明">UML说明</h2><p><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1ewxhltbbtdj20qy0d43zm.jpg" alt=""></p>
<h2 id="创建型模式">创建型模式</h2><h3 id="工厂模式-简单工厂">工厂模式-简单工厂</h3><p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewxia9uhulj20gr0emq3e.jpg" alt=""></p>
<h3 id="工厂模式-工厂方法模式">工厂模式-工厂方法模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewxite169fj20uo0c5q3p.jpg" alt=""></p>
<h3 id="工厂模式-抽象工厂">工厂模式-抽象工厂</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewxj6nh6fwj20v30h7dh0.jpg" alt=""></p>
<h3 id="Builder_模式，建造者模式">Builder 模式，建造者模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewy3ppzlfjj20uj0gbwfr.jpg" alt=""></p>
<h3 id="单例模式">单例模式</h3><p><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1ewy3ssxt7gj20bi04wglo.jpg" alt=""></p>
<h2 id="结构型模式">结构型模式</h2><h3 id="适配器模式">适配器模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy441hmlhj20hq0f3aar.jpg" alt=""></p>
<h3 id="桥接模式">桥接模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewy4lptm1aj20s00dymy3.jpg" alt=""></p>
<h3 id="外观模式">外观模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy53du88tj20ls0dq751.jpg" alt=""></p>
<h3 id="装饰者模式">装饰者模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewy96u7diej20tn0d30tq.jpg" alt=""></p>
<h3 id="代理模式">代理模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewy9f8gw9sj20nz0dhmy3.jpg" alt=""></p>
<h3 id="享元模式">享元模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewya256t6rj20mo0bxq42.jpg" alt=""></p>
<h2 id="行为模式">行为模式</h2><h3 id="命令模式">命令模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewyaqv6oo7j20nz0e8dgz.jpg" alt=""></p>
<h3 id="中介者模式">中介者模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewybdmdrynj20nw0czt9x.jpg" alt=""></p>
<h3 id="观察者模式">观察者模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewyc3lzfo9j20ur0at0tp.jpg" alt=""></p>
<h3 id="策略模式">策略模式</h3><p><img src="http://ww1.sinaimg.cn/large/4c2edcb7jw1ewyc8eguuij20ni0awmxu.jpg" alt=""></p>
<h3 id="状态模式">状态模式</h3><p><img src="http://ww4.sinaimg.cn/large/4c2edcb7jw1ewyjbaj60kj20my0b40th.jpg" alt=""></p>
<h3 id="责任链模式">责任链模式</h3><p><img src="http://ww2.sinaimg.cn/large/4c2edcb7jw1ewyjd2f4lhj20o50c7758.jpg" alt=""></p>
<h3 id="模板方法模式">模板方法模式</h3><p><img src="http://ww3.sinaimg.cn/large/4c2edcb7jw1ewyk470amyj20j80daab3.jpg" alt=""></p>
<p><a href="http://design-patterns.readthedocs.org/zh_CN/latest/creational_patterns/creational.html" target="_blank" rel="external">跟多关于设计模式的参考</a></p>
<h2 id="其他概念">其他概念</h2><h3 id="依赖注入-控制反转">依赖注入-控制反转</h3><p>依赖注入是实现控制反转最常用的一种方法。依赖注入可以看作是工厂模式的升华，生成的对象在配置文件（xml，json）中定义，使用反射生成相应的对象。</p>
<h3 id="继承，封装，多态">继承，封装，多态</h3><p>继承，抽象公共的部分，对现实世界的表述更加容易理解<br>封装，封装使得程序容易改变。<br>多态，统一接口，不同方法。</p>
<h3 id="重载和覆盖">重载和覆盖</h3><p>重载（overload）：对于类的方法（包括从父类中继承的方法），方法名相同，参数列表不同的方法之间就构成了重载关系。<br>覆盖 (override)：也叫重写，就是在当父类中的某些方法不能满足要求时，子类中改写父类的方法。当父类中的方法被覆盖了后，除非用super关键字，否则就无法再调用父类中的方法了。</p>
<h3 id="里氏替换原则">里氏替换原则</h3><p>里氏替换原则规定，<strong>所有的子类都能作为父类的代理(proxy)工作</strong>。例如，如果一个方法需要父类对象作为输入，那么如果你提供一个子类对象，它也应该正常工作。任何不能替代父类的类都违反了里氏替换原则。</p>
<h3 id="开闭(Open_closed)设计原则">开闭(Open closed)设计原则</h3><p>个系统对扩展是开放的，但对修改是封闭的。</p>
<h3 id="多态">多态</h3><p>一个接口，多种方法。使用父类对象(或指针)调用子类函数。</p>
<h2 id="小问题">小问题</h2><ul>
<li><p>组合(composition)，聚合(aggregation)和关联(association)的区别是什么？<br><strong>关联</strong>的意思是两个对象是相互联系的。组合和聚合是关联的两种方式。在代码中表现为成员变量。<br><strong>组合</strong>是关联的一种形式，即一个对象由多个对象组成，但是它们必须共存（<strong>生命周期相同</strong>），例如人体由各种器官组合而成，独立的器官不能生存，它们必须在身体内发挥作用。代码中表现为List&lt;&gt;。<br><strong>聚合</strong>也是关联的一种形式，表示对象的集合，例如城市是居民的聚合（<strong>声明周期不相同</strong>）。在代码中表现为List&lt;&gt;。</p>
</li>
<li><p>接口和抽象类有什么区别？<br>接口是最纯粹的抽象形式，只有操作，没有实现<br>抽象类是一些抽象和具体事物的组合体。</p>
</li>
</ul>
<h2 id="如何做设计">如何做设计</h2><h3 id="设计的共性">设计的共性</h3><p>拆，把复杂的问题变成简单的子问题，不断迭代<br>输入输出的把控<br>变化的预估</p>
<h3 id="设计的模式">设计的模式</h3><p>系统级：分层，服务化（把公共的部分做成服务）<br>模块级：线程角色（主线程，工作线程），线程模型，流水线<br>设计模式：解决特定问题的特定方法</p>
<h3 id="设计的过程">设计的过程</h3><p>定义问题，需求，系统边界<br>给出解决方案，尽可能多。在调研的阶段<strong>消灭变更</strong>。<br>选择解决方案</p>
<h3 id="设计的原则">设计的原则</h3><p>simple is best，没有最好的设计，只有最合适的设计</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/"> #设计模式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-动态规划专题/">
                动态规划
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-动态规划专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-动态规划专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>动态规划的关键是写出状态转移方程</p>
<h3 id="青蛙跳台阶_VS_斐波那契数列">青蛙跳台阶 VS 斐波那契数列</h3><h4 id="问题描述">问题描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="解法">解法</h4><p>状态转移方程：</p>
<pre><code><span class="tag">a</span>[n] = <span class="tag">a</span>[n-<span class="number">1</span>] + <span class="tag">a</span>[n-<span class="number">2</span>]
</code></pre><h4 id="代码">代码</h4><p>递归，使用vector存储每一步的结果，防止重复计算</p>
<pre><code><span class="keyword">class</span> Solution {
public:
    int jumpFloor(int number) {
        <span class="keyword">if</span>(number &lt;= 0) <span class="keyword">return</span> 0;
        vector&lt;int&gt; <span class="literal">vec</span>(number + 1, 0);
        <span class="keyword">count</span>(number, <span class="keyword">vec</span>);
        <span class="keyword">return</span> <span class="keyword">vec</span>[number];
    }
    int <span class="keyword">count</span>(int <span class="keyword">n</span>, vector&lt;int&gt;&amp; <span class="keyword">vec</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">n</span> == 0 || <span class="keyword">n</span> == 1 || <span class="keyword">n</span> == 2)
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">n</span>;
        <span class="keyword">if</span>(<span class="keyword">vec</span>[<span class="keyword">n</span>] != 0)
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        <span class="keyword">else</span>
        {
            <span class="keyword">vec</span>[<span class="keyword">n</span>] = <span class="keyword">count</span>(<span class="keyword">n</span> - 1, <span class="keyword">vec</span>) + <span class="keyword">count</span>(<span class="keyword">n</span> - 2, <span class="keyword">vec</span>);
            <span class="keyword">return</span> <span class="keyword">vec</span>[<span class="keyword">n</span>];
        }
    }
};
</code></pre><p>非递归：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> jumpFloor(<span class="built_in">int</span> <span class="keyword">number</span>) {
        <span class="keyword">if</span>(<span class="keyword">number</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;
        <span class="built_in">int</span> temp1 = <span class="number">1</span>, temp2 = <span class="number">2</span>, ans = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= <span class="keyword">number</span>; i++)
        {
            ans = temp1 + temp2;
            temp1 = temp2;
            temp2 = ans;
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="House_Robber">House Robber</h3><h4 id="问题描述-1">问题描述</h4><p>强盗偷东西，不能连续抢两家，求最多可以打劫到的金钱数。</p>
<h4 id="解法-1">解法</h4><p>状态转移方程：</p>
<pre><code>dp[i] = max<span class="comment">(dp[i-1], dp[i-2]+num[i])</span>
</code></pre><p>表示当前位置最大的金钱数，等于i位置不打劫和i位置打劫的更大值。</p>
<h4 id="代码-1">代码</h4><p>递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//动态规划，状态转移方程：S(n)=max{S(n-1),S(n-2)+a[n]}</span>
<span class="comment">//直接使用递归超时，需要额外存储换时间</span>
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; res(<span class="built_in">num</span>.size(), -<span class="number">1</span>);
        <span class="keyword">return</span> S(<span class="built_in">num</span>.size() - <span class="number">1</span>, <span class="built_in">num</span>, res) ;
    }

    <span class="built_in">int</span> S(<span class="built_in">int</span> i, vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">num</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; res)
    {
        <span class="keyword">if</span>(i == <span class="number">0</span>)
            res[i] = <span class="built_in">num</span>[i];
        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)
            res[i] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
        <span class="keyword">else</span> <span class="keyword">if</span>(res[i] != -<span class="number">1</span>) 
            <span class="keyword">return</span> res[i];
        <span class="keyword">else</span>
        {
            <span class="built_in">int</span> S1=S(i-<span class="number">1</span>, <span class="built_in">num</span>, res);
            <span class="built_in">int</span> S2=S(i-<span class="number">2</span>, <span class="built_in">num</span>, res) + <span class="built_in">num</span>[i];
            res[i] = S1 &gt;= S2 ? S1 : S2;
        }
        <span class="keyword">return</span> res[i];
    }
};
</code></pre><p>非递归解法：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    <span class="built_in">int</span> rob(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>) {
        <span class="built_in">int</span> n = <span class="built_in">num</span>.size();
        <span class="keyword">if</span>(n == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)
            <span class="keyword">return</span> <span class="built_in">num</span>[<span class="number">0</span>];
        <span class="keyword">else</span>
        {
            vector&lt;<span class="built_in">int</span>&gt; maxV(n, <span class="number">0</span>);
            maxV[<span class="number">0</span>] = <span class="built_in">num</span>[<span class="number">0</span>];
            maxV[<span class="number">1</span>] = max(<span class="built_in">num</span>[<span class="number">0</span>], <span class="built_in">num</span>[<span class="number">1</span>]);
            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; n; i ++)
                maxV[i] = max(maxV[i - <span class="number">2</span>] + <span class="built_in">num</span>[i], maxV[i - <span class="number">1</span>]);
            <span class="keyword">return</span> maxV[n - <span class="number">1</span>];
        }
    }
};
</code></pre><h3 id="House_Robber_II">House Robber II</h3><h4 id="题目描述">题目描述</h4><p>街道变成环，其他条件不变</p>
<h4 id="解法-2">解法</h4><p>res = max（抢第一家到倒数第二家， 抢第二家到最后一家）</p>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">int</span> rob(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(nums.<span class="keyword">size</span>() == <span class="number">1</span>)
            <span class="keyword">return</span> nums[<span class="number">0</span>];
        <span class="keyword">return</span> <span class="keyword">max</span>(robber(nums, <span class="number">0</span>, nums.<span class="keyword">size</span>()-<span class="number">2</span>), robber(nums, <span class="number">1</span>, nums.<span class="keyword">size</span>()-<span class="number">1</span>));
    }

    <span class="keyword">int</span> robber(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)
    {
        <span class="keyword">int</span> temp1 = <span class="number">0</span>, temp2 = <span class="number">0</span>,res = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)
        {
            res = <span class="keyword">max</span>(temp1 + nums[i], temp2);
            temp1 = temp2;
            temp2 = res;
        }
        <span class="keyword">return</span> res;
    }
};
</code></pre><h3 id="最大连续子序列">最大连续子序列</h3><h4 id="最大连续子序列和">最大连续子序列和</h4><p>遍历如果currentSum&lt;0 丢弃前面的数，否则currentSum+=num[i]。记录max</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> greatest = <span class="built_in">array</span>[<span class="number">0</span>];
        <span class="keyword">int</span> currentSum = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
        {
            <span class="keyword">if</span>(currentSum &lt;= <span class="number">0</span>)
                currentSum = <span class="built_in">array</span>[i];
            <span class="keyword">else</span>
                currentSum += <span class="built_in">array</span>[i];

            <span class="keyword">if</span>(currentSum &gt; greatest)
                greatest = currentSum;
        }
        <span class="keyword">return</span> greatest;
    }
};
</code></pre><h4 id="最大连续子序列乘积">最大连续子序列乘积</h4><pre><code><span class="keyword">class</span> Solution {
//思路：动态规划，计算字数组和的时候sub[i+<span class="number">1</span>]=<span class="built_in">max</span>(sub[i]+A[i+<span class="number">1</span>],A[i+<span class="number">1</span>]),在计算子数组乘积的时候，
/*
<span class="built_in">max</span>[i]=<span class="built_in">max</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
<span class="built_in">min</span>[i]=<span class="built_in">min</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i],nums[i])
*/
<span class="keyword">public</span>:
    <span class="built_in">int</span> maxProduct(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> maxcur,mincur;
        <span class="built_in">int</span> <span class="built_in">maxval</span> = nums[<span class="number">0</span>];
        <span class="built_in">int</span> minpre = nums[<span class="number">0</span>];
        <span class="built_in">int</span> maxpre = nums[<span class="number">0</span>];
        for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)
        {
            maxcur = <span class="built_in">max</span>(<span class="built_in">max</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            mincur = <span class="built_in">min</span>(<span class="built_in">min</span>(maxpre*nums[i],minpre*nums[i]),nums[i]);
            <span class="built_in">maxval</span> = <span class="built_in">max</span>(<span class="built_in">maxval</span>, maxcur);
            minpre = mincur;
            maxpre = maxcur;
        }
        <span class="keyword">return</span> <span class="built_in">maxval</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-图遍历/">
                图，回溯，遍历
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-图遍历/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-图遍历/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer_66_矩阵中的路径">剑指offer 66 矩阵中的路径</h3><h4 id="问题描述">问题描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h4 id="解法">解法</h4><p>使用<code>vector&lt;vector&lt;bool&gt;&gt; visited</code>记录位置是否被访问过。每个节点指向周围四个点，从而形成一个有向图。然后使用递归进行有向图的深度优先遍历。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span>
    </span>{
        <span class="keyword">if</span>(matrix == NULL || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vec(cols, <span class="keyword">false</span>);
            visited.push_back(vec);
        }
        <span class="keyword">int</span> step = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)
        {
            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)
            {
                <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, i, j, str, step, visited))
                    <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j,
                     <span class="keyword">char</span>* str, <span class="keyword">int</span> &amp;step, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;visited)</span>
    </span>{
        <span class="keyword">if</span>(str[step] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">bool</span> hasPath = <span class="keyword">false</span>;
        <span class="keyword">if</span>(i &gt;=<span class="number">0</span> &amp;&amp; i&lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp;
          matrix[i*cols + j] == str[step] &amp;&amp; !visited[i][j])
        {
            step++;
            visited[i][j] = <span class="keyword">true</span>;
            hasPath = hasPathCore(matrix, rows, cols, i-<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i+<span class="number">1</span>, j, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j-<span class="number">1</span>, str, step, visited) ||
                hasPathCore(matrix, rows, cols, i, j+<span class="number">1</span>, str, step, visited);
            <span class="keyword">if</span>(!hasPath)
            {
                step--;
                visited[i][j] = <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> hasPath;          
    }
};
</code></pre><h3 id="剑指offer_67_机器人的运动范围">剑指offer 67 机器人的运动范围</h3><h4 id="问题描述-1">问题描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h4 id="解法-1">解法</h4><p>模拟，进行图的深度优先遍历，每走一步是否满足条件。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span>
    </span>{
        <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows*cols;i++)
            visited[i] = <span class="keyword">false</span>;
        <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);
        <span class="keyword">delete</span> [] visited;
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">int</span> count = <span class="number">0</span>;
        <span class="keyword">if</span>(check(threshold, rows, cols, i, j, visited))
        {
            visited[i * cols + j] = <span class="keyword">true</span>;
            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, i-<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i+<span class="number">1</span>, j, visited)
                + movingCountCore(threshold, rows, cols, i, j-<span class="number">1</span>, visited)
                + movingCountCore(threshold, rows, cols, i, j+<span class="number">1</span>, visited);
        }
        <span class="keyword">return</span> count;
    }

    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* visited)</span>
    </span>{
        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp; !visited[i*cols + j]
          &amp;&amp; getDigitSum(i)+getDigitSum(j) &lt;= threshold
          )  
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span>
    </span>{
        <span class="keyword">int</span> sum = <span class="number">0</span>;
        <span class="keyword">while</span>(number)
        {
            sum += number%<span class="number">10</span>;
            number /= <span class="number">10</span>;
        }
        <span class="keyword">return</span> sum;
    }    
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/图/"> #图 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-递归专题/">
                递归
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-递归专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-递归专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer11_数值的整数次方">剑指offer11 数值的整数次方</h3><h4 id="问题描述">问题描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h4 id="解法">解法</h4><p>求a的b次方</p>
<ul>
<li>如果b是奇数，result=a*a^(b-1)</li>
<li>如果b是偶数，temp=a^(b/2),result=temp*temp</li>
</ul>
<p>避免多次乘法。</p>
<h4 id="注意点">注意点</h4><ul>
<li>判断输入数据是否合法，0的负数次方不合法，0的0次方返回1.0</li>
<li>浮点数相等的判断</li>
<li><p>负数次方转化为整数次方</p>
<h4 id="代码">代码</h4><p>  class Solution {<br>  public:</p>
<pre><code><span class="keyword">bool</span> invalidInput=<span class="keyword">false</span>;
<span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>) </span>{
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)
    {
        invalidInput = <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="number">0.0</span>;
    }
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1.0</span>;
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>,<span class="number">0.0</span>))
        <span class="keyword">return</span> <span class="number">0.0</span>;
    <span class="keyword">int</span> absExponent;
    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)
        absExponent =- exponent;
    <span class="keyword">else</span>
        absExponent = exponent;

    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, absExponent);
    <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)
        <span class="keyword">return</span> temp;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">1.0</span> / temp;
}

<span class="function"><span class="keyword">double</span> <span class="title">powerPositive</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exp</span>)
</span>{
    <span class="keyword">if</span>(exp == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">if</span>(exp == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">base</span>;
    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, exp &gt;&gt; <span class="number">1</span>);
    <span class="keyword">if</span>((exp&amp;<span class="number">1</span>) == <span class="number">1</span>)
        <span class="keyword">return</span> temp * temp * <span class="keyword">base</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> temp * temp;

}

<span class="function"><span class="keyword">bool</span> <span class="title">doubleEqual</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)
</span>{
    <span class="keyword">if</span>(a - b &gt; -<span class="number">0.0000001</span> &amp;&amp; a - b &lt; <span class="number">0.0000001</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>  };</p>
</li>
</ul>
<h3 id="全排列问题（剑指offer_28_字符串的全排列）">全排列问题（剑指offer 28 字符串的全排列）</h3><h4 id="问题描述-1">问题描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。</p>
<h4 id="解法-1">解法</h4><p>使用递归进行深度优先遍历，可以画出递归树，然后对这个树（图）进行深度优先遍历。递归函数表示当前位置的元素(index)和之后(包括自己)的元素进行交换。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>元素交换后还需要换回来</li>
<li>排列的序列中如果有重复元素需要判断。</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
  vector&lt;string&gt; Permutation(string <span class="keyword">str</span>) {
    vector&lt;string&gt; vec;
    <span class="keyword">if</span>(<span class="keyword">str</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> vec;
    PermutationR(<span class="keyword">str</span>,<span class="number">0</span>,vec);
    sort(vec.begin(),vec.end());
    <span class="keyword">return</span> vec;
  }

    <span class="keyword">void</span> PermutationR(string&amp; <span class="keyword">str</span>, <span class="keyword">int</span> <span class="keyword">index</span>, vector&lt;string&gt;&amp; vec)
    {
        <span class="keyword">if</span>(<span class="keyword">index</span> == <span class="keyword">str</span>.size() - <span class="number">1</span>)
            vec.push_back(<span class="keyword">str</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">index</span>; i &lt; <span class="keyword">str</span>.size(); i++)
        {
            <span class="keyword">if</span>(i != <span class="keyword">index</span> &amp;&amp; <span class="keyword">str</span>[<span class="keyword">index</span>] == <span class="keyword">str</span>[i]) 
                <span class="keyword">continue</span>;
            <span class="keyword">char</span> temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
            PermutationR(<span class="keyword">str</span>, <span class="keyword">index</span> + <span class="number">1</span>, vec); 
            temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
        }
    }
};
</code></pre><h2 id="子集问题">子集问题</h2><h3 id="Leetcode_78_Subset">Leetcode 78 Subset</h3><h4 id="问题描述-2">问题描述</h4><p>给定一个集合，生成这个集合的所有子集</p>
<h4 id="解法-2">解法</h4><p>遍历数组中的元素，每个元素有出现和不出现两种情况，然后递归考虑后一个元素。</p>
<h4 id="代码-2">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; subsets(vector&lt;<span class="type">int</span>&gt;&amp; nums) {
        sort(nums.begin(), nums.<span class="keyword">end</span>());
        vector&lt;<span class="type">int</span>&gt; vec;
        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
        genSubset(vec, <span class="literal">result</span>, <span class="number">0</span>, nums);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    <span class="type">void</span> genSubset(vector&lt;<span class="type">int</span>&gt;&amp; vec, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; <span class="literal">result</span>, <span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt; nums)
    {
        <span class="literal">result</span>.push_back(vec);
        <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; nums.size(); i++)
        {
            vec.push_back(nums[i]);
            genSubset(vec, <span class="literal">result</span>, i + <span class="number">1</span>, nums);
            vec.pop_back();
        }
    }
};
</code></pre><h3 id="拓展：子集和问题">拓展：子集和问题</h3><h4 id="问题描述-3">问题描述</h4><p>子集和问题的一个实例为〈S,t〉。其中，S={ 1 x ， 2 x ，…， n x }是一个正整数的集合，c是一个正整数。子集和问题判定是否存在S的一个子集S1，使得 S1中的所有元素之和等于c。<br>试设计一个解子集和问题的回溯法。</p>
<h4 id="解法-3">解法</h4><p>使用暴力解法，任何一个数字在最终的结果中都有出现和不出现两种情况所以复杂度是(2^n)方，需要在不断遍历结果过程中对结果进行剪枝。<br>可以构造所有子集，每次进入的时候判断是否满足条件。</p>
<h3 id="剑指offer_53_正则表达式匹配">剑指offer 53 正则表达式匹配</h3><h4 id="问题描述-4">问题描述</h4><p>请实现一个函数用来匹配包括’.’和<code>&#39;*&#39;</code>的正则表达式。模式中的字符’.’表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和<code>&quot;ab*ac*a&quot;</code>匹配，但是与”aa.a”和<code>&quot;ab*a&quot;</code>均不匹配</p>
<h4 id="解法-4">解法</h4><p>考虑<code>bool match(char* str, char* pattern)</code><br>因为str中可能出现_*这种形式，所以每次需要扫描pattern的后一个元素。讨论以下几种情况：</p>
<ul>
<li><p><code>_*</code></p>
<ul>
<li><p>如果能匹配上 <code>*p == *str</code>或者 <code>*p == &#39;.&#39;</code></p>
<ul>
<li>next state -&gt; str+1, p+2</li>
<li>current state -&gt; str+1, p</li>
<li>ignore this -&gt; str p+2</li>
</ul>
</li>
<li><p>如果匹配不上 ignore this -&gt; str, p+2</p>
</li>
</ul>
</li>
<li><code>*str == *p</code> -&gt; str+1, p+1</li>
<li><code>*p == &#39;.&#39;</code> -&gt; str+1, p+1</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool match(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">char</span>* pattern)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || pattern == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, pattern);
    }
    bool matchCore(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">char</span> *p)
    {
        <span class="keyword">if</span>(*<span class="keyword">str</span>  == <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*(p+<span class="number">1</span>) == <span class="string">'*'</span>)
        {
            <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">2</span>) || matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p) || matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
            <span class="keyword">else</span>
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
        }
        <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
            <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">1</span>);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-常用函数专题/">
                常用函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-常用函数专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-常用函数专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="C语言常用库函数">C语言常用库函数</h2><p>需要引用断言函数库</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span>
</code></pre><h3 id="注意点">注意点</h3><ul>
<li>需要声明断言</li>
<li>字符串操作结尾需要’\0’</li>
<li>不改变的内容需要声明const</li>
<li>对于<code>void*</code>类型，使用<code>(char*)dst</code>按字节赋值</li>
</ul>
<h3 id="strlen">strlen</h3><pre><code>size_t strlen(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    size_t len = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> != <span class="string">'\0'</span>)
    {
        <span class="built_in">str</span>++;
        len++;
    }
    <span class="keyword">return</span> len;
}
</code></pre><h3 id="strcpy">strcpy</h3><pre><code><span class="keyword">char</span>* strcpy(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">char</span>* <span class="keyword">ret</span> = dst;
    <span class="keyword">while</span>(*src != '\0')
    {
<span class="comment">        *dst = *src;</span>
        dst++;
        src++;
    }
<span class="comment">    *dst = '\0';</span>
    <span class="keyword">return</span> <span class="keyword">ret</span>;
}
</code></pre><h3 id="memcpy">memcpy</h3><pre><code><span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, size_t <span class="built_in">size</span>)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="built_in">size</span>--)
    {
        *(<span class="built_in">char</span>*)dst = *(<span class="built_in">char</span>*)src;
        dst = (<span class="built_in">char</span>*)dst + <span class="number">1</span>;
        src = (<span class="built_in">char</span>*)src + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="memset">memset</h3><pre><code><span class="keyword">void</span>* memset(<span class="keyword">void</span>* dst, <span class="keyword">int</span> val, size_t <span class="keyword">size</span>)
{
    assert(dst != <span class="keyword">NULL</span>);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="keyword">size</span>--)
    {
        *(<span class="keyword">char</span>*)dst = val;
        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="strcmp">strcmp</h3><pre><code><span class="label">int</span> <span class="keyword">strcmp(const </span>char* <span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">assert</span>(<span class="keyword">str2 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&gt; *<span class="keyword">str2)
</span>            return <span class="number">1</span><span class="comment">;</span>
        <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&lt; <span class="keyword">str2)
</span>            return -<span class="number">1</span><span class="comment">;</span>
        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        return <span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
        return -<span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span>
        return <span class="number">0</span><span class="comment">;</span>
}
</code></pre><h3 id="strcat">strcat</h3><pre><code><span class="label">char</span>* <span class="keyword">strcat(char* </span><span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    char* ret = <span class="keyword">str1;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        <span class="keyword">str1++;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        *<span class="keyword">str1 </span>= *<span class="keyword">str2;
</span>        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    *<span class="keyword">str1 </span>= <span class="string">'\0'</span><span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><h2 id="atoi和itoa">atoi和itoa</h2><h3 id="atoi">atoi</h3><p>把字符串(<code>char*</code>或者<code>string</code>)转化为整数</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>删除字符串前面的空值</li>
<li>考虑字符传中可能出现的+,-</li>
<li>考虑溢出的情况</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="built_in">int</span> atoi(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    <span class="keyword">while</span>(*<span class="built_in">str</span> == <span class="string">' '</span>)
        <span class="built_in">str</span>++;
    bool isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'-'</span>)
    {
        isNeg = <span class="keyword">true</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'+'</span>)
        <span class="built_in">str</span>++;
    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> !=<span class="string">'\0'</span> &amp;&amp; *<span class="built_in">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="built_in">str</span> &lt;= <span class="string">'9'</span>)
    {
        num = num * <span class="number">10</span> + (*<span class="built_in">str</span> - <span class="string">'0'</span>);
        <span class="keyword">if</span>(isNeg &amp;&amp; -num &lt; INT_MIN)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(!isNeg &amp;&amp; num &gt; INT_MAX)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">return</span> -num;
    <span class="keyword">else</span>
        <span class="keyword">return</span> num;
}
</code></pre><h3 id="itoa">itoa</h3><h4 id="注意点-2">注意点</h4><ul>
<li>正负数</li>
<li>反转字符串</li>
<li>最后的’\0’</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">char</span>* itoa(<span class="keyword">int</span> num, <span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">bool</span> isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)
    {
        isNeg = <span class="keyword">true</span>;
        num = -num;
    }
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(num)
    {
        <span class="keyword">str</span>[i] = num % <span class="number">10</span>;
        num /= <span class="number">10</span>;
        i++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">str</span>[i++] = <span class="string">'-'</span>;
    <span class="keyword">for</span>(j = <span class="number">0</span>, k = i-<span class="number">1</span>; j &lt; k; j++, k--)
    {
        <span class="keyword">char</span> ch = <span class="keyword">str</span>[j];
        <span class="keyword">str</span>[j] = <span class="keyword">str</span>[k];
        <span class="keyword">str</span>[k] = ch;
    }
    <span class="keyword">str</span>[i] = <span class="string">'\0'</span>;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><h2 id="自己实现一个String">自己实现一个String</h2><h3 id="注意点-3">注意点</h3><ul>
<li>参数不修改使用const</li>
<li>构造函数<ul>
<li>为m_data申请空间，包括字符串结束符’\0’</li>
<li><code>const char* str</code>,判断传入<code>char* str</code>参数是否为空</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>复制一个对象，一定需要申请新的空间</li>
<li><code>strlen(other.m_data)</code>在类中获取m_data指针</li>
<li>使用字符串函数strcpy</li>
</ul>
</li>
<li>析构函数<ul>
<li><code>delete [] m_data;</code></li>
</ul>
</li>
<li>赋值函数<ul>
<li>判断this == &amp;rhs</li>
<li>先申请空间，再释放原空间，再赋值(避免申请失败造成不了后果)</li>
</ul>
</li>
<li>重载操作符<ul>
<li>考虑返回引用(operator=)or值(operator+)</li>
<li>一般单目运算符使用成员函数重载，双目运算符使用友元</li>
<li>MyString&amp; other参数是否和this相等</li>
<li>重载operator+,判断源字符串为空</li>
<li>重载operator==，使用strcmp</li>
</ul>
</li>
</ul>
<h3 id="代码-2">代码</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">class</span> MyString
{
<span class="keyword">public</span>:
    MyString();
    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str);
    MyString(<span class="keyword">const</span> MyString&amp; other);
    ~MyString();
    MyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs);
    MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index);
    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs);
<span class="keyword">private</span>:
    <span class="keyword">char</span>* m_data;
};

MyString::MyString()
{
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
    *m_data = <span class="string">'\0'</span>;
}

MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)
{
    <span class="keyword">if</span>(str == NULL)
    {
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
        *m_data = <span class="string">'\0'</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(m_data, str);
    }
}

MyString::MyString(<span class="keyword">const</span> MyString&amp; other)
{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
    <span class="built_in">strcpy</span>(m_data, other.m_data);
}

MyString::~MyString()
{
    <span class="keyword">delete</span> [] m_data;
}

MyString&amp; MyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)
    {
        <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(temp, rhs.m_data);
        <span class="keyword">delete</span> [] m_data;
        m_data = NULL;
        m_data = temp;
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}

MyString MyString::<span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs)
{
    MyString newStr;
    <span class="keyword">if</span>(rhs.m_data == NULL)
        newStr = *<span class="keyword">this</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(m_data == NULL)
        newStr = rhs;
    <span class="keyword">else</span>
    {
        newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(newStr.m_data, m_data);
        <span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);
    }
    <span class="keyword">return</span> newStr;
}

<span class="keyword">char</span> MyString::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index)
{
    <span class="keyword">return</span> m_data[index];
}

<span class="keyword">bool</span> MyString::<span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">int</span> result = <span class="built_in">strcmp</span>(m_data, rhs.m_data);
    <span class="keyword">return</span> (<span class="number">0</span> == result);
}

ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs)
{
    output &lt;&lt; rhs.m_data;
    <span class="keyword">return</span> output;
}
</code></pre><h2 id="Singleton">Singleton</h2><h3 id="简单写法">简单写法</h3><pre><code>class Singleton
{<span class="keyword">
public</span>:
   <span class="keyword"> static</span> Singleton*<span class="function"> getInstance(</span><span class="function">)</span>;
    virtual<span class="function"> ~Singleton(</span><span class="function">)</span>;<span class="keyword">
private</span>:
   <span class="function"> Singleton(</span><span class="function">)</span>;
   <span class="keyword"> static</span> Singleton *instance;
};

Singleton* Singleton::instance = NU<span class="class">LL;</span>//如果允许在这里直接new出来可以避免多线程的影响
Singleton::Singleton(<span class="function">)</span>{}
Singleton::~Singleton(<span class="function">)</span>
{
    delete instance;
   <span class="instruction"> instance </span>= NU<span class="class">LL;</span>
}

Singleton*<span class="function"> Singleton::getInstance(</span><span class="function">)</span>
{
   <span class="function"> if(</span>instance == NULL<span class="function">)</span>
    {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
    }
   <span class="instruction"> return </span>instance;
}
</code></pre><h3 id="模板+资源管理+线程安全">模板+资源管理+线程安全</h3><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Singleton</span>
{
private:
    <span class="type">Singleton</span>(){};
    <span class="keyword">static</span> auto_ptr&lt;T&gt; <span class="keyword">ptr</span>;
public:
    <span class="keyword">static</span> auto_ptr&lt;T&gt; getInstance()
    {
        <span class="type">Mutex</span> mutex;
        mutex.lock();
        <span class="keyword">if</span>(! <span class="keyword">ptr</span>.get())
        {
            auto_ptr&lt;T&gt; temp(new T);
            <span class="keyword">ptr</span> = temp;
        }
        <span class="keyword">return</span> <span class="keyword">ptr</span>;
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/常用函数/"> #常用函数 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-一般题目/">
                二叉树专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/">
                二叉树专题-二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-二叉查找树/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-基础/">
                二叉树专题-基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/04/找工作总结-链表专题/">
                链表专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/04/找工作总结-链表专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/04/找工作总结-链表专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="keyword">next</span>;
    ListNode(<span class="keyword">int</span> x):val(x),<span class="keyword">next</span>(<span class="keyword">NULL</span>){}
};
</code></pre><h3 id="求链表中节点个数">求链表中节点个数</h3><pre><code><span class="keyword">int</span> getLength(ListNode* head)
{
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">while</span>(head)
    {
        head = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">count</span>++;
    }
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><h3 id="单链表翻转">单链表翻转</h3><pre><code><span class="constant">ListNode*</span> reverseList(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> newHead = <span class="constant">NULL;</span>
    <span class="constant">ListNode*</span> node = head;
    <span class="keyword">while</span>(node)
    {
        <span class="constant">ListNode*</span> temp = node-&gt;<span class="keyword">next</span>;
        node-&gt;<span class="keyword">next</span> = newHead;
        newHead = node;
        node = temp-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中倒数第k个节点">查找链表中倒数第k个节点</h3><pre><code>ListNode* getLastK(ListNode* head, <span class="built_in">int</span> k)
{
    ListNode* fisrt = head;
    ListNode* <span class="built_in">second</span> = head;
    <span class="keyword">while</span>(k--)
    {
        <span class="keyword">if</span>(first)
            first = first-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            return <span class="literal">NULL</span>;
    }
    <span class="keyword">while</span>(first)
    {
        fisrt = first-&gt;<span class="keyword">next</span>;
        <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>;
    }
    return <span class="built_in">second</span>;
}
</code></pre><h3 id="删除链表中第k个节点">删除链表中第k个节点</h3><pre><code>ListNode* deleteK(ListNode* head, <span class="keyword">int</span> k)
{
    <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)
        <span class="keyword">return</span> head;
    ListNode* toBeDelete;
    ListNode* newHead;
    <span class="keyword">if</span>(k == <span class="number">1</span>)
    {
        toBeDelete = head;
        newHead = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">delete</span> toBeDelete;
        <span class="keyword">return</span> newHead;
    }
    newHead = head;
    ListNode* node = head;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">2</span>; i++)
    {
        <span class="keyword">if</span>(node)
            node = node-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> newHead;
    }
    <span class="keyword">if</span>(node == <span class="keyword">NULL</span> || node-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)
        <span class="keyword">return</span> newHead;
    toBeDelete = node-&gt;<span class="keyword">next</span>;
    node-&gt;<span class="keyword">next</span> = node-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    <span class="keyword">delete</span> toBeDelete;
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中间节点">查找链表中间节点</h3><pre><code><span class="constant">ListNode*</span> findMiddle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> first = head;
    <span class="constant">ListNode*</span> second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = fisrt-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        if(first)
            second = second-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> second;
}
</code></pre><h3 id="从尾到头打印链表">从尾到头打印链表</h3><pre><code>void reversePrint(<span class="type">ListNode</span>* head)
{
    <span class="type">ListNode</span>* node = head;
    stack&lt;<span class="type">ListNode</span>*&gt; s;
    <span class="keyword">while</span>(node)
    {
        s.push(node);
        node = node-&gt;next;
    }
    <span class="keyword">while</span>(!s.empty<span class="literal">()</span>)
    {
        cout&lt;&lt;s.top<span class="literal">()</span>-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">" "</span>;
        s.pop<span class="literal">()</span>;
    }
}
</code></pre><h3 id="单链表排序，选择排序">单链表排序，选择排序</h3><pre><code>void sortList(<span class="type">ListNode</span>* head)
{
    <span class="keyword">for</span>(<span class="type">ListNode</span>* p = head; p != <span class="type">NULL</span>; p = p-&gt;next)
    {
        <span class="type">ListNode</span>* min = p;
        <span class="keyword">for</span>(<span class="type">ListNode</span>* q = p-&gt;next; q != <span class="type">NULL</span>; q = q-&gt;next)
        {
            <span class="keyword">if</span>(q-&gt;<span class="keyword">val</span> &lt; min-&gt;<span class="keyword">val</span>)
                min = q;
        }
        <span class="built_in">int</span> temp = p-&gt;<span class="keyword">val</span>;
        p-&gt;<span class="keyword">val</span> = min-&gt;<span class="keyword">val</span>;
        min-&gt;<span class="keyword">val</span> = temp;
    }
}
</code></pre><h3 id="合并两个有序链表">合并两个有序链表</h3><pre><code>ListNode<span class="subst">*</span> mergeList(ListNode<span class="subst">*</span> list1, ListNode<span class="subst">*</span> list2)
{
    <span class="keyword">if</span>(list1 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list2;
    <span class="keyword">if</span>(list2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list1;
    ListNode<span class="subst">*</span> head <span class="subst">=</span> <span class="built_in">NULL</span>;
    ListNode <span class="subst">*</span>node1 <span class="subst">=</span> list1, <span class="subst">*</span>node2 <span class="subst">=</span> list2;
    ListNode <span class="subst">*</span>tnode <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
    {
        head <span class="subst">=</span> node1;
        node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
    }
    <span class="keyword">else</span>
    {
        head <span class="subst">=</span> node2;
        node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
    }
    tnode <span class="subst">=</span> head;
    tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">while</span>(node1 <span class="subst">&amp;&amp;</span> node2)
    {
        <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
            node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
        <span class="keyword">else</span>
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
            node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
    }
    <span class="keyword">if</span>(node1)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
    <span class="keyword">if</span>(node2)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
    <span class="keyword">return</span> head;
}
</code></pre><h3 id="判断一个链表是否有环">判断一个链表是否有环</h3><pre><code>bool hasCircle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode </span>*first = head, *second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = first-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        second = second-&gt;<span class="keyword">next</span>;
        if(first == second)
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="判断两个链表是否相交">判断两个链表是否相交</h3><pre><code>bool isJoin(<span class="constant">ListNode </span>*list1, <span class="constant">ListNode </span>*list2)
{
    if(list1 == <span class="constant">NULL </span>|| list2 == <span class="constant">NULL)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="constant">ListNode </span>*n1 = list1, *n2 = list2;
    <span class="keyword">while</span>(n1-&gt;<span class="keyword">next</span>)
        n1 = n1-&gt;<span class="keyword">next</span>;
    <span class="keyword">while</span>(n2-&gt;<span class="keyword">next</span>)
        n2 = n2-&gt;<span class="keyword">next</span>;
    <span class="keyword">return</span> (n1 == n2);
}
</code></pre><h3 id="判断两个链表相交的第一个节点">判断两个链表相交的第一个节点</h3><ol>
<li>判断两个链表是否相交，得到两个链表长度len1,len2</li>
<li>假设len1 &gt; len2，n1先走(len1-len2)步</li>
<li>n1,n2一起走，直到n1 == n2</li>
</ol>
<h3 id="如果一个链表有环，求进入环中的第一个节点">如果一个链表有环，求进入环中的第一个节点</h3><ol>
<li>使用上面的方法判断是否有环</li>
<li>在环中走一圈得到环的长度len</li>
<li>前后两个节点一个先走len步（走一个环的长度），两个一起走相遇在环的入口</li>
</ol>
<h3 id="在O(1)的时间内删除节点">在O(1)的时间内删除节点</h3><pre><code><span class="literal">void</span> deleteInO1(ListNode<span class="subst">*</span> <span class="built_in">list</span>, ListNode<span class="subst">*</span> toBeDelete)
{
    <span class="keyword">if</span>(<span class="built_in">list</span> <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> toBeDelete <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="keyword">if</span>(toBeDelete <span class="subst">==</span> <span class="built_in">list</span>)
    {
        <span class="built_in">list</span> <span class="subst">=</span> <span class="built_in">list</span><span class="subst">-&gt;</span>next;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    <span class="keyword">if</span>(toBeDelete<span class="subst">-&gt;</span>next <span class="subst">==</span> <span class="built_in">NULL</span>)
    {
        ListNode<span class="subst">*</span> node <span class="subst">=</span> <span class="built_in">list</span>;
        <span class="keyword">while</span>(node <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>next <span class="subst">!=</span> toBeDelete)
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>next;
        node<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    ListNode<span class="subst">*</span> temp <span class="subst">=</span> toBeDelete<span class="subst">-&gt;</span>next;
    toBeDelete<span class="subst">-&gt;</span>val <span class="subst">=</span> temp<span class="subst">-&gt;</span>val;
    toBeDelete<span class="subst">-&gt;</span>next <span class="subst">=</span> temp<span class="subst">-&gt;</span>next;
    delete temp;
    <span class="keyword">return</span> ;
}
</code></pre><h2 id="特殊题目">特殊题目</h2><h3 id="剑指offer57_删除链表中的重复节点">剑指offer57 删除链表中的重复节点</h3><h4 id="问题描述">问题描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法">解法</h4><p>使用preNode和node指向最后一个未删除的节点和第一个可能删除的节点</p>
<ul>
<li>如果保留重复元素的第一个<br>只需要使用node扫描一次，判断和preNode-&gt;val是否相等，分两种情况处理即可</li>
<li>如果不保留重复元素<br>需要确定新的头元素newHead,需要判断是否重复，因为需要全部删除。</li>
</ul>
<h4 id="类型1的代码">类型1的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode *deleteDuplicates(ListNode *head) {
        <span class="keyword">if</span>(<span class="keyword">NULL</span> == head || <span class="keyword">NULL</span>==head-&gt;next)
            <span class="keyword">return</span> head;
        ListNode *preNode = head;
        ListNode *node = preNode-&gt;next;
        <span class="keyword">while</span>(node)
        {
            <span class="keyword">if</span>(node-&gt;val == preNode-&gt;val)
            {
                ListNode* temp = node;
                node = node-&gt;next;
                preNode-&gt;next = node;
                delete temp;
            }
            <span class="keyword">else</span>
            {
                node = node-&gt;next;
                preNode = preNode-&gt;next;
            }
        }
        <span class="keyword">return</span> head;
    }
};
</code></pre><h4 id="类型2的代码">类型2的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> head;
        ListNode *node = head;
        ListNode *newHead = <span class="keyword">NULL</span>;
        ListNode *preNode = <span class="keyword">NULL</span>;
        <span class="keyword">while</span>(node)
        {
            bool isDuplicated = <span class="keyword">false</span>;
            <span class="keyword">if</span>(node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)
                isDuplicated = <span class="keyword">true</span>;
            <span class="keyword">if</span>(isDuplicated)
            {
                int val = node-&gt;val;
                <span class="keyword">while</span>(node!= <span class="keyword">NULL</span> &amp;&amp; node-&gt;val == val)
                {
                    ListNode *temp = node;
                    node = node-&gt;next;
                    delete temp;
                }
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(!newHead)
                {
                    newHead = node;
                    preNode = node;
                }
                <span class="keyword">else</span>
                {
                    preNode-&gt;next = node;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
        }
        <span class="keyword">if</span>(preNode)
            preNode-&gt;next = <span class="keyword">NULL</span>;
        <span class="keyword">return</span> newHead;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/链表/"> #链表 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/03/找工作总结-栈和队列专题/">
                栈和队列专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/03/找工作总结-栈和队列专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/03/找工作总结-栈和队列专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法">解法</h4><p>两个栈stack1,stack2。完成push和pop函数即可。</p>
<ul>
<li>push的时候向stack1压栈。</li>
<li>pop的时候<br>(1)stack2不为空，弹出stack2.top<br>(2)stack1不为空，把stack1中的元素全部弹出到stack2，然后弹出stack2.top<br>(3)如果stack1和stack2都是空，那么抛出异常<h4 id="注意点">注意点</h4></li>
<li>模板的写法</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">MyQueue</span>
{
public:
    <span class="type">void</span> push(<span class="keyword">const</span> T&amp; item);
    T pop();
private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> <span class="type">MyQueue</span>::push(<span class="keyword">const</span> T&amp; item)
{
    stack1.push(item);
}

<span class="keyword">template</span>&lt;typename T&gt;
T <span class="type">MyQueue</span>::pop()
{
    <span class="keyword">if</span>(!stack2.empty())
    {
        T temp = stack2.top();//?是否需要引用
        stack2.pop();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(!stack1.empty())
    {
        <span class="keyword">while</span>(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }
    <span class="keyword">else</span>
        throw exception(<span class="string">"MyQueue is empty!"</span>);
}
</code></pre><h4 id="扩展问题，使用两个队列实现栈">扩展问题，使用两个队列实现栈</h4><p>有queue1，queue2两个队列，完成push,pop。</p>
<ul>
<li>push<br>如果queue1.empty &amp;&amp; queue.empty 向queue1中push<br>如果有一个不为空，向不为空的队列里push</li>
<li>pop<br>如果queue1.empty &amp;&amp; queue.empty 抛出异常<br>把不为空的队列出队到空队列，直到剩下一个元素，弹出这个元素</li>
</ul>
<h3 id="剑指offer21_包含min函数的栈">剑指offer21 包含min函数的栈</h3><h4 id="问题描述-1">问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解法-1">解法</h4><p>使用stack1,stack2两个栈，stack1压入原本的元素，stack2只压最小元素</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">int</span> tempMin;
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            tempMin = <span class="keyword">value</span>;
        <span class="keyword">else</span>
        {
            tempMin = s2.top();
            <span class="keyword">if</span>(<span class="keyword">value</span> &lt; tempMin)
                tempMin = <span class="keyword">value</span>;
        }
        s1.push(<span class="keyword">value</span>);
        s2.push(tempMin);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">pop</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span>;
        s1.pop();
        s2.pop();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s1.top();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">min</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s2.top();
    }
<span class="keyword">private</span>:
    stack&lt;<span class="keyword">int</span>&gt; s1;
    stack&lt;<span class="keyword">int</span>&gt; s2;
};
</code></pre><h3 id="剑指offer22_栈的压入弹出序列">剑指offer22 栈的压入弹出序列</h3><h4 id="问题描述-2">问题描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h4 id="解法-2">解法</h4><p>使用一个栈stack进行模拟，遍历数组元素：</p>
<ul>
<li>如果<code>vec[i] != stack.top</code>，压入</li>
<li>如果<code>vec[i] == stack.top</code>，弹出</li>
<li><code>i == vec.size</code>时，判断栈是否为空</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    bool IsPopOrder<span class="params">(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)</span> {
        <span class="keyword">if</span><span class="params">(pushV.size<span class="params">()</span> != popV.size<span class="params">()</span>)</span>
            return <span class="literal">false</span>;
        stack&lt;int&gt; s;
        int i=<span class="number">0</span>,j=<span class="number">0</span>;
        <span class="keyword">for</span><span class="params">(;j &lt; popV.size<span class="params">()</span>; j++)</span>
        {
            while<span class="params">(s.empty<span class="params">()</span> || <span class="params">(i &lt; pushV.size<span class="params">()</span> &amp;&amp; s.top<span class="params">()</span> != popV[j])</span>)</span>
                s.push<span class="params">(pushV[i++])</span>;
            <span class="keyword">if</span><span class="params">(s.top<span class="params">()</span> == popV[j])</span>
                s.pop<span class="params">()</span>;
            <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span>)</span>
                break;
        }
        <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span> &amp;&amp; j == popV.size<span class="params">()</span> &amp;&amp; s.empty<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="剑指offer65_滑动窗口最大值">剑指offer65 滑动窗口最大值</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解法-3">解法</h4><p>使用双端队列(dequeue)记录当前窗口最大值<strong>下标</strong>序列，每插入一个元素就向前删除。通过比较dequeue的第一个元素是当前窗口的最大元素<strong>下标</strong>，比较首元素下标和i-size判断删除队列头部元素。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>从后向前删除</li>
<li>最后一个窗口</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; maxInWindows(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, unsigned <span class="type">int</span> size)
    {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(num.size() &lt; size || size &lt; <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        deque&lt;<span class="type">int</span>&gt; indexes;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)
        {
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            indexes.push_back(i);
        }

        <span class="keyword">for</span>(<span class="type">int</span> i = size;i &lt; num.size(); i++)
        {
            <span class="literal">result</span>.push_back(num[indexes.front()]);
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; indexes.front() &lt;= (i-size))
                indexes.pop_front();
            indexes.push_back(i);
        }
        <span class="literal">result</span>.push_back(num[indexes.front()]);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/栈和队列/"> #栈和队列 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">53</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
