<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-一般题目/">
                数组专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法">解法</h4><p>从右上角（这样使得这一行剩余元素都比他小，这一列剩余元素都比他大）向左下角扫描</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> width = <span class="built_in">array</span>[<span class="number">0</span>].size();
        <span class="keyword">int</span> height = <span class="built_in">array</span>.size();
        <span class="keyword">int</span> i = <span class="number">0</span>, j = width - <span class="number">1</span>;
        <span class="keyword">while</span>(i &lt; height &amp;&amp; j &gt;= <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)
                i++;
            <span class="keyword">else</span>
                j--;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer32_整数中1出现的次数（从1到n整数中1出现的次数）">剑指offer32 整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="问题描述-1">问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h4 id="解法-1">解法</h4><p>这个解法对于1-9的原理是一样的。首先找到规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从 1 至  10^i ，在它们右数第  i  位中，任意的 X 都出现了  10^(i−1)  次。这个可以用来计算高位的值。<br>计算方法：<br>当计算右数第  i  位包含的 X 的个数时：<br>取第  i  位左边（高位）的数字，乘以  10^(i−1) ，得到基础值  a 。<br>取第  i  位数字，计算修正值：<br>如果大于 X，则结果为  a+ 10^(i−1)。<br>如果小于 X，则结果为  a。<br>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  (a+b+1) 。<br>例如对于num=52134, i=3, a=52, b=34, i位数字k=1,k=x故 result=a+b+1<br>解释，a等于0~51，可推出高位的结果，a=52时，讨论低位的结果。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">int</span> NumberOf1Between1AndN_Solution(<span class="keyword">int</span> n)
    {
        <span class="keyword">int</span> x = <span class="number">1</span>;
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>, k;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)
        {
            k = n / i;
            <span class="comment">//k/10为高位数字</span>
            <span class="keyword">count</span> += (k / <span class="number">10</span>) * i;
            <span class="keyword">int</span> cur = k % <span class="number">10</span>;
            <span class="keyword">if</span>(cur &gt; x)
                <span class="keyword">count</span>+=i;               
            <span class="keyword">else</span> <span class="keyword">if</span>(cur == x)
                <span class="comment">//n%i为低位数字</span>
                <span class="keyword">count</span> += n % i + <span class="number">1</span>;
            <span class="keyword">else</span>{}
        }
        <span class="keyword">return</span> <span class="keyword">count</span>;
    }
};
</code></pre><h3 id="剑指offer44_扑克牌的顺子">剑指offer44 扑克牌的顺子</h3><h4 id="问题描述-2">问题描述</h4><p>抽出一序列牌，王代表任意数字是0，并且A看作1,J为11,Q为12,K为13。判断这个序列是否是顺子</p>
<h4 id="解法-2">解法</h4><p>对序列进行排序，看0是否能将空缺数字填满。</p>
<h4 id="注意点">注意点</h4><ul>
<li>统计0的个数和gap的数量进行比较</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool IsContinuous(vector&lt;<span class="keyword">int</span>&gt; numbers)
    {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">sort</span>(numbers.begin(), numbers.end());
        <span class="keyword">int</span> numOfZero = <span class="number">0</span>, numOfGap = <span class="number">0</span>;
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>() &amp;&amp; numbers[i] == <span class="number">0</span>; i++)
            numOfZero++;
        <span class="keyword">if</span>(i &lt; numbers.<span class="keyword">size</span>())
            i++;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == numbers[i - <span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>; 
            numOfGap += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;
        }
        <span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer52_构建乘积数组">剑指offer52 构建乘积数组</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组<code>A[0,1,...,n-1]</code>,请构建一个数组<code>B[0,1,...,n-1]</code>,其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<h4 id="解法-3">解法</h4><p>从上到下扫描，temp记录中间结果，避免重复的乘法。从上到下遍历一次，从下到上遍历一次。</p>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; multiply(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A) {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>(A.size(), <span class="number">1</span>);
        <span class="keyword">if</span>(A.size() &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)
        {
            temp *= A[i - <span class="number">1</span>];
            <span class="literal">result</span>[i] = temp;
        }
        temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)
        {
            temp *= A[i + <span class="number">1</span>];
            <span class="literal">result</span>[i] *= temp;
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h3 id="剑指offer20_顺时针打印矩阵">剑指offer20 顺时针打印矩阵</h3><h4 id="问题描述-4">问题描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h4 id="解法-4">解法</h4><p>先写一个打印一圈的函数，再遍历所有的圈。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>判断遍历是否越界</li>
<li>遍历的时候注意减回去(x—)</li>
</ul>
<h4 id="代码-4">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">matrix</span>) {
        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>.<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">int</span> start = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> start =  <span class="number">0</span>; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); start++)
            printInCircle(<span class="keyword">matrix</span>, start, vec);
        <span class="keyword">return</span> vec;
    }

    void printInCircle(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>, <span class="keyword">int</span> start, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)
    {
        <span class="keyword">int</span> x = start, y = start;
        <span class="comment">//从左向右打印</span>
        <span class="keyword">int</span> endx = <span class="keyword">matrix</span>[y].<span class="keyword">size</span>()- <span class="number">1</span> - start;
        <span class="keyword">for</span>(; x &lt;= endx; x++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        --x;

        <span class="comment">//从上向下打印</span>
        <span class="keyword">int</span> endy = <span class="keyword">matrix</span>.<span class="keyword">size</span>() - <span class="number">1</span> - start;
        <span class="keyword">if</span>(y + <span class="number">1</span> &gt; endy)
            <span class="keyword">return</span>;
        y++;
        <span class="keyword">for</span>(; y &lt;= endy; y++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y--;

        <span class="comment">//从右向左打印</span>
        <span class="keyword">if</span>(x - <span class="number">1</span> &lt; start)
            <span class="keyword">return</span>;
        x--;
        <span class="keyword">for</span>(; x &gt;= start; x--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        x++;
        <span class="comment">//从下向上打印</span>
        <span class="keyword">if</span>(y - <span class="number">1</span> &lt; start) <span class="keyword">return</span>;
        y--;
        <span class="keyword">for</span>(; y &gt; start; y--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y++;
    }

 };
</code></pre><h3 id="剑指offer30_最小的k个数">剑指offer30 最小的k个数</h3><h4 id="问题描述-5">问题描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="解法-5">解法</h4><p>使用大顶堆存储k个数，遍历原数据，每次淘汰最大的，最后堆中剩余的元素就是最小的k个数</p>
<h4 id="注意点-2">注意点</h4><ul>
<li>输入数据合法性，k的取值大于input.size()的情况</li>
<li><p>stl中<algorithm>关于堆的操作，make_heap,push_heap,pop_heap,sort_heap.默认建立大顶堆，如果想使用小顶堆需要加入比较函数。</algorithm></p>
<pre><code>make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
</code></pre></li>
</ul>
<h4 id="代码-5">代码</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    vector&lt;<span class="built_in">int</span>&gt; <span class="type">GetLeastNumbers_Solution</span>(vector&lt;<span class="built_in">int</span>&gt; input, <span class="built_in">int</span> k) {
        vector&lt;<span class="built_in">int</span>&gt; res;
        <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.size<span class="literal">()</span>)
            return res;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)
            res.push_back(input[i]);
        make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; input.size<span class="literal">()</span>; i++)
        {
            <span class="keyword">if</span>(input[i] &gt;= res[<span class="number">0</span>])
                continue;
            res.push_back(input[i]);
            push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            res.pop_back<span class="literal">()</span>;
        }
        sort_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        return res;
    }
};
</code></pre><h3 id="剑指offer33_把数组排成最小的数">剑指offer33 把数组排成最小的数</h3><h4 id="问题描述-6">问题描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="解法-6">解法</h4><p>首先要证明这样一个结论：</p>
<blockquote>
<p>若ca&lt;ac则在最后的字符串中，c应该在a的后面</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>条件：ca&lt;ac，有另一个任意<strong>字符串</strong>b与a,c进行排列组合<br>讨论：</p>
<pre><code>若b&lt;c&lt;<span class="tag">a</span> 可以得到bca是最小的
若c&lt;b&lt;<span class="tag">a</span> 可以得到cba是最小的
若c&lt;a&lt;<span class="tag">b</span> 可以得到cab是最小的
</code></pre><p>结论：c应该在a的前面</p>
<h4 id="注意点-3">注意点</h4><ul>
<li><p>sort函数中比较函数应该如何写</p>
<p>  <code>template &lt;class RandomAccessIterator, class Compare&gt;</code><br>  <code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
</li>
</ul>
<p>comp函数表示</p>
<blockquote>
<p>The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.<br>比较函数传入两个参数，返回bool，返回值表示在最终的排序结果中，第一个参数是否应该出现在第二个参数的前面。</p>
</blockquote>
<h4 id="代码-6">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span>
    </span>{
        <span class="built_in">string</span> temp1 = str1 + str2;
        <span class="built_in">string</span> temp2 = str2 + str1;
        <span class="keyword">if</span>(temp1.compare(temp2)&lt;=<span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;

    }

    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>{
        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs(numbers.size());
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)
        {
            strs[i] = numToString(numbers[i]);
        }
        <span class="built_in">std</span>::sort(strs.begin(), strs.end(), cmp);
        <span class="built_in">string</span> ans;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)
            ans += strs[i];
        <span class="keyword">return</span> ans;
    }  

    <span class="function"><span class="built_in">string</span> <span class="title">numToString</span><span class="params">(<span class="keyword">int</span> num)</span>
    </span>{
        <span class="built_in">string</span> str;
        <span class="keyword">while</span>(num)
        {
            str = (<span class="keyword">char</span>)(num % <span class="number">10</span> + <span class="string">'0'</span>) + str;
            num = num / <span class="number">10</span>;
        }
        <span class="keyword">return</span> str;
    } 
};
</code></pre><h3 id="剑指offer34_丑数">剑指offer34 丑数</h3><h4 id="问题描述-7">问题描述</h4><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="解法-7">解法</h4><p>使用递推法，<code>*numM2</code>,<code>*numM3</code>,<code>*numM5</code>表示，x2,x3,x5后产生的数</p>
<h4 id="代码-7">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> GetUglyNumber_Solution(<span class="built_in">int</span> <span class="built_in">index</span>) {
        <span class="keyword">if</span>(<span class="built_in">index</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> *a = new <span class="built_in">int</span>[<span class="built_in">index</span>];
        a[<span class="number">0</span>] = <span class="number">1</span>;
        <span class="built_in">int</span> *numM2 = a, *numM3 = a, *numM5 = a;
        for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">index</span>; i++)
        {
            <span class="built_in">int</span> <span class="built_in">min</span> = getMin((*numM2) * <span class="number">2</span>, (*numM3) * <span class="number">3</span>, (*numM5) * <span class="number">5</span>);
            a[i] = <span class="built_in">min</span>;
            <span class="keyword">while</span>((*numM2) * <span class="number">2</span> &lt;= <span class="built_in">min</span>)
                numM2++;
            <span class="keyword">while</span>((*numM3) * <span class="number">3</span> &lt;= <span class="built_in">min</span>)
                numM3++;
            <span class="keyword">while</span>((*numM5) * <span class="number">5</span> &lt;= <span class="built_in">min</span>)
                numM5++;
        }
        <span class="keyword">return</span> a[<span class="built_in">index</span>-<span class="number">1</span>];
    }

    <span class="built_in">int</span> getMin(<span class="built_in">int</span> num1,<span class="built_in">int</span> num2,<span class="built_in">int</span> num3)
    {
        <span class="keyword">return</span> <span class="built_in">min</span>(num1, <span class="built_in">min</span>(num2, num3));
    }
};
</code></pre><h3 id="剑指offer45_圆圈中最后剩下的数字（约瑟夫环问题）">剑指offer45 圆圈中最后剩下的数字（约瑟夫环问题）</h3><h4 id="问题描述-8">问题描述</h4><p>每年六一儿童节,NowCoder都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为NowCoder的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到NowCoder名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？</p>
<h4 id="解法-8">解法</h4><p>约瑟夫环递推公式：<br>f(n, m)表示n个人玩儿，报到m退出，最后剩下的人的编号。</p>
<pre><code><span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = 0, <span class="keyword">n</span>=1
<span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = (<span class="literal">f</span>(<span class="keyword">n</span> - 1) + <span class="keyword">m</span>) % <span class="keyword">n</span>, <span class="keyword">n</span> &gt; 1
</code></pre><h4 id="代码-8">代码</h4><h5 id="递推解法">递推解法</h5><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span>
    </span>{
        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">int</span> last = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)
            last=(last + m) % i;
        <span class="keyword">return</span> last;
    }
};
</code></pre><h5 id="递归解法">递归解法</h5><pre><code>int lastRemain(int <span class="keyword">n</span>, int  <span class="keyword">m</span>)
{
    <span class="keyword">if</span>(<span class="keyword">n</span> == 1)
        <span class="keyword">return</span> 0;
    <span class="keyword">return</span> (lastRemain(<span class="keyword">n</span> - 1, <span class="keyword">m</span>) % <span class="keyword">n</span>);
}
</code></pre><h4 id="问题拓展:求第i次出环的人的编号">问题拓展:求第i次出环的人的编号</h4><pre><code>int getNumOfI(int <span class="keyword">n</span>, int <span class="keyword">m</span>, int i)
{
    <span class="keyword">if</span>(i == 1)
        <span class="keyword">return</span> (<span class="keyword">n</span> + <span class="keyword">m</span> - 1) % <span class="keyword">n</span>; <span class="comment">//第一次出环 (n-1+m)%n</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> getNumOfI(<span class="keyword">n</span> - 1, <span class="keyword">m</span>, i - 1) % <span class="keyword">n</span>;
}
</code></pre><p><a href="http://www.cnblogs.com/yangyh/archive/2011/10/30/2229517.html" target="_blank" rel="external">参考</a></p>
<h3 id="剑指offer64_数据流中的中位数">剑指offer64 数据流中的中位数</h3><h4 id="问题描述-9">问题描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>实现一种数据结构，要求插入删除O(logn),取中位数O(1)</p>
<h4 id="解法-9">解法</h4><p>实现一个小顶堆和大顶堆，大数存在小顶堆，小数存在大顶堆，每次按大小压入元素，调整两个堆中的数量，使得<code>0&lt;=Num(大顶堆)-Num(小顶堆)&lt;=1</code>。</p>
<h4 id="注意点-4">注意点</h4><ul>
<li>使用priority_queue<br>初始化：<pre><code>priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;
priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;
</code></pre>压入，弹出：<pre><code><span class="tag">minHeap</span><span class="class">.push</span>(<span class="tag">maxHeap</span><span class="class">.top</span>());
<span class="tag">maxHeap</span><span class="class">.pop</span>();
</code></pre></li>
</ul>
<h4 id="代码-9">代码</h4><pre><code>class Solution {
public:
    void Insert<span class="params">(int num)</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.empty<span class="params">()</span> || num &lt;= maxHeap.top<span class="params">()</span>)</span>
            maxHeap.push<span class="params">(num)</span>;
        <span class="keyword">else</span>
            minHeap.push<span class="params">(num)</span>;
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>+<span class="number">2</span>)</span>
        {
            minHeap.push<span class="params">(maxHeap.top<span class="params">()</span>)</span>;
            maxHeap.pop<span class="params">()</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>-<span class="number">1</span>)</span>
        {
            maxHeap.push<span class="params">(minHeap.top<span class="params">()</span>)</span>;
            minHeap.pop<span class="params">()</span>;
        }
    }

    double GetMedian<span class="params">()</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>)</span>
            return <span class="params">(maxHeap.top<span class="params">()</span> + minHeap.top<span class="params">()</span>)</span>/<span class="number">2.0</span>;
        <span class="keyword">else</span>
            return maxHeap.top<span class="params">()</span>;
    }
private:
    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;

};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-出现次数/">
                数组专题-数组中出现的次数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-出现次数/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-出现次数/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="通用的几种解题思路">通用的几种解题思路</h2><ul>
<li>使用map记录出现的次数，要求额外增加空间复杂度</li>
<li>所有数字异或可以消灭掉数组中出现偶数次的数字</li>
</ul>
<h3 id="剑指offer51_数组中重复的数字">剑指offer51 数组中重复的数字</h3><h4 id="问题描述">问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h4 id="解法">解法</h4><ul>
<li>排序后扫描，时间复杂度nlogn，空间复杂度O(1)</li>
<li>使用map记录，时间复杂度O(n)，空间复杂度O(n)</li>
</ul>
<h4 id="注意点">注意点</h4><ul>
<li>map的遍历<br><code>map&lt;int, int&gt;::iterator iter;</code><br><code>iter-&gt;first</code> <code>iter-&gt;second</code></li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{
        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;
        <span class="keyword">bool</span> ans = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)
        {
            <span class="keyword">if</span>(dict.count(numbers[i]) == <span class="number">0</span>)
                dict[numbers[i]] = <span class="number">1</span>;
            <span class="keyword">else</span>{
                dict[numbers[i]] += <span class="number">1</span>;
                ans = <span class="keyword">true</span>;
            }
        }
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;
        <span class="keyword">for</span>(iter = dict.begin();iter != dict.end();iter++)
        {
            <span class="keyword">if</span>(iter-&gt;second &gt; <span class="number">1</span>)
            {
                *duplication = iter-&gt;first;
                duplication++;
            }
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer29_数组中出现次数超过一半的数字">剑指offer29 数组中出现次数超过一半的数字</h3><h4 id="问题描述-1">问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<h4 id="解法-1">解法</h4><ul>
<li>使用快排partition函数，扫描一遍数组中间元素就是出现超过一半的数字</li>
<li>使用time记录数字出现的次数，cur记录当前数字</li>
</ul>
<h4 id="注意点-1">注意点</h4><ul>
<li>使用解法2需要判断最后的次数是否真的大于一半，如果不是，返回特定值</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="keyword">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="keyword">int</span>&gt; numbers) {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>) 
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> time = <span class="number">1</span>;
        <span class="keyword">int</span> cur = numbers[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(time == <span class="number">0</span>)
            {
                cur = numbers[i];
                time = <span class="number">1</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == cur)
                time++;
            <span class="keyword">else</span>
                time--;
        }
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == cur)
                <span class="keyword">count</span>++;
        }
        <span class="keyword">if</span>(<span class="keyword">count</span> * <span class="number">2</span> &gt; numbers.<span class="keyword">size</span>())
            <span class="keyword">return</span> cur;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre><h3 id="剑指offer40_数组中只出现一次的数字">剑指offer40 数组中只出现一次的数字</h3><h4 id="问题描述-2">问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解法-2">解法</h4><ul>
<li>对于只有一个数字出现一次，对所有数字做异或操作</li>
<li>有两个数字a,b出现了一次，其它出现偶数次。所有数字异或得temp = a^b，使用result做spliter，每一个数字和temp做与操作，把数组分成两组</li>
</ul>
<h4 id="注意点-2">注意点</h4><ul>
<li>与或非的操作符优先级</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void FindNumsAppearOnce(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>,<span class="built_in">int</span>* num1,<span class="built_in">int</span> *num2) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)
        {
            *num1 = <span class="number">0</span>;
            *num2 = <span class="number">0</span>;
            <span class="keyword">return</span> ;
        }
        <span class="built_in">int</span> temp = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;<span class="type">data</span>.<span class="built_in">size</span>(); i++)
            temp ^= <span class="type">data</span>[i];

        <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="type">data</span>.<span class="built_in">size</span>(); i++)
        {
            <span class="keyword">if</span>((<span class="type">data</span>[i] &amp; temp) == <span class="number">0</span>)
                a ^= <span class="type">data</span>[i];
            <span class="keyword">else</span>
                b ^= <span class="type">data</span>[i];

        }
        *num1 = a;
        *num2 = b;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/25/找工作总结-字符串专题-一般题目/">
                字符串专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/25/找工作总结-字符串专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/25/找工作总结-字符串专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一遍，记录空格个数。申请newSize，从后向前填充数组。</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string replaceSpace(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="built_in">int</span> numOfSpace=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">str</span>.<span class="built_in">size</span>();++i)
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
                ++numOfSpace;
        <span class="built_in">int</span> newSize=<span class="built_in">str</span>.<span class="built_in">size</span>()+<span class="number">2</span>*numOfSpace;
        string ans;
        ans.resize(newSize);
        <span class="built_in">int</span> i=<span class="built_in">str</span>.<span class="built_in">size</span>()-<span class="number">1</span>,j=newSize-<span class="number">1</span>;
        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)   
        {
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
            {
                ans[j--]=<span class="string">'0'</span>;
                ans[j--]=<span class="string">'2'</span>;
                ans[j--]=<span class="string">'%'</span>;
                --i;
            }
            <span class="keyword">else</span>
                ans[j--]=<span class="built_in">str</span>[i--];
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer54_表示数值的字符串">剑指offer54 表示数值的字符串</h3><p>问题描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>解法：首先可以写出这个字符串的正则表达式</p>
<pre><code>(+|-)？\<span class="keyword">d</span>+(.\<span class="keyword">d</span>+)?(<span class="keyword">e</span>|<span class="literal">E</span>(+|-)?\<span class="keyword">d</span>+)?
</code></pre><p>对于正则表达式中的符号，<code>?</code>表示0或1，使用<code>if</code>判断，+表示1或者更多，直接扫描判断。</p>
<p>注意点：<br>(1) 非法输入，传入str == NULL<br>(2) 结束条件的判断</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isNumeric(<span class="keyword">char</span>* <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'.'</span>)
        {
            <span class="keyword">str</span>++;
            <span class="comment">//根据题目要求是否允许"32."这样的数据</span>
            <span class="comment">//if(*str == '\0')</span>
            <span class="comment">//    return false;</span>
            scanDigits(<span class="keyword">str</span>);
        }
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'e'</span> || *<span class="keyword">str</span> == <span class="string">'E'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">void</span> scanDigits(<span class="keyword">char</span> *(&amp;<span class="keyword">str</span>))
    {
        <span class="keyword">while</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'9'</span>)
            <span class="keyword">str</span>++;
    }
};
</code></pre><h3 id="剑指offer55_字符流中第一个不重复的字符">剑指offer55 字符流中第一个不重复的字符</h3><p>问题描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>解法：字符只有256个，所以可以使用<code>int dict[256]</code>数组来记录所有字符出现的情况。0表示未出现过，-1表示出现过大于1次，&gt;0时dict[i]表示字符i第一次出现的index</p>
<p>注意点：<br>通过遍历dict[26]找到minIndex找到<strong>第一次出现</strong>的字符</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>
</span>{
<span class="keyword">public</span>:
      <span class="comment">//Insert one char from stringstream</span>
    <span class="keyword">void</span> Insert(<span class="keyword">char</span> ch)
    {
        <span class="keyword">if</span>(dict[ch] == <span class="number">0</span>) <span class="comment">//没出现过</span>
            dict[ch] = <span class="keyword">index</span>;
        <span class="keyword">else</span> <span class="comment">//出现过</span>
            dict[ch] = -<span class="number">1</span>;
        <span class="keyword">index</span>++;
    }
      <span class="comment">//return the first appearence once char in current stringstream</span>
    <span class="keyword">char</span> FirstAppearingOnce()
    {
        <span class="keyword">char</span> ans=<span class="string">'#'</span>;
        <span class="keyword">int</span> minIndex = INT_MAX;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
        {
            <span class="keyword">if</span>(dict[i] &gt; <span class="number">0</span> &amp;&amp; dict[i] &lt; minIndex)
            {
                ans = i;
                minIndex = dict[i];
            }
        }
        <span class="keyword">return</span> ans;
    }

    Solution()
    {
        <span class="keyword">index</span> = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
            dict[i] = <span class="number">0</span>;
    }
<span class="keyword">private</span>:
    <span class="keyword">int</span> dict[<span class="number">256</span>];
    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">1</span>;
};
</code></pre><h3 id="剑指offer42_反转单词顺序_VS_左旋字符串">剑指offer42 反转单词顺序 VS 左旋字符串</h3><p>反转字符串函数：</p>
<pre><code>void reverseString(<span class="built_in">string</span> &amp;str, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        char temp = str[<span class="built_in">left</span>];
        str[<span class="built_in">left</span>] = str[<span class="built_in">right</span>];
        str[<span class="built_in">right</span>] = temp;
        <span class="built_in">left</span>++;
        <span class="built_in">right</span>--;
    }
}
</code></pre><h4 id="反转单词顺序">反转单词顺序</h4><p>问题描述：JOBDU最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>解法：先反转每一个单词，再反转整句</p>
<p>注意点：</p>
<ol>
<li>功能测试：”student. a am I”</li>
<li>特殊测试用例”aaa “,” aaa”</li>
</ol>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string ReverseSentence(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;
        <span class="keyword">while</span>(right &lt; <span class="built_in">str</span>.<span class="built_in">size</span>())
        {
            <span class="keyword">while</span>(<span class="built_in">str</span>[left] == <span class="string">' '</span>)
            {
                left++;
                right++;
            }
            <span class="comment">//应对用例"aa "</span>
            <span class="keyword">if</span>(left &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>()) 
                <span class="keyword">break</span>;
            <span class="keyword">while</span>(<span class="built_in">str</span>[right] != <span class="string">' '</span> &amp;&amp; <span class="built_in">str</span>[right] != <span class="string">'\0'</span>)
                right++;
            reverseString(<span class="built_in">str</span>,left,right-<span class="number">1</span>);
            left = right;
        }
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre><h4 id="左旋字符串">左旋字符串</h4><p>问题描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>解法：先反转3分割的两部分，再旋转这个字符串</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string LeftRotateString(string <span class="built_in">str</span>, <span class="built_in">int</span> n) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="keyword">if</span>(n &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, n - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, n, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/字符串/"> #字符串 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/24/排序算法总结/">
                排序算法总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/24/排序算法总结/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/24/排序算法总结/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>void insertSort(int a[], int N)
<span class="comment">{
    for(int i = 1; i &lt; N; i++)
    {
        int temp = a[i];
        int j;
        for(j = i; j &gt; 0 &amp;&amp; temp &lt; a[j-1]; j--)
            a[j] = a[j-1];
        a[j] = temp;
    }</span>
}
</code></pre><h3 id="希尔排序">希尔排序</h3><p>原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<blockquote>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> incre = N / <span class="number">2</span>; incre &gt; <span class="number">0</span>; incre /= <span class="number">2</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = incre; i &lt; N; i++)
        {
            <span class="keyword">int</span> temp = a[i];
            <span class="keyword">int</span> j;
            <span class="keyword">for</span>(j = i; j &gt;= incre &amp;&amp; temp &lt; a[j - incre]; j -= incre)
                a[j] = a[j - incre];
            a[j] = temp;
        }
    }
}
</code></pre><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。</p>
<pre><code>void bubbleSort(int <span class="literal">a</span>[], int N)
{
    for(int i = <span class="number">0</span><span class="comment">; i &lt; N; i++)</span>
    {
        for(int j = i<span class="comment">; j &lt; N - i - 1; j++)</span>
        {
            <span class="keyword">if</span>(<span class="literal">a</span>[j] &gt; <span class="literal">a</span>[j+<span class="number">1</span>])
            {
                int temp = <span class="literal">a</span>[j]<span class="comment">;</span>
                <span class="literal">a</span>[j] = <span class="literal">a</span>[j+<span class="number">1</span>]<span class="comment">;</span>
                <span class="literal">a</span>[j+<span class="number">1</span>] = temp<span class="comment">;</span>
            }
        }
    }
}
</code></pre><p>补充说明：使用didSwap=true/false可以避免重复的比较，使得最好情况的复杂度变为O(n)</p>
<h3 id="快速排序">快速排序</h3><p>原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>实现：</p>
<pre><code>void quickSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> temp = a[<span class="built_in">left</span>];
        <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">right</span>;
        <span class="keyword">while</span>(i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &lt;= a[j])
                j--;
            <span class="keyword">if</span>(i &lt; j)
                a[i++] = a[j];
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &gt;= a[i])
                i++;
            <span class="keyword">if</span>(i &lt; j)
                a[j--] = a[i];
        }
        a[i] = temp;
        quickSortCore(a, <span class="built_in">left</span>, i-<span class="number">1</span>);
        quickSortCore(a, i+<span class="number">1</span>, <span class="built_in">right</span>);
    }

}

void quickSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    quickSortCore(a, <span class="number">0</span>, N-<span class="number">1</span>);
}
</code></pre><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p>原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)
    {
        <span class="keyword">int</span> k = i;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)
        {
            <span class="keyword">if</span>(a[j] &lt; a[k])
                k = j;
        }
        <span class="keyword">int</span> temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
}
</code></pre><h3 id="堆排序">堆排序</h3><p>堆序性质： 堆分为大顶堆和小顶堆，满足<code>Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code>称为大顶堆，满足 <code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]</code>称为小顶堆。</p>
<p>原理：利用大顶堆或小顶堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。如从小到大排序，建立大顶堆，堆顶元素与堆尾不断交换，同时缩小堆的范围，最终得到排序结果。</p>
<pre><code>void percDown(int a[], int i, int N)
<span class="comment">{
    int temp = a[i], child;
    for(; 2 * i + 1 &lt; N; i = child)
    {
        child = 2 * i + 1;
        if(child + 1 &lt; N &amp;&amp; a[child] &lt; a[child + 1])
            child++;
        if(temp &lt; a[child])
            a[i] = a[child];
        else
            break;
    }</span>
    a[i] = temp;
}

void heapSort(int a[], int N)
<span class="comment">{
    for(int i = N / 2; i &gt;= 0; i--)
        percDown(a, i, N);
    for(int i = N-1; i &gt; 0; i--)
    {
        int temp = a[i];
        a[i] = a[0];
        a[0] = temp;
        percDown(a, 0, i);
    }</span>
}
</code></pre><h2 id="归并排序">归并排序</h2><p>原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。</p>
<pre><code>void merge(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> lpos = <span class="built_in">left</span>, lend = <span class="built_in">mid</span>;
        <span class="built_in">int</span> rpos = <span class="built_in">mid</span> + <span class="number">1</span>, rend = <span class="built_in">right</span>;
        <span class="built_in">int</span> tpos = <span class="built_in">left</span>;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(a[lpos] &lt;= a[rpos])
                temp[tpos++] = a[lpos++];
            <span class="keyword">else</span>
                temp[tpos++] = a[rpos++];
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++] = a[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = a[rpos++];
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">right</span>; i++)
            a[i] = temp[i];
    }
}
void mergeSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
        mergeSortCore(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>);
        mergeSortCore(a, temp, <span class="built_in">mid</span>+<span class="number">1</span>, <span class="built_in">right</span>);
        merge(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);
    }
}
void mergeSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    <span class="built_in">int</span> *temp = <span class="keyword">new</span> <span class="built_in">int</span>[N];
    mergeSortCore(a, temp, <span class="number">0</span>, N-<span class="number">1</span>);
    delete [] temp;
}
</code></pre><h2 id="各种排序算法的复杂度稳定性分析">各种排序算法的复杂度稳定性分析</h2><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">复杂度分析</th>
<th>稳定性</th>
<th>稳定性原因分析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">简单插入</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">平均接近nlogn,最好O(n),最坏O(n^2)</td>
<td>不稳定</td>
<td>增量分组，有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">交换排序</td>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">平均nlogn,最好nlogn,最坏O(n^2)</td>
<td>不稳定</td>
<td>有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">直接选择</td>
<td style="text-align:left">平均O(n^2),最好O(n^2),最坏O(n^2)</td>
<td>不稳定</td>
<td>5 8 5 2</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">平均,最好,最坏nlogn</td>
<td>不稳定</td>
<td>3 2 3 2</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">平均,最好,最坏nlogn，有O(n)空间复杂度</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
</tbody>
</table>
<h2 id="扩展问题">扩展问题</h2><ul>
<li>单链表可以做快速排序吗？为什么？</li>
</ul>
<p>可以。快速排序的核心函数partition，选择某个元素为枢纽元x(通常是第一个)，一遍扫描之后使得比x小的在枢纽元左边，比x大的在枢纽元的右边。使用链表时，x指向链表头(枢纽元)，扫描这个链表，小元素拼在链表头，大元素拼在链表尾部，从而完成一次partition函数的流程。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序/"> #排序 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/21/effectiveCPP读书笔记/">
                Effective C++ 读书笔记
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-08-20
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/编程语言/">编程语言</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/08/21/effectiveCPP读书笔记/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/21/effectiveCPP读书笔记/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C++ 使用模板编程</li>
<li>STL</li>
</ul>
<p>每一个部分都有各自的规约</p>
<h2 id="条款2，_尽量以const，enum，inline替换#define">条款2， 尽量以const，enum，inline替换#define</h2><ul>
<li>#define只有替换功能，在预处理阶段完成，没有<strong>类型检查</strong>，也没有封装性</li>
<li>使用const替代变量定义，inline替代函数定义</li>
<li>预处理器中，#include必不可少，#ifdef，#else可以用来进行控制编译</li>
</ul>
<h2 id="条款3，尽可能使用const">条款3，尽可能使用const</h2><p>只要是事实，就把它说出来。只要是const就要声明为const类型。</p>
<ul>
<li>const修饰变量<br>const char <em>p = greeting等价于char const </em>p = greeting<br>char * const p = greeting 指针不可更改指向对象</li>
<li>const修饰函数，是最有威力的应用</li>
</ul>
<p>(1) const 返回值</p>
<p>(2) const 函数参数，使用最多</p>
<p>(3) const 成员函数，表明这个函数不能修改任何成员变量（static变量可以修改），也不能调用任何非const成员</p>
<p>补充，<br>volidate int a，告诉编译器这个值可能被未知因素修改，每次都要从内存中重新读取<br>mutable int a，可以突破const成员函数限制，在函数中被修改</p>
<h2 id="条款4，确定对象被使用前已先被初始化">条款4，确定对象被使用前已先被初始化</h2><ul>
<li><p>成员初始化应该在构造函数之前，意味着要使用<strong>成员初始化列表</strong>进行成员变量的初始化<br>说明：成员变量总是以声明的次序被初始化</p>
</li>
<li><p>对于static变量，使用Singleton+inline，保证在对象使用前初始化</p>
</li>
</ul>
<h2 id="条款5，了解C++默默编写并调用了哪些函数">条款5，了解C++默默编写并调用了哪些函数</h2><p>构造函数，拷贝构造函数，赋值函数，析构函数</p>
<h2 id="条款6，若不想使用编译器自动生成的函数，就该明确拒绝">条款6，若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul>
<li>如果某些对象不可复制（不能使用copy constructor）<br>不是很安全的做法：把拷贝构造函数声明为private<br>更好的做法：写一个<strong>UnCopyable基类</strong>，copy constructor声明为private</li>
</ul>
<h2 id="条款7，为多态基类声明virtual析构函数">条款7，为多态基类声明virtual析构函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span></span>{}
A *b=<span class="keyword">new</span> B()
<span class="keyword">delete</span> b
</code></pre><p>因为b是A类型的指针，所以会导致局部销毁（只有A的部分被销毁）</p>
<p>原则：</p>
<ul>
<li><strong>企图作为（多态的）base class的类理论上都应该有virtual函数</strong>，否则不应该作为base class（虚指针会额外增加空间）</li>
<li>任何带有virtual 函数的类都应该把析构函数声明为virtual<br>不要试图继承任何STL容器，因为他们没有virtual的析构函数</li>
</ul>
<h2 id="条款8，别让异常逃离析构函数">条款8，别让异常逃离析构函数</h2><ul>
<li>析构函数不能抛出异常，否则会导致不明行为。</li>
<li>析构函数应该吞下这个异常，防止传播</li>
<li><strong>调用一个自己的函数，使得用户有机会来处理这个异常</strong>。 </li>
</ul>
<h2 id="条款9，_绝不要在构造或者析构过程中调用virtual函数">条款9， 绝不要在构造或者析构过程中调用virtual函数</h2><ul>
<li><p>构造过程</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:     
    A(){
         virtual <span class="function"><span class="title">fun</span><span class="params">()</span></span>
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{}</span></span>
B b;
</code></pre></li>
</ul>
<p>构造B-&gt;构造A-&gt;调用fun(),这时B还没构造完（被编译器看成A对象），导致virtual 函数不会下降到子类执行。</p>
<ul>
<li>析构过程<br>析构B-&gt;析构A-&gt;调用fun()，这时B已经被析构掉了，同样virtual函数不会下降，得不到想要的结果。</li>
</ul>
<h2 id="条款10，令operator=_返回一个reference_to_*this">条款10，令operator= 返回一个reference to *this</h2><p>为了保证连续运算如：A=B=C 相当于A = (B = C)<br>返回一个引用，不会调用copy constructor<br>对于+=同样适用</p>
<h2 id="条款11，在operator=_中处理自我赋值">条款11，在operator= 中处理自我赋值</h2><p>判断一下，if (this == &amp;rhs) return *this</p>
<h2 id="条款12，复制对象时勿忘其每一个成分">条款12，复制对象时勿忘其每一个成分</h2><p>可能出现的问题</p>
<p>（1）对象中的非内置类型不能得到赋值</p>
<p>（2）对象从父类继承而来的变量不能得到赋值</p>
<ul>
<li>赋值所有local成员（内置类型，对象）</li>
<li>调用所有base class中的适当的copy constructor</li>
</ul>
<h2 id="条款13，以对象管理资源">条款13，以对象管理资源</h2><p>C++申请释放的资源：堆内存（最常用），文件，互斥锁，数据库连接等。一旦申请资源，就必须释放，否则就会造成内存泄露。</p>
<p>以对象管理资源相当于，使用一个类（RAII类）封装这个资源，在构造时初始化，在析构时释放。声明这个对象时使用栈内存声明。</p>
<p>常用：</p>
<p><code>auto_ptr</code> ,封装对象，重写了指针行为，看起来像一个指针。只能指向一个对象。复制或者赋值，会删除原来的指针。</p>
<p><code>shared_ptr</code>，类似于auto_ptr，不过允许多个指针指向同一个对象，内部提供引用计数。<br>这两个是最常见的RAII类，在构造时初始化，析构时delete。（注意不能<code>auto_ptr</code>(new std::string[10])数组对象）</p>
<h2 id="条款14，在资源管理类中小心copying行为">条款14，在资源管理类中小心copying行为</h2><p>类似于<code>auto_ptr</code>或者<code>shared_ptr</code>的处理方式，对于复制。可以：</p>
<ul>
<li>禁止复制</li>
<li>引用计数，类似于shared_ptr</li>
</ul>
<h2 id="条款15，在资源管理类中提供对原始资源的访问">条款15，在资源管理类中提供对原始资源的访问</h2><p>隐式：如<code>auto_ptr</code>重写了指针行为，*ptr,<code>ptr-&gt;</code>使得这个变量看起来像一个指针。从而可以访问封装的资源</p>
<p>显示：提供get()函数返回资源</p>
<h2 id="条款16，使用new和delete时要采用相同的形式">条款16，使用new和delete时要采用相同的形式</h2><p>A *a=new A() ,释放时 使用delete a</p>
<p>int *a=new a[100],释放时使用delete []a</p>
<h2 id="条款17，以独立语句将newed对象置入智能指针">条款17，以独立语句将newed对象置入智能指针</h2><pre><code>std::tr1::shared_ptr&lt;Widget&gt; <span class="function"><span class="title">pw</span><span class="params">(new Widget)</span></span>
<span class="function"><span class="title">processWidget</span><span class="params">(pwd, priority()</span></span>)
</code></pre><p>使用单独语句，不要放到一起可能会造成编译先后导致指针丢失。<br>其实不是很明白这点</p>
<h2 id="条款18，让接口容易被使用，不易被误用">条款18，让接口容易被使用，不易被误用</h2><ul>
<li><p>导入新类型</p>
<pre><code><span class="built_in">Date</span>(<span class="built_in">int</span> <span class="built_in">month</span>, <span class="built_in">int</span> <span class="built_in">day</span>, <span class="built_in">int</span> <span class="built_in">year</span>)
</code></pre></li>
</ul>
<p>多个参数，使用Month，Day，Year类型，可以预防接口被误用</p>
<ul>
<li>接口一致性</li>
</ul>
<p>如:stl每个容器都有size()方法</p>
<h2 id="条款19，设计class犹如设计type">条款19，设计class犹如设计type</h2><p>设计一个类时需要考虑很多问题：</p>
<ol>
<li>创建和销毁</li>
<li>初始化（初始化列表），拷贝构造函数</li>
<li>pass by value &amp;&amp; pass by reference</li>
<li>继承关系</li>
<li>类型转换</li>
<li>操作符重载</li>
<li>标准函数驳回（private copy constructor）</li>
<li>public private</li>
<li>效率，异常</li>
<li>不够一般化，太过一般化</li>
<li>是否真的需要这个类型</li>
</ol>
<h2 id="条款20，_宁以pass_by_reference_to_const_替换_pass_by_value">条款20， 宁以pass by reference to const 替换 pass by value</h2><ul>
<li>区别</li>
</ul>
<p>pass by value:</p>
<p>要调用copy constructor，可能是费时的操作</p>
<p>pass by reference to const:</p>
<p>const Student &amp;s，const保证变量在函数内不会被修改</p>
<ul>
<li><p>pass by value可能导致多态失效</p>
<pre><code><span class="keyword">void</span> printNameAndDisplay（Window w）
</code></pre></li>
</ul>
<p>传入子类对象，不能实现多态</p>
<ul>
<li>在编译器底层，reference是通过指针来实现的</li>
</ul>
<h2 id="条款21，必须返回对象时，别妄想返回其reference">条款21，必须返回对象时，别妄想返回其reference</h2><pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator* (<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs)
</code></pre><p>如果返回reference</p>
<ul>
<li>返回local stack的对象（Rational r），则函数退出时，这个对象已经被销毁了</li>
<li>返回heap-allocate对象，会造成何时delete的问题。</li>
<li>返回static对象，if(a<em>b == c</em>d),导致一个static对象不够用的问题</li>
</ul>
<p>原则，必须在返回reference和object作出一个选择，程序员的工作就是选出正确的那个</p>
<h2 id="条款22，将变量声明为private">条款22，将变量声明为private</h2><ul>
<li>public接口内全部都是函数，可以产生用户使用这个类时，良好的一致性</li>
<li>private parameter可以产生封装的效果，封装使得变更更加容易</li>
<li>假如有一个public变量，如果取消它，所有使用它的客户代码都会被破坏<br>假如有一个protect变量，如果取笑它，所有使用它的derived class都会被破坏<br>所以protect并不比public更具有封装性</li>
</ul>
<h2 id="条款23，宁以non-member、non-friend替换member函数">条款23，宁以non-member、non-friend替换member函数</h2><ul>
<li>多个操作具有先后顺序，应该把他们绑定到一起</li>
<li>封装-&gt;客户端难修改-&gt;更多弹性去改变</li>
<li>non-member（non-friend）函数VSmember函数</li>
</ul>
<p>non-member函数不能访问private成分，提供更大的封装性</p>
<h2 id="条款24，若所有参数皆需类型转换，请为此采用non-member函数">条款24，若所有参数皆需类型转换，请为此采用non-member函数</h2><p>实现有理数类Rational，乘法的操作符重载<br>开始可能会向使用成员函数的写法 </p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp; rhs) <span class="keyword">const</span>
</code></pre><p>但是希望完成乘法交换律</p>
<pre><code><span class="type">Rational</span> r
<span class="type">Rational</span> <span class="literal">result</span> = <span class="number">2</span> * r
</code></pre><p>需要对2进行隐式类型转换，方法</p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs) 
</code></pre><p>使用non-member函数。</p>
<p>不是很明白</p>
<h2 id="条款25，考虑写出一个不抛出异常的swap函数">条款25，考虑写出一个不抛出异常的swap函数</h2><p>std::swap(T&amp; a, T&amp; b)可以对两个对象进行交换</p>
<p>如果这样做的效率不高，可以考虑自己写一个不会抛出异常的swap成员函数</p>
<p>例如：stl 容器中就有很多swap函数，只交换指针，而不会复制对象。</p>
<ol>
<li>自行实现这样一个swap成员函数(可以使用std::swap调换指针)</li>
<li>在命名空间内提供一个swap<widget>(Widget &amp;a,Widget &amp;b)去实现一个非成员函数来调用前者。</widget></li>
</ol>
<h2 id="条款26，尽可能延后变量定义式的出现时间">条款26，尽可能延后变量定义式的出现时间</h2><p>对变量进行定义，意味着承受构造的成本。</p>
<p>原则：应该延后变量定义到使用前的一刻为止。</p>
<h2 id="条款27，尽量少做转型动作">条款27，尽量少做转型动作</h2><p>C风格的转型</p>
<pre><code><span class="list">(<span class="keyword">int</span>)</span><span class="number">2.1</span>
int<span class="list">(<span class="number">2.1</span>)</span>
</code></pre><p>C++的新式转型：</p>
<ul>
<li><code>const_cast&lt;T&gt;(expression)</code> 将对象的常量性移除</li>
<li><code>dynamic_cast&lt;T&gt;(expression)</code> 主要用来进行安全向下转型<br>例如：只有基类可以使用，但是想调用子类的函数。尝试使用多态来代替。</li>
<li><code>static_cast&lt;T&gt;(expression)</code> 主要用来强制类型转换<br>例如：<code>static_cast&lt;int&gt;(2.1)</code><br>尽量使用C++风格的转型</li>
</ul>
<h2 id="条款28，避免返回handles指向对象内部成分">条款28，避免返回handles指向对象内部成分</h2><pre><code><span class="keyword">class</span> <span class="title">A</span>{
<span class="keyword">public</span>：
     <span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span>;
}
<span class="keyword">class</span> <span class="title">B</span>{
<span class="keyword">private</span>:
     A *a
}
</code></pre><p>如果在B类中提供<code>A&amp;</code>的返回（假设为rt），那么用户可以调用<code>rt.func()</code>修改B中的private成员了。<br>这是一种放松封装的行为。</p>
<h2 id="条款29，为“异常安全”而努力是值得的">条款29，为“异常安全”而努力是值得的</h2><p>异常安全的函数提供以下三个保证之一（从弱到强）：</p>
<ul>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下</li>
<li>强烈保证：函数调用成功，则完全成功。函数调用失败，则程序回复到调用之前的状态</li>
<li>nothrow：保证绝对不抛出异常。（通常完全使用内置类型的操作，提供不抛出异常的保证）<br>一个软件系统，要么具备异常安全性，要么不具备。只提供部分异常安全性函数，不能叫做具备异常安全性的系统。<br>以对象管理资源，是一种很好的防止内存泄露，保证异常安全性的方法。</li>
</ul>
<h2 id="条款30，透彻了解inlining的里里外外">条款30，透彻了解inlining的里里外外</h2><ul>
<li>inline函数意味着对这个函数的每一次调用，使用函数本体替换</li>
</ul>
<p>好处：减少调用成本</p>
<p>坏处：增加代码体积</p>
<ul>
<li>inline函数适合小型被频繁调用的函数</li>
</ul>
<p>函数内部有for循环不适合inline，因为本身的开销已经够大，减少调用的开销意义不大。</p>
<ul>
<li>inline只是一个向编译器发出的申请，编译器可以忽略它。</li>
</ul>
<p>如编译器拒绝复杂函数inline(带有递归，循环),virtual函数也会使inline落空。</p>
<h2 id="条款31，将文件间的编译依存关系降到最低">条款31，将文件间的编译依存关系降到最低</h2><p>方法1，使用Handle class</p>
<p>增加一个实现类去真正实现类的功能，原来的类只维护一个指向实现类的指针</p>
<p>方法2，使用Interface class</p>
<p>基类是虚基类，不包括任何成员变量。</p>
<h2 id="条款32，确定你的public继承是is-a的关系">条款32，确定你的public继承是is-a的关系</h2><p>如题</p>
<h2 id="条款33，避免遮掩继承而来的名称">条款33，避免遮掩继承而来的名称</h2><p>假如：Derived:Base</p>
<p>当编译器通过函数名称去找相应函数，会先从Derived类作用域找，然后再从Base类的作用域找<br>当使用函数重载的时候就可能出现问题。</p>
<p>使用using Base::func可以避免这种情况。 </p>
<h2 id="条款34，区分接口继承和实现继承">条款34，区分接口继承和实现继承</h2><ul>
<li>对于non-virtual函数的继承</li>
</ul>
<p>意味着，子类必须有和父类一样的实现</p>
<ul>
<li>对于virtual</li>
</ul>
<p>（1）pure-virtual, 只继承接口，意味着每个子类的行为都很有可能不一样</p>
<p>（2）imprure-virtual， 提供缺省的实现，意味着有一些子类的行为可能一样</p>
<p>可以使用pure-virtual+缺省行为分离(另外写一个函数)的方法，解决有可能子类在不知情的情况下继承了并不需要的缺省的实现。 </p>
<h2 id="条款35，考虑virtual函数以外的其他选择">条款35，考虑virtual函数以外的其他选择</h2><ul>
<li><p>NVI Non-virtual Interface<br>使用public non-virtual 函数调用private virtual函数(做一下修饰而已)</p>
</li>
<li><p>使用函数指针</p>
</li>
<li><p>使用tr1::function封装函数指针，代替函数指针的行为</p>
</li>
<li><p>使用strategy设计模式</p>
</li>
</ul>
<p>将想要virtual的行为封装成一个类(Calculator)，在类内部进行多态计算，通过传入的对象指针来判断。</p>
<h2 id="条款36，绝不重新定义继承而来的non-virtual函数">条款36，绝不重新定义继承而来的non-virtual函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{</span></span>
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
A *ptA=new B()
B *ptB=new B()
</code></pre><p>ptA-&gt;fun()调用A中的fun<br>ptB-&gt;fun()调用B中的fun<br>因为non-virtual函数不能进行动态绑定，调用函数只跟指针类型有关，所以</p>
<ol>
<li>不要重写父类的non-virtual函数</li>
<li>父类的non-virtual函数意味着，所有子类的实现都是这样</li>
</ol>
<h2 id="条款37，绝不重新定义进程而来的缺省参数值">条款37，绝不重新定义进程而来的缺省参数值</h2><p>缺省参数都是静态绑定的，即使是在virtual的函数中</p>
<h2 id="条款38，复合（组合）是has-a的关系">条款38，复合（组合）是has-a的关系</h2><h2 id="条款39，明智而审慎地使用private继承">条款39，明智而审慎地使用private继承</h2><p>private继承意味着所有父类的成员在子类中都变为private，</p>
<p>好处：可以让基类部分最优化，减少尺寸。</p>
<h2 id="条款40，明智而审慎地使用多重继承">条款40，明智而审慎地使用多重继承</h2><ul>
<li>一个class继承自多个base class，那么父类成分有相同函数，就需要显示指定。</li>
<li>对于钻石型继承，B:A,C:A,D:B,D:C，需要指定虚继承，来避免重复继承A中的成分</li>
<li>虚继承需要编译器做很多工作，要付出一定成本，一般不用。</li>
<li>如果有单一继承可以满足需求，一般这个方案一定比多重继承要好。</li>
</ul>
<h2 id="条款41，了解隐式接口和编译器多态">条款41，了解隐式接口和编译器多态</h2><ul>
<li><p>运行时多态，通过虚指针和虚函数实现</p>
</li>
<li><p>编译时多态</p>
</li>
</ul>
<p>(1) 函数重载，相同函数名不同参数列表</p>
<p>(2) 在模板特化的时候，根据类型生成具体的函数</p>
<h2 id="条款42，了解typename的双重意义">条款42，了解typename的双重意义</h2><pre><code><span class="keyword">template</span>&lt; class T&gt; class <span class="type">Widget</span>;
<span class="keyword">template</span>&lt;typename T&gt;class <span class="type">Widget</span>;
</code></pre><p>并没有什么不同</p>
<p>当使用嵌套从属名称，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename C&gt;
typename C::const_iterator iter(container.begin())
</code></pre><p>const_iterator是依赖于C的名称，这时候必须用typename</p>
<h2 id="条款43，学习处理模板化基类内的名称">条款43，学习处理模板化基类内的名称</h2><p>对于模板C++的继承，由于基类模板可能被特化，特化使得基类内的成员不确定，C++会拒绝从模板化基类中寻找继承而来的名称</p>
<p>解决办法：</p>
<ol>
<li>在使用base class之前使用this-&gt;</li>
<li>使用using</li>
</ol>
<h2 id="条款44，将与参数无关的代码抽离templates">条款44，将与参数无关的代码抽离templates</h2><p>使用带参template可能会引起代码膨胀，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename T,std:size_t n&gt;
</code></pre><p>解决办法：<br>使用模板父类去处理由于size_t而造成的代码膨胀的问题</p>
<h2 id="条款45，运用成员函数模板接受所有兼容类型的参数">条款45，运用成员函数模板接受所有兼容类型的参数</h2><ul>
<li>智能指针是使用模板实现的，那如果我们要智能指针之间（具有继承关系的）能够相互转化，赋值，解决办法：</li>
<li>使用成员函数模板，对兼容的类型进行构造和赋值</li>
</ul>
<h2 id="条款46，需要类型转换时请为模版定义非成员函数">条款46，需要类型转换时请为模版定义非成员函数</h2><pre><code><span class="type">Rational</span>&lt;<span class="type">int</span>&gt; a(<span class="number">1</span>,<span class="number">2</span>);
<span class="type">Rational</span>&lt;<span class="type">int</span>&gt; <span class="literal">result</span> = a*<span class="number">2</span>; // <span class="type">Error</span>
</code></pre><p>模板化实例，不进行隐式类型转换，使用friend方法。</p>
<h2 id="条款47，请使用traits_classes表现类型信息">条款47，请使用traits classes表现类型信息</h2><p>引用：</p>
<blockquote>
<p>traits class是个类模板，在不修改一个实体（通常是数据类型或常量）的前提下，把属性和方法关联到一个编译时的实体。在c++中的具体实现方式是：首先定义一个类模板，然后进行显式特化或进行相关类型的部分特化。<br>我的理解是：traits是服务于泛型编程的，其目的是让模板更加通用，同时把一些细节向普通的模板用户隐藏起来。当用不同的类型去实例化一个模板时，不可避免有些类型会存在一些与众不同的属性，若考虑这些特性的话，可能会导致形成的模板不够“泛型”或是过于繁琐，而traits的作用是把这些特殊属性隐藏起来，从而实现让模板更加通用。</p>
</blockquote>
<h2 id="条款48，认识template元编程">条款48，认识template元编程</h2><ul>
<li>模版元编程有两个效力：第一，它让某些事情更容易；第二，可将工作从运行期转移到编译期。</li>
<li>引用：<blockquote>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。</p>
</blockquote>
</li>
</ul>
<h2 id="条款49，了解new_handler的行为">条款49，了解new_handler的行为</h2><p>new_handler 的意思就是说，当使用operator new 无法分配内存时，转交给用户，用户来做一些事情。</p>
<h2 id="条款50，了解new和delete的合理替换时机">条款50，了解new和delete的合理替换时机</h2><p>有时候，我们替换掉编译器提供的new或者delete。重写operator new。三个常见理由：</p>
<ol>
<li>用来检测运用上的错误，超额分配一些内存，再额外的空间放置一些内存；</li>
<li>为了强化效能，编译器提供的new/delete是通用的，通用就意味着冗余和效率低下，为什么？这个很好理解，因为他要支持很多情况下，也必须考虑很多情况。我们重写new/delete，也就是说，对于特定情况，给出特定的实现。</li>
<li>为了收集使用上的统计数据。</li>
</ol>
<h2 id="条款51，编写new和delete时需固守常规">条款51，编写new和delete时需固守常规</h2><p>自定义new/delete的时候，需要遵守一些规则。</p>
<ol>
<li>循环申请，直到成功或者抛出异常</li>
<li>class专属版本处理，分配大小与class大小不一致的错误。</li>
<li>delete的时候，判断是否为null。</li>
</ol>
<h2 id="条款52，写了placement_new也要写placement_delete">条款52，写了placement new也要写placement delete</h2><h2 id="条款53，不要轻忽编译器的警告">条款53，不要轻忽编译器的警告</h2><h2 id="条款54，让自己熟悉包括TR1在内的标准程序库">条款54，让自己熟悉包括TR1在内的标准程序库</h2><p>C++11（原名C++0x）于2011年8月12日公布。<br>TR1是一份文档，由编译器实现，在std::tr1命名空间下<br>C++11纳入了大部分TR1的内容</p>
<h2 id="条款55，让自己熟悉Boost">条款55，让自己熟悉Boost</h2><p>Boost是一个社区，提供很多程序库，作为新的C++标准的试验场。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/"> #C++ </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/31/从图灵测试到图灵停机/">
                从图灵到图灵测试再到图灵停机
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-31
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/杂七杂八/">杂七杂八</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/31/从图灵测试到图灵停机/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/31/从图灵测试到图灵停机/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮助盟军破解德军密码系统Enigma的故事。图灵，这个计算机之父，影响着计算机技术发展的方方面面，计算机的最高奖图灵奖也是以他的名字命名的，没办法人家是祖师爷呀。</p>
<h2 id="图灵生平">图灵生平</h2><blockquote>
<p>阿兰·麦席森·图灵（Alan Mathison Turing），生于1912年6月23日，逝于1954年6月7日 ，被誉为“<strong>计算机科学之父</strong>”和“人工智能之父”。图灵和同事破译的情报，在盟军诺曼底登陆等重大军事行动中发挥了重要作用，图灵因此在1946年获得“不列颠帝国勋章”。历史学家认为，他让二战提早了2年结束，至少拯救了2000万人的生命 。<br>计算机逻辑的奠基者，提出了“图灵机”和“图灵测试”等重要概念。美国计算机协会（ACM）1966年设立的以其名命名的“<strong>图灵奖</strong>”是计算机界最负盛名和最崇高的一个奖项，有“计算机界的诺贝尔奖”之称。</p>
<p>1912年6月23日出生于英国帕丁顿，1931年进入剑桥大学国王学院，师从著名数学家哈代，1938年在美国普林斯顿大学取得博士学位，二战爆发后返回剑桥，曾经协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。</p>
<p>因图灵的同性恋倾向，他于1952年被起诉（这种行为在当时的英国仍属刑事犯罪）。 为了继续科研工作，他接受了治疗雌激素注射（ 化学阉割 ）代替牢狱之刑。 图灵于1954年6月7日去世（食用氰化物泡过的苹果中毒）， 勘验确定他的死亡是自杀。 英国女王伊丽莎白二世在2013年追授特赦。</p>
<p>阿兰·麦席森·图灵是一名世界级的长跑运动员。他的马拉松最好成绩是2小时46分3秒，比1948年奥林匹克运动会金牌成绩慢11分钟。1948年的一次跨国赛跑比赛中，他跑赢了同年奥运会银牌得主汤姆·理查兹（Tom Richards）。</p>
</blockquote>
<h2 id="图灵测试">图灵测试</h2><blockquote>
<p>如果一台机器能够与人类展开对话（通过电传设备）而不能被辨别出其机器身份，那么称这台机器具有智能。</p>
</blockquote>
<p>这也是《机械姬》这部电影讨论的核心所在。善良单纯的天才程序员被大Boss天才坑蒙拐骗参加设计的图灵测试，机器人ava通过利用程序员的同情心（程序员多么可怜），诱骗他完成了逃离实验基地的任务。最终是否通过测试不是由程序员判断的，而是由机器人能否骗到程序员决定的。多么精巧的设计！一个高智商的程序员，明知道很有可能被骗，但还是被骗了，这无疑是真正的人工智能。</p>
<p>最后实验失控，大Boss被AI杀死（预示着人类要灭亡么？），AI进入到人群之中。</p>
<p>这是一部好电影，但这篇文章不是一篇影评，就不赘述电影的细节了。</p>
<h2 id="图灵停机问题">图灵停机问题</h2><p>突然想起来本科离散数学提到的一个很有意思的问题，图灵停机问题（The Halting Problem））。描述如下：</p>
<blockquote>
<p>不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。</p>
</blockquote>
<p>精妙的是这个问题的证明过程。通过反证法可以证明这个命题。</p>
<p>假设我们某一天真做出了这么一个极度聪明的万能算法（就叫God_algo吧），你只要给它一段程序（二进制描述），再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束（停机），我们来编写一下我们的这个算法吧：</p>
<pre><code>bool God_algo(<span class="keyword">char</span>* <span class="keyword">program</span>, <span class="keyword">char</span>* <span class="keyword">input</span>)
{
    <span class="keyword">if</span>(&lt;<span class="keyword">program</span>&gt; halts <span class="keyword">on</span> &lt;<span class="keyword">input</span>&gt;)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> false;
}
</code></pre><p>这里我们假设if的判断语句里面是你天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在，我们从这个God_algo出发导出一个新的算法：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span><span class="params">(<span class="keyword">char</span>* program)</span>
</span>{
    <span class="keyword">if</span>( God_algo(program, program) )
    {
           <span class="keyword">while</span>(<span class="number">1</span>);        <span class="comment">// loop forever!</span>
           <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// can never get here!</span>
    }
    <span class="keyword">else</span>
       <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<pre><code>Satan_algo<span class="list">(<span class="keyword">Satan_algo</span>)</span><span class="comment">;</span>
</code></pre><p>我们来分析一下这行简单的调用：</p>
<ol>
<li><p>Satan_algo(Satan_algo)这个调用要么能够运行结束返回（停机），要么不能返回（loop forever）。</p>
</li>
<li><p>如果它能够结束，那么Santa_algo算法里面的那个if判断就会成立（因为God_algo(Santa_algo,Santa_algo)将会返回true），从而程序便进入那个包含一个无穷循环while(1);的if分支，于是这个Satan_algo(Satan_algo)调用便永远不会返回（结束）了。</p>
</li>
<li><p>如果不能结束（停机），则if判断就会失败，从而选择另一个if分支并返回true，即Satan_algo(Satan_algo)又能够返回（停机）。</p>
</li>
</ol>
<p>总之，我们有：</p>
<p>Satan_algo(Satan_algo)能够停机=&gt; 它不能停机</p>
<p>Satan_algo(Satan_algo)不能停机=&gt; 它能够停机</p>
<p>所以它停也不是，不停也不是，左右矛盾。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/26/linux命令sed和awk/">
                linux命令sed和awk
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/linux/">linux</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/26/linux命令sed和awk/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/linux命令sed和awk/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p>
<h3 id="常见应用">常见应用</h3><ol>
<li>抽区域</li>
<li>匹配正则表达式</li>
<li>比较域</li>
<li>增加，附加，替换</li>
</ol>
<h3 id="执行过程">执行过程</h3><p>sed一次处理一行或多行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行或多行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向或写入命令存储输出。</p>
<h3 id="调用方式">调用方式</h3><ul>
<li>命令行输入</li>
</ul>
<p>sed [选项] ‘sed命令’ 输入文件</p>
<ul>
<li>使用sed脚本<br>sed [选项] –f sed脚本文件 输入文件</li>
</ul>
<h3 id="常用选项">常用选项</h3><p>-n：不打印，不写编辑行到标准输出，缺省情况下打印所有行[编辑/未编辑]p命令可以打印编辑行</p>
<p>-c：下一命令是编辑命令，使用多项编辑时加入此选项</p>
<p>-f： 调用sed脚本 sed –f sedScriptFile targetFile</p>
<p>-i：将修改附加到源文件上</p>
<h3 id="使用技巧">使用技巧</h3><p>重定向sed结果输出<br>$sed ‘sed-command’ inputfile &gt; outputfile</p>
<p>定位内容的方式</p>
<p><code>x</code> 行x</p>
<p><code>x,y</code> 行x到行y</p>
<p><code>/pattern/</code> 模式</p>
<p><code>/pattern/pattern/</code> 两个模式</p>
<p><code>/pattern/,x</code>     模式+行【在给定行号上查询模式】</p>
<p><code>X,y</code> /pattern/ 通过行号和模式查询匹配行</p>
<p><code>X,y!</code> 不包含指定行号</p>
<h3 id="基本的sed命令">基本的sed命令</h3><p>P 打印匹配行 print</p>
<p>= 打印匹配行行号</p>
<p>a\ 定位行号后附加新文本信息 append</p>
<p>i\ 定位行号后插入   insert</p>
<p>d 删除定位行   delete</p>
<p>c\ 用新文本替换定位文本   change</p>
<p>s 使用替换模式替换相应模式 </p>
<p>r 从另一个文件中读文本  read</p>
<p>w 写文本到一个文件   write</p>
<p>q 第一个模式匹配完成后退出或立即退出</p>
<p>{} 定位执行命令组</p>
<p>n 从另一个文件中读文本下一行，并附加在下一行</p>
<p>g 将模式2黏贴到/pattern n/</p>
<p>y 传送字符</p>
<h3 id="实例：">实例：</h3><ul>
<li>显示文本</li>
</ul>
<p><code>$sed -n &#39;1,4p&#39; file</code></p>
<p>显示1-4行</p>
<p><code>$sed -n &#39;4,/Str/p&#39;</code></p>
<p>显示第4行到匹配到Str的一行，/str/代表匹配到的一行</p>
<ul>
<li>插入修改文本</li>
</ul>
<p><code>$sed &#39;/str/a\ &quot;inserted line&quot;&#39; file</code></p>
<p>在满足条件的行后，插入内容</p>
<p><code>sed &#39;/str/i\ &quot;appended line&quot;&#39; file</code></p>
<p>在满足条件的行前插入内容</p>
<p><code>$sed &#39;3 c\ &quot;changed line&quot;&#39; file</code></p>
<p>满足条件的行，整行替换掉</p>
<ul>
<li>删除文本</li>
</ul>
<p><code>$sed &#39;1,3d&#39; file</code></p>
<p>删除1-3行</p>
<p><code>$sed &#39;/str/d&#39; file</code></p>
<p>删除匹配行</p>
<p><code>$sed -n &#39;/Begin/,/End/p&#39; file | more</code></p>
<p>删除两个匹配行之间的数据</p>
<ul>
<li>替换文本</li>
</ul>
<p>格式：<code>[address[,address]] s/pattern-find/replacement-pattern/[g,p,w,n]</code></p>
<p>n    1到512之间的一个数字，表示对本模式中指定模式第n次出现的情况进行替换。</p>
<p>g    对模式空间所有出现的情况进行全局更改【缺省只替换首次出现的模式 】</p>
<p>p    打印模式空间的内容</p>
<p>w    file</p>
<p><code>$sed &#39;s/str/tostr/&#39; file</code> </p>
<p>替换每一行首次出现的str为tostr</p>
<p><code>$sed &#39;s/str/tostr/g&#39; file</code></p>
<p>替换所有的行内，出现的所有str为tostr</p>
<p><code>$sed &#39;s/str/tostr/w output&#39; file</code></p>
<p>替换后重定向到output</p>
<p>转换字符</p>
<p><code>sed &#39;y/cp/wd/&#39; test.txt</code></p>
<p>c转换成w，p转换成d</p>
<ul>
<li>Shell向sed传值</li>
</ul>
<p><code>echo $input | sed &#39;s/bb/&#39;$str&#39;/&#39;</code></p>
<p><code>echo $input | sed &quot;s/bb/$str/&quot;</code></p>
<h2 id="awk">awk</h2><h3 id="主要功能-1">主要功能</h3><p>awk是一种用于处理文本的工具，主要用于格式化报文，或从一个大文本中抽取数据。</p>
<h3 id="执行过程-1">执行过程</h3><p>awk每次读入一行，执行’ ‘中的内容，按模式匹配来采取动作</p>
<h3 id="格式">格式</h3><p><code>awk &#39;pattern+{action}&#39; file</code></p>
<p>pattern用于筛选查询匹配行，决定了动作何时触发，可以使用条件语句，正则表达式</p>
<p>action用于对筛选后的内容进行处理</p>
<p>BEGIN可以设置计数和打印头（可选）</p>
<p>END打印输出文本总数和结尾状态标识(可选)</p>
<h3 id="常用参数">常用参数</h3><p>-F 指定读取一行数据的分隔符，默认为空格<br>-f 指定处理程序的脚本文件，这个文件必须符合awk语法</p>
<h3 id="调用方式：">调用方式：</h3><p><code>awk –f awk-script-file input-files</code></p>
<h3 id="常用内置参数">常用内置参数</h3><p><code>$0,$1,....$n</code>   <code>$0</code>代表当前行的内容，<code>$i</code>代表当前行被分割后的第i个字段的内容</p>
<p>ARGC 命令行参数个数</p>
<p>ARGV 命令行参数排列</p>
<p>ENVIRON 支持队列中系统环境变量的使用</p>
<p>FILENAME 实际操作的文件名</p>
<p>FNR 浏览文件记录数，&lt;=NR</p>
<p>FS <strong>设置输入域分隔符，等价于命令行-F选项</strong> ，可在BEGIN中进行设置,然后执行的时候均以设置的符号为分隔符</p>
<p>NF <strong>浏览记录 域的个数</strong>，在记录被读取时设置【number of fields】一共有多少个域</p>
<p>NR <strong>已读取记录数</strong>【number of rows】</p>
<p>RS 控制记录分隔符，缺省：新行\n，Row Separator记录分隔符，可以根据具体数据需求，设置读取一条记录的区间</p>
<p>OFS <strong>输出域的分隔符</strong>，缺省空格，输出结果 print $1,$2默认加的是空格，可以在BEGIN中设置，改为其他分隔符</p>
<p>ORS 输出记录的分隔符，缺省：新行\n，整体记录的</p>
<h3 id="实例">实例</h3><ul>
<li>打印</li>
</ul>
<p>打印所有行</p>
<p><code>awk &#39;{print $0}&#39; file</code></p>
<p>打印包含头尾</p>
<p><code>awk &#39;BEGIN{print &quot;Name Age&quot;}{print $1,$2}END{print &quot;END_OF_REPORT&quot;}&#39;</code></p>
<ul>
<li>使用判断语句</li>
</ul>
<p><code>&lt;  &lt;=  &gt;  &gt;=  ==  !=</code>  </p>
<p>~匹配正则   !~不匹配正则</p>
<p><code>|| &amp;&amp; !</code> 或且非</p>
<p><code>awk &#39;{if($2!~/Rudy/) print $0}&#39; content</code></p>
<p><code>awk &#39;{if($1==&quot;001&quot; &amp;&amp; $2~/^Ru/) print $0}&#39; content</code></p>
<ul>
<li>使用内置的变量 </li>
</ul>
<p><code>awk &#39;BEGIN{OFS=&#39;\t&#39;}{print NF,NR,$0}END{print FILENAME}&#39; content &gt; output</code></p>
<p>设置输出的分隔符为’\t’，输出一些内置变量的信息</p>
<ul>
<li>AWK变量中的字符串和数字的转换</li>
</ul>
<p>字符串-&gt;整数</p>
<p><code>$ awk &#39;BEGIN{a=&quot;100&quot;;b=&quot;10test10&quot;;print (a+b+0);}&#39;</code></p>
<p><code>110</code></p>
<p>只需要将变量通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。</p>
<p>整数-&gt;字符串</p>
<p><code>awk &#39;BEGIN{a=100;b=100;c=(a&quot;&quot;b);print c}&#39;</code>      </p>
<p><code>100100</code></p>
<p>只需要将变量与””符号连接起来运算即可。</p>
<ul>
<li>使用内置的字符串函数</li>
</ul>
<p><code>gsub(r,s)</code> 在整个$0中<strong>用s代替r</strong></p>
<p><code>gsub(r,s,t)</code> 在整个t中用s替代r</p>
<p><code>index(s,t)</code> 返回s中字符串t的第一位置</p>
<p><code>length(s)</code> <strong>返回s长度</strong></p>
<p><code>match(s,r)</code> 测试s是否包含匹配r的字符串</p>
<p><code>split(s,a,fs)</code> 在fs上将s分成序列a.fs为分隔符</p>
<p><code>sprint(fmt,exp)</code> 返回经fmt格式化后的exp</p>
<p><code>sub(r,s)</code> 用$0中最左边最长的子串代替s</p>
<p><code>substr(s,p)</code> 返回字符串s中从p开始的后缀部分</p>
<p><code>substr(s,p,n)</code> 返回字符串s中从p开始长度为n的后缀部分</p>
<p>替换字符串</p>
<p><code>awk &#39;BEGIN{FS=&#39;\t&#39;}{gsub(/Rudy/,&quot;RUDY&quot;);{print $0}}&#39; content</code></p>
<ul>
<li>使用printf进行格式化输出</li>
</ul>
<p><code>%c</code> ASCII字符</p>
<p><code>%d</code> 整数</p>
<p><code>%e</code> 浮点数，可科学计数法</p>
<p><code>%f</code> 浮点数，小数形式</p>
<p><code>%g</code> 由awk决定使用哪种浮点数转换e或f</p>
<p><code>%o</code> 八进制</p>
<p><code>%s</code> 字符串</p>
<p><code>%x</code> 十六进制</p>
<p>格式化输出一个字符串</p>
<p><code>awk -F&#39;\t&#39; &#39;{printf(&quot;%s\t%s\n&quot;,$2,$1)}&#39; content</code></p>
<ul>
<li>向awk中传递参数</li>
</ul>
<p><code>awk &#39;{if($3&lt;=AGE){print $0}}&#39; AGE=20 content</code> </p>
<ul>
<li><p>写一个awk脚本</p>
<pre><code><span class="comment">#!bin/awk -f</span>
BEGIN{
        FS=<span class="string">"['\t']"</span>
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="string">"NUMBER"</span>,<span class="string">"NAME"</span>,<span class="string">"AGE"</span>)
}
{
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)
}
END{
        <span class="keyword">print</span> <span class="string">"END OF FILE"</span>
}
</code></pre></li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux命令/"> #linux命令 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/26/linux正则表达式和grep/">
                linux正则表达式和grep
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-25
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/linux/">linux</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/26/linux正则表达式和grep/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/26/linux正则表达式和grep/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk: 伪装成实用程序的强大编程语言，主要用于文本处理</li>
</ul>
<h3 id="常用符号">常用符号</h3><h4 id="基本元字符">基本元字符</h4><p><code>^</code> 行首定位符，表示以..开始</p>
<p><code>$</code> 行尾定位符，表示以..结束</p>
<p><code>.</code>  匹配单个字符</p>
<p><code>*</code> 匹配0个或任意多个字符</p>
<p><code>[]</code> 匹配[]中出现字符范围内的一个字符</p>
<p><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h4 id="扩展元字符">扩展元字符</h4><p><code>?</code> 匹配0个或者1个</p>
<p><code>+</code> 匹配1个或者多个</p>
<p><code>|</code> 或者</p>
<p><code>()</code>分组符号</p>
<h4 id="特殊匹配字符">特殊匹配字符</h4><p><code>[:alnum:]</code> 字母与数字字符</p>
<p><code>[:alpha:]</code> 字母</p>
<p><code>[:ascii:]</code> ASCII字符</p>
<p><code>[:blank:]</code> <strong>空格或制表符</strong></p>
<p><code>[:cntrl:]</code> ASCII控制字符</p>
<p><code>[:digit:]</code> 数字</p>
<p><code>[:graph:]</code> 非控制、空格字符</p>
<p><code>[:lower:]</code> 小写字母</p>
<p><code>[:print:]</code> 可打印字符</p>
<p><code>[:punct:]</code> 标点符号字符</p>
<p><code>[:space:]</code> <strong>空白字符，包括垂直制表符</strong></p>
<p><code>[:upper:]</code> 大写字母</p>
<p><code>[:xdigit:]</code> 十六进制数字</p>
<h3 id="实例">实例</h3><ul>
<li>^ $<br><code>ls -l | grep ^d</code></li>
</ul>
<p>匹配以d开头的所有内容</p>
<ul>
<li><code>ls -l | grep d$</code></li>
</ul>
<p>匹配以d结束的所有内容</p>
<ul>
<li><code>^$</code> </li>
</ul>
<p>匹配空行</p>
<ul>
<li><code>^.$</code></li>
</ul>
<p>只包含一个字符的</p>
<ul>
<li><code>* ？ +</code></li>
</ul>
<p><code>compu*ter</code> 匹配u，重复0次或多次</p>
<p><code>compu?ter</code> 匹配0个或者1个u</p>
<p><code>compu+ter</code> 匹配1个或多个u</p>
<p><strong>需要注意的是+和？是扩展字符，需要看具体使用正则表达式的环境<br>如果使用grep需要使用-E指定为扩展模式才能正常使用+和？</strong></p>
<ul>
<li><code>\</code>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
</ul>
<p><code>\.pass</code>  匹配<code>*.pass</code></p>
<ul>
<li><code>[]</code></li>
</ul>
<p><code>[1234]</code> 匹配1,2,3,4中的一个</p>
<p><code>[1-9]</code> 数字1-9中的一个</p>
<p><code>[A-Za-z]</code> 所有字母</p>
<p><code>[^0-9]</code> 一个非数字的字符</p>
<ul>
<li><code>\{\}</code></li>
</ul>
<p><code>A\{2\}B</code>   匹配AAB</p>
<p><code>A\{4,\}B</code>   匹配A出现至少4次B</p>
<p><code>A\{2,4\}B</code>  匹配A出现在2至4次之间</p>
<h2 id="grep">grep</h2><p>功能：grep是文本搜索工具，使用正则表达式搜索文本并打印匹配行</p>
<p>格式：<code>grep [options] PATTERN [Files]</code></p>
<p>注：</p>
<p>输入字符串<strong>作为参数，最好双引号括起</strong>  “mystr”</p>
<p>在<strong>调用变量时，也使用双引号括起</strong>  “$MYSTR”</p>
<p>使用<strong>正则[匹配模式]是，应使用单引号括起</strong>  ‘49[32]’</p>
<p>常用选项：</p>
<p><code>-c</code> 只输出匹配的行数,而不输出匹配的行</p>
<p><code>-i</code> 不区分大小写</p>
<p><code>-n</code> 显示匹配行及行号</p>
<p><code>-q</code>  安静模式，不输出任何东西，如果找到了返回0</p>
<p><code>-E</code> 启用扩展表达式，可使用扩展字符，如：+ ? | () {} , 或者直接使用egrep</p>
<p><code>-v</code> 显示不包含匹配文本的所有行</p>
<p>实例：</p>
<ol>
<li><p>在多个文件中查找<br><code>grep “sort” filea fileb</code>  在filea,fileb中查找</p>
</li>
<li><p>计算匹配行数<br><code>grep -c &quot;sort&quot; file</code></p>
</li>
<li><p>使用正则表达式查找<br><code>grep &#39;48[34]&#39; file</code></p>
</li>
<li><p>使用扩展元字符<br><code>grep -E &#39;aaa|bbb&#39; file</code></p>
</li>
<li><p>匹配空行<br><code>grep &#39;^$&#39; file</code></p>
</li>
<li><p>特殊匹配字符，grep 允许使用国际字符串模式匹配或匹配模式的类名<br><code>grep ‘5[[:upper:]] [[:upper:]]’</code> data  5开头，两个大写</p>
</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux命令/"> #linux命令 </a>
          
            <a href="/tags/正则表达式/"> #正则表达式 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/24/HadoopStreaming/">
                Hadoop Streaming学习文档
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/Hadoop/">Hadoop</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/24/HadoopStreaming/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/24/HadoopStreaming/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架允许任何程序语言实现的程序（只要该程序支持标准输入输出即可），在Hadoop MapReduce中使用，方便已有程序向Hadoop平台移植。</p>
<h2 id="Streaming原理">Streaming原理</h2><p>使用Java实现了一个包装<strong>用户程序</strong>（mapper，reducer方法）的MapReduce程序，该程序调用MapReduce的Java接口，创建一个<strong>新的进程</strong>包装用户程序，将数据通过<strong>管道</strong>传递给包装的用户程序。</p>
<p><img src="http://i.imgur.com/dlebclb.jpg" alt=""></p>
<h2 id="考虑的问题">考虑的问题</h2><p>在实际的开发过程中，开发人员需要考虑下面几个方面的问题，其中1,2是必须实现的：</p>
<ol>
<li>Mapper程序：对输入key/value数据进行处理；</li>
<li>Reducer程序：对mapper的输出进行归并处理；</li>
<li>Combiner：在本地对一个计算节点上的mapper输出进行归并；</li>
<li>Partitioner：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li>InputFormat/OutputFormat：对输入数据进行切分，保存输出数据。</li>
</ol>
<h2 id="执行">执行</h2><pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “cat” \
    -reducer “cat” \
    -jobconf mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">1</span>\
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”dist-sort”
</code></pre><p>这是一个实现了分布式排序的程序。可以通过shell脚本，shell命令，或者其它语言的<strong>可执行程序</strong>来进行mapper和reducer程序的运行</p>
<h2 id="常用参数的使用">常用参数的使用</h2><p>例1：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">2</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"Python/bin/python $app/mapper.py"</span> \
    -reducer <span class="string">"Python/bin/python $app/reducer.py"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archive</span>
</code></pre><p>-D表示配置参数，剩余项是和输入输出相关的文件和可执行程序</p>
<p><code>-D mapred.job.name=&quot;jobname&quot; \</code>,作业名</p>
<p><code>-D mapred.job.priority=VERY_HIGH \</code> 作业优先级</p>
<p><code>-D mapred.job.map.capacity=500 \</code>,最多同时运行map任务数</p>
<p><code>-D mapred.job.reduce.capacity=300 \</code>最多同时运行reduce任务数</p>
<p><code>-D mapred.map.tasks=500 \</code>,map任务个数</p>
<p><code>-D mapred.reduce.tasks=300 \</code>,reduce任务个数</p>
<p>capacity是同时运行任务的个数，tasks是运行任务的总的个数，一般task更大，capacity是同时运行任务的上限</p>
<p><code>-D stream.num.map.output.key.fields=2 \</code>,表示在第2个分隔符（默认为\t）之前作为key，之后作为value，也可以使用参数<code>-D stream.map.output.field.separator=. \</code>指定分隔符为’.’或者其它字符。</p>
<p><code>-mapper &quot;Python/bin/python $app/mapper.py&quot; \</code>指定map任务，需要可执行，读入标准输入流，输出标准输出流</p>
<p><code>-reducer &quot;Python/bin/python $app/reducer.py&quot; \</code>指定reducer任务</p>
<p><code>-input $input \</code>指定输入文件</p>
<p><code>-output $output \</code>指定输出文件</p>
<p><code>-cacheArchive $archive</code>分发压缩包。<code>$archive</code>格式为<code>hdfs://host:port/path/to/archivefile#linkname</code>，表示hdfs上这个压缩包的路径为<code>hdfs://host:port/path/to/archivefile</code>,可以使用<code>linkname/children/path</code>访问这个压缩包的内容</p>
<p>例2：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">3</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.partitioner</span><span class="class">.options</span>=<span class="string">"-k1,1"</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.comparator</span><span class="class">.options</span>=<span class="string">"-k1,1 -k3,3nr"</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"cat"</span> \
    -reducer <span class="string">"cat"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archives</span>
</code></pre><p><code>-D mapred.text.key.partitioner.options=&quot;-k1,1&quot; \</code>表示对key进行分割，分割符默认为\t，取分割后的1,1部分作为主key，剩下的作为辅key</p>
<p><code>-D mapred.text.key.comparator.options=&quot;-k1,1 -k3,3nr&quot; \</code>指定排序依据，主key按第一部分排字母序，辅key按第三部分数字序倒序排</p>
<p>例3：</p>
<pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -D stream<span class="class">.map</span><span class="class">.output</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">4</span> \
    -D map<span class="class">.output</span><span class="class">.key</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D num<span class="class">.key</span><span class="class">.fields</span><span class="class">.for</span><span class="class">.partition</span>=<span class="number">2</span> \ 
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “mymapper.sh” -reducer “ myreducer.sh” \
    -partitioner org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.lib</span><span class="class">.KeyFieldBasedPartitioner</span> \
    -file /home/work/mymapper<span class="class">.sh</span> \
    -file /home/work/myreducer<span class="class">.sh</span> \
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”jobname”
</code></pre><p><code>-D stream.map.output.field.separator=. \</code><br><code>-D stream.num.map.output.key.fields=4 \</code><br>表示输出分隔符为’.’，并且第4个.之后为value，之前为key</p>
<p><code>-D map.output.key.field.separator=. \</code><br><code>-D num.key.fields.for.partition=2 \</code><br>表示key内的分隔符为’.’，第2个’.’之前作为主key，之后作为辅key</p>
<p><code>-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner \</code>指定要使用KeyFieldBasedPartitioner，也就是key域内的partioner。这样的话会把主key的内容作为partition的依据，相同的主key分配到同一个reducer中。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hadoop/"> #Hadoop </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/23/Hadoop基本原理/">
                Hadoop基本原理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-05-23
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/Hadoop/">Hadoop</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/23/Hadoop基本原理/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/23/Hadoop基本原理/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据处理速度快（Velocity） 数据真实性高（Veracity） 合起来被称为4V。</p>
<p>处理大数据是为了挖掘数据中的隐含价值</p>
<h4 id="如何处理大数据？">如何处理大数据？</h4><p>集中式计算VS分布式计算</p>
<p>集中式计算：通过不断增加处理器的个数来增强耽搁计算机的计算能力，从而提高处理的速度。需要的内存很大，计算的速度很快。</p>
<p>分布式计算：一组通过网络连接的计算机，形成一个分散的系统。将需要处理的大量数据分散成多个部分，交由系统中的耽搁计算机分别处理，最后将这些计算结果合并得到最终结果。（MapReduce的核心思想）</p>
<h3 id="Hadoop是怎么产生的">Hadoop是怎么产生的</h3><h4 id="技术基础">技术基础</h4><p>google三驾马车：GFS、MapReduce和BigTable。Hadoop是在google三驾马车基础上的开源实现。</p>
<ol>
<li>GFS（Google File System）分布式文件系统，对应Hadoop当中的HDFS。</li>
<li>MapReduce分布式计算框架，也是Hadoop处理大数据的核心思想。</li>
<li>BigTable是基于GFS的数据存储系统，对应Hadoop的HBase。</li>
</ol>
<h4 id="三大分布式计算系统">三大分布式计算系统</h4><p>Hadoop，Spark，Storm是主流的三大分布式计算系统</p>
<p>Spark VS Hadoop</p>
<p>Hadoop使用硬盘来存储数据，而Spark是将数据存在内存中的，因此Spark何以提供超过Hadoop 100倍的计算速度。内存断电后会丢失，所以Spark不<br>适用于需要长期保存的数据。</p>
<p>Storm VS Hadoop</p>
<p>Storm在Hadoop基础上提供了实时运算的特性，可以实时处理大数据流。不同于Hadoop和Spark，Storm不尽兴数据的手机和存储工作，直接通过网络接受并实时处理数据，然后直接通过网络实时传回结果。</p>
<p>所以三者适用于的应用场景分别为：</p>
<ol>
<li>Hadoop常用于离线的复杂的大数据处理</li>
<li>Spark常用于离线的快速的大数据处理</li>
<li>Storm常用于在线实时的大数据处理</li>
</ol>
<h3 id="Hadoop定义">Hadoop定义</h3><h4 id="Hadoop是什么">Hadoop是什么</h4><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架</p>
<h4 id="Hadoop特点">Hadoop特点</h4><ol>
<li>可靠。Hadoop假设计算元素和存储会失败，所以会维护多个工作数据的副本，对失败的节点会重新处理</li>
<li>高效。通过并行方式工作，加快处理速度。</li>
<li>可伸缩。可以处理PB级的数据。</li>
<li>高扩展。可以方便地扩展到数以千计的节点。</li>
<li>低成本。Hadoop是开源的，Hadoop节点可以是很便宜的机器。</li>
</ol>
<h4 id="应用场景">应用场景</h4><p>Hadoop适用于：海量数据，离线数据，复杂数据</p>
<p>场景1：数据分析，如海量日志分析，商品推荐，用户行为分析</p>
<p>场景2：离线计算，（异构计算+分布式计算）天文计算</p>
<p>场景3：海量数据存储，如Facebook的存储集群。</p>
<p><a href="http://cloud.zol.com.cn/441/4415033_all.html" target="_blank" rel="external">更多应用场景</a></p>
<h3 id="Hadoop原理">Hadoop原理</h3><h4 id="HDFS">HDFS</h4><p>HDFS（Hadoop File System），是Hadoop的分布式文件存储系统</p>
<ol>
<li>将大文件分解为多个Block，每个Block保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。</li>
<li>默认每个Block保存3个副本，64M为1个Block。</li>
<li>将Block按照key-value映射到内存当中。</li>
</ol>
<p>HDFS架构图如下：</p>
<p><img src="http://i.imgur.com/ZliSEXb.png" alt=""></p>
<h5 id="NameNode">NameNode</h5><p>HDFS使用主从结构，NameNode是Master节点，是领导。所有的客户端的读写请求，都需要首先请求NameNode。</p>
<p>NameNode存储</p>
<ol>
<li>fsimage：元数据镜像文件（文件系统的目录树，文件的<strong>元数据</strong>信息）。元数据信息包括文件的信息，文件对应的block信息（版本信息，类型信息，和checksum），以及每一个block所在的DataNode的信息。</li>
<li>edits：元数据的操作日志</li>
</ol>
<h5 id="DataNode">DataNode</h5><p>DataNode是Slave，负责真正存储所有的block内容，以及数据块的读写操作</p>
<p>NameNode，DataNode，rack只是一些逻辑上的概念。NameNode和DataNode可能是一台机器也可能是，相邻的一台机器，很多DataNode可能处于同一台机器。rack是逻辑上比DataNode更大的概念，可能是一台机器，一台机柜，也可能是一个机房。通过使文件的备份更广泛地分布到不同的rack，DataNode上可以保证数据的可靠性。</p>
<h5 id="HDFS写入数据">HDFS写入数据</h5><ol>
<li>Client拆分文件为64M一块。</li>
<li>Client向NameNode发送写数据请求。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode。</li>
<li>Client向DataNode发送block1,2,3….；发送过程是以流式写入。流式写入，数据流向为DataNode1-&gt;DataNode2-&gt;DataNode3(1,2,3为通过规则选出来的可用的DataNode)</li>
<li>发送完毕后告知NameNode</li>
<li>NameNode告知Client发送完成</li>
</ol>
<p>在写数据的时候：</p>
<ul>
<li>写1T文件，我们需要3T的存储，3T的网络流量贷款。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ul>
<h5 id="HDFS读取数据">HDFS读取数据</h5><ol>
<li>Client向NameNode发送读请求</li>
<li>NameNode查看MetaData信息，返回文件的block位置</li>
<li>根据一定规则（优先选择附近的数据），按顺序读取block</li>
</ol>
<p><a href="http://www.weixuehao.com/archives/596" target="_blank" rel="external">更多内容</a></p>
<h4 id="MapReduce">MapReduce</h4><p>Map是把一组数据一对一的<strong>映射</strong>为另外的一组数据，其映射的规则由一个<strong>map函数</strong>来指定。Reduce是对一组数据进行<strong>归约</strong>，这个归约的规则由一个<strong>reduce函数</strong>指定。</p>
<p>整个的MapReduce执行过程可以表示为：</p>
<p><code>(input)&lt;k1, v1&gt; =&gt; map =&gt; &lt;k2, v2&gt; =&gt; combine =&gt; &lt;k2, v2’&gt; =&gt; reduce =&gt; &lt;k3, v3&gt;(output)</code></p>
<p>也可以表示为流程图：</p>
<p><img src="http://i.imgur.com/yRsLgoK.png" alt=""></p>
<ol>
<li><strong>分割</strong>：把输入数据分割成不相关的若干键/值对（key1/value1）集合，作为input</li>
<li><strong>映射</strong>：这些键/值对会由多个map任务来<strong>并行地处理</strong>。输出一些中间键/值对key2/value2集合</li>
<li><strong>排序</strong>：MapReduce会对map的输出（key2/value2）按照key2进行排序（便于归并）</li>
<li><strong>conbine</strong>：属于同一个key2的所有value2组合在一起作为reduce任务的输入（相当于提前reduce，减小key2的数量，减小reduce的负担）</li>
<li><strong>Partition</strong>：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li><strong>规约</strong>：由reduce任务计算出最终结果并输出key3/value3。</li>
</ol>
<h4 id="程序员需要做的">程序员需要做的</h4><ul>
<li>单机程序需要处理数据读取和写入、数据处理</li>
<li>Hadoop程序需要实现map和reduce函数</li>
<li>map和reduce之间的数据传输、排序，容错处理等由Hadoop MapReduce和HDFS自动完成。</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hadoop/"> #Hadoop </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">42</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
