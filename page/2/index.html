<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Rudy" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?Rudy-Zhang";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Rudy's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Rudy's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-递归专题/">
                递归
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-递归专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-递归专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>递归的本质是图的深度优先遍历</p>
<h3 id="剑指offer11_数值的整数次方">剑指offer11 数值的整数次方</h3><h4 id="问题描述">问题描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h4 id="解法">解法</h4><p>求a的b次方</p>
<ul>
<li>如果b是奇数，result=a*a^(b-1)</li>
<li>如果b是偶数，temp=a^(b/2),result=temp*temp</li>
</ul>
<p>避免多次乘法。</p>
<h4 id="注意点">注意点</h4><ul>
<li>判断输入数据是否合法，0的负数次方不合法，0的0次方返回1.0</li>
<li>浮点数相等的判断</li>
<li><p>负数次方转化为整数次方</p>
<h4 id="代码">代码</h4><p>  class Solution {<br>  public:</p>
<pre><code><span class="keyword">bool</span> invalidInput=<span class="keyword">false</span>;
<span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>) </span>{
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>)
    {
        invalidInput = <span class="keyword">true</span>;
        <span class="keyword">return</span> <span class="number">0.0</span>;
    }
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>, <span class="number">0.0</span>) &amp;&amp; exponent == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1.0</span>;
    <span class="keyword">if</span>(doubleEqual(<span class="keyword">base</span>,<span class="number">0.0</span>))
        <span class="keyword">return</span> <span class="number">0.0</span>;
    <span class="keyword">int</span> absExponent;
    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)
        absExponent =- exponent;
    <span class="keyword">else</span>
        absExponent = exponent;

    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, absExponent);
    <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)
        <span class="keyword">return</span> temp;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">1.0</span> / temp;
}

<span class="function"><span class="keyword">double</span> <span class="title">powerPositive</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exp</span>)
</span>{
    <span class="keyword">if</span>(exp == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">if</span>(exp == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">base</span>;
    <span class="keyword">double</span> temp = powerPositive(<span class="keyword">base</span>, exp &gt;&gt; <span class="number">1</span>);
    <span class="keyword">if</span>((exp&amp;<span class="number">1</span>) == <span class="number">1</span>)
        <span class="keyword">return</span> temp * temp * <span class="keyword">base</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> temp * temp;

}

<span class="function"><span class="keyword">bool</span> <span class="title">doubleEqual</span>(<span class="params"><span class="keyword">double</span> a, <span class="keyword">double</span> b</span>)
</span>{
    <span class="keyword">if</span>(a - b &gt; -<span class="number">0.0000001</span> &amp;&amp; a - b &lt; <span class="number">0.0000001</span>)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><p>  };</p>
</li>
</ul>
<h3 id="全排列问题（剑指offer_28_字符串的全排列）">全排列问题（剑指offer 28 字符串的全排列）</h3><h4 id="问题描述-1">问题描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。</p>
<h4 id="解法-1">解法</h4><p>使用递归进行深度优先遍历，可以画出递归树，然后对这个树（图）进行深度优先遍历。递归函数表示当前位置的元素(index)和之后(包括自己)的元素进行交换。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>元素交换后还需要换回来</li>
<li>排列的序列中如果有重复元素需要判断。</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
  vector&lt;string&gt; Permutation(string <span class="keyword">str</span>) {
    vector&lt;string&gt; vec;
    <span class="keyword">if</span>(<span class="keyword">str</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> vec;
    PermutationR(<span class="keyword">str</span>,<span class="number">0</span>,vec);
    sort(vec.begin(),vec.end());
    <span class="keyword">return</span> vec;
  }

    <span class="keyword">void</span> PermutationR(string&amp; <span class="keyword">str</span>, <span class="keyword">int</span> <span class="keyword">index</span>, vector&lt;string&gt;&amp; vec)
    {
        <span class="keyword">if</span>(<span class="keyword">index</span> == <span class="keyword">str</span>.size() - <span class="number">1</span>)
            vec.push_back(<span class="keyword">str</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">index</span>; i &lt; <span class="keyword">str</span>.size(); i++)
        {
            <span class="keyword">if</span>(i != <span class="keyword">index</span> &amp;&amp; <span class="keyword">str</span>[<span class="keyword">index</span>] == <span class="keyword">str</span>[i]) 
                <span class="keyword">continue</span>;
            <span class="keyword">char</span> temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
            PermutationR(<span class="keyword">str</span>, <span class="keyword">index</span> + <span class="number">1</span>, vec); 
            temp = <span class="keyword">str</span>[<span class="keyword">index</span>];
            <span class="keyword">str</span>[<span class="keyword">index</span>] = <span class="keyword">str</span>[i];
            <span class="keyword">str</span>[i] = temp;
        }
    }
};
</code></pre><h2 id="子集问题">子集问题</h2><h3 id="Leetcode_78_Subset">Leetcode 78 Subset</h3><h4 id="问题描述-2">问题描述</h4><p>给定一个集合，生成这个集合的所有子集</p>
<h4 id="解法-2">解法</h4><p>遍历数组中的元素，每个元素有出现和不出现两种情况，然后递归考虑后一个元素。</p>
<h4 id="代码-2">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; subsets(vector&lt;<span class="type">int</span>&gt;&amp; nums) {
        sort(nums.begin(), nums.<span class="keyword">end</span>());
        vector&lt;<span class="type">int</span>&gt; vec;
        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
        genSubset(vec, <span class="literal">result</span>, <span class="number">0</span>, nums);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }

    <span class="type">void</span> genSubset(vector&lt;<span class="type">int</span>&gt;&amp; vec, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; <span class="literal">result</span>, <span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt; nums)
    {
        <span class="literal">result</span>.push_back(vec);
        <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; nums.size(); i++)
        {
            vec.push_back(nums[i]);
            genSubset(vec, <span class="literal">result</span>, i + <span class="number">1</span>, nums);
            vec.pop_back();
        }
    }
};
</code></pre><h3 id="拓展：子集和问题">拓展：子集和问题</h3><h4 id="问题描述-3">问题描述</h4><p>子集和问题的一个实例为〈S,t〉。其中，S={ 1 x ， 2 x ，…， n x }是一个正整数的集合，c是一个正整数。子集和问题判定是否存在S的一个子集S1，使得 S1中的所有元素之和等于c。<br>试设计一个解子集和问题的回溯法。</p>
<h4 id="解法-3">解法</h4><p>使用暴力解法，任何一个数字在最终的结果中都有出现和不出现两种情况所以复杂度是(2^n)方，需要在不断遍历结果过程中对结果进行剪枝。<br>可以构造所有子集，每次进入的时候判断是否满足条件。</p>
<h3 id="剑指offer_53_正则表达式匹配">剑指offer 53 正则表达式匹配</h3><h4 id="问题描述-4">问题描述</h4><p>请实现一个函数用来匹配包括’.’和<code>&#39;*&#39;</code>的正则表达式。模式中的字符’.’表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和<code>&quot;ab*ac*a&quot;</code>匹配，但是与”aa.a”和<code>&quot;ab*a&quot;</code>均不匹配</p>
<h4 id="解法-4">解法</h4><p>考虑<code>bool match(char* str, char* pattern)</code><br>因为str中可能出现_*这种形式，所以每次需要扫描pattern的后一个元素。讨论以下几种情况：</p>
<ul>
<li><p><code>_*</code></p>
<ul>
<li><p>如果能匹配上 <code>*p == *str</code>或者 <code>*p == &#39;.&#39;</code></p>
<ul>
<li>next state -&gt; str+1, p+2</li>
<li>current state -&gt; str+1, p</li>
<li>ignore this -&gt; str p+2</li>
</ul>
</li>
<li><p>如果匹配不上 ignore this -&gt; str, p+2</p>
</li>
</ul>
</li>
<li><code>*str == *p</code> -&gt; str+1, p+1</li>
<li><code>*p == &#39;.&#39;</code> -&gt; str+1, p+1</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool match(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">char</span>* pattern)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || pattern == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, pattern);
    }
    bool matchCore(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">char</span> *p)
    {
        <span class="keyword">if</span>(*<span class="keyword">str</span>  == <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *p == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*(p+<span class="number">1</span>) == <span class="string">'*'</span>)
        {
            <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">2</span>) || matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p) || matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
            <span class="keyword">else</span>
                <span class="keyword">return</span> matchCore(<span class="keyword">str</span>, p+<span class="number">2</span>);
        }
        <span class="keyword">if</span>(*p == *<span class="keyword">str</span> || (*p == <span class="string">'.'</span> &amp;&amp; *<span class="keyword">str</span> != <span class="string">'\0'</span>))
            <span class="keyword">return</span> matchCore(<span class="keyword">str</span>+<span class="number">1</span>, p+<span class="number">1</span>);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/递归/"> #递归 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/11/找工作总结-常用函数专题/">
                常用函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/11/找工作总结-常用函数专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/11/找工作总结-常用函数专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="C语言常用库函数">C语言常用库函数</h2><p>需要引用断言函数库</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;assert.h&gt;</span>
</code></pre><h3 id="注意点">注意点</h3><ul>
<li>需要声明断言</li>
<li>字符串操作结尾需要’\0’</li>
<li>不改变的内容需要声明const</li>
<li>对于<code>void*</code>类型，使用<code>(char*)dst</code>按字节赋值</li>
</ul>
<h3 id="strlen">strlen</h3><pre><code>size_t strlen(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    size_t len = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> != <span class="string">'\0'</span>)
    {
        <span class="built_in">str</span>++;
        len++;
    }
    <span class="keyword">return</span> len;
}
</code></pre><h3 id="strcpy">strcpy</h3><pre><code><span class="keyword">char</span>* strcpy(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">char</span>* <span class="keyword">ret</span> = dst;
    <span class="keyword">while</span>(*src != '\0')
    {
<span class="comment">        *dst = *src;</span>
        dst++;
        src++;
    }
<span class="comment">    *dst = '\0';</span>
    <span class="keyword">return</span> <span class="keyword">ret</span>;
}
</code></pre><h3 id="memcpy">memcpy</h3><pre><code><span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, size_t <span class="built_in">size</span>)
{
    <span class="keyword">assert</span>(dst != NULL);
    <span class="keyword">assert</span>(src != NULL);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="built_in">size</span>--)
    {
        *(<span class="built_in">char</span>*)dst = *(<span class="built_in">char</span>*)src;
        dst = (<span class="built_in">char</span>*)dst + <span class="number">1</span>;
        src = (<span class="built_in">char</span>*)src + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="memset">memset</h3><pre><code><span class="keyword">void</span>* memset(<span class="keyword">void</span>* dst, <span class="keyword">int</span> val, size_t <span class="keyword">size</span>)
{
    assert(dst != <span class="keyword">NULL</span>);
    <span class="keyword">void</span>* ret = dst;
    <span class="keyword">while</span>(<span class="keyword">size</span>--)
    {
        *(<span class="keyword">char</span>*)dst = val;
        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;
    }
    <span class="keyword">return</span> ret;
}
</code></pre><h3 id="strcmp">strcmp</h3><pre><code><span class="label">int</span> <span class="keyword">strcmp(const </span>char* <span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">assert</span>(<span class="keyword">str2 </span>!= NULL)<span class="comment">;</span>
    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&gt; *<span class="keyword">str2)
</span>            return <span class="number">1</span><span class="comment">;</span>
        <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>&lt; <span class="keyword">str2)
</span>            return -<span class="number">1</span><span class="comment">;</span>
        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    <span class="preprocessor">if</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        return <span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span> <span class="preprocessor">if</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
        return -<span class="number">1</span><span class="comment">;</span>
    <span class="preprocessor">else</span>
        return <span class="number">0</span><span class="comment">;</span>
}
</code></pre><h3 id="strcat">strcat</h3><pre><code><span class="label">char</span>* <span class="keyword">strcat(char* </span><span class="keyword">str1, </span>const char* <span class="keyword">str2)
</span>{
    <span class="preprocessor">assert</span>(<span class="keyword">str1 </span>!= NULL)<span class="comment">;</span>
    char* ret = <span class="keyword">str1;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str1 </span>!= <span class="string">'\0'</span>)
        <span class="keyword">str1++;
</span>    <span class="preprocessor">while</span>(*<span class="keyword">str2 </span>!= <span class="string">'\0'</span>)
    {
        *<span class="keyword">str1 </span>= *<span class="keyword">str2;
</span>        <span class="keyword">str1++;
</span>        <span class="keyword">str2++;
</span>    }
    *<span class="keyword">str1 </span>= <span class="string">'\0'</span><span class="comment">;</span>
    return ret<span class="comment">;</span>
}
</code></pre><h2 id="atoi和itoa">atoi和itoa</h2><h3 id="atoi">atoi</h3><p>把字符串(<code>char*</code>或者<code>string</code>)转化为整数</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>删除字符串前面的空值</li>
<li>考虑字符传中可能出现的+,-</li>
<li>考虑溢出的情况</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="built_in">int</span> atoi(<span class="keyword">const</span> <span class="built_in">char</span>* <span class="built_in">str</span>)
{
    <span class="keyword">assert</span>(<span class="built_in">str</span> != NULL);
    <span class="keyword">while</span>(*<span class="built_in">str</span> == <span class="string">' '</span>)
        <span class="built_in">str</span>++;
    bool isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'-'</span>)
    {
        isNeg = <span class="keyword">true</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(*<span class="built_in">str</span> == <span class="string">'+'</span>)
        <span class="built_in">str</span>++;
    <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;
    <span class="keyword">while</span>(*<span class="built_in">str</span> !=<span class="string">'\0'</span> &amp;&amp; *<span class="built_in">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="built_in">str</span> &lt;= <span class="string">'9'</span>)
    {
        num = num * <span class="number">10</span> + (*<span class="built_in">str</span> - <span class="string">'0'</span>);
        <span class="keyword">if</span>(isNeg &amp;&amp; -num &lt; INT_MIN)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">if</span>(!isNeg &amp;&amp; num &gt; INT_MAX)
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">str</span>++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">return</span> -num;
    <span class="keyword">else</span>
        <span class="keyword">return</span> num;
}
</code></pre><h3 id="itoa">itoa</h3><h4 id="注意点-2">注意点</h4><ul>
<li>正负数</li>
<li>反转字符串</li>
<li>最后的’\0’</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">char</span>* itoa(<span class="keyword">int</span> num, <span class="keyword">char</span>* <span class="keyword">str</span>)
{
    <span class="keyword">bool</span> isNeg = <span class="keyword">false</span>;
    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)
    {
        isNeg = <span class="keyword">true</span>;
        num = -num;
    }
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">while</span>(num)
    {
        <span class="keyword">str</span>[i] = num % <span class="number">10</span>;
        num /= <span class="number">10</span>;
        i++;
    }
    <span class="keyword">if</span>(isNeg)
        <span class="keyword">str</span>[i++] = <span class="string">'-'</span>;
    <span class="keyword">for</span>(j = <span class="number">0</span>, k = i-<span class="number">1</span>; j &lt; k; j++, k--)
    {
        <span class="keyword">char</span> ch = <span class="keyword">str</span>[j];
        <span class="keyword">str</span>[j] = <span class="keyword">str</span>[k];
        <span class="keyword">str</span>[k] = ch;
    }
    <span class="keyword">str</span>[i] = <span class="string">'\0'</span>;
    <span class="keyword">return</span> <span class="keyword">str</span>;
}
</code></pre><h2 id="自己实现一个String">自己实现一个String</h2><h3 id="注意点-3">注意点</h3><ul>
<li>参数不修改使用const</li>
<li>构造函数<ul>
<li>为m_data申请空间，包括字符串结束符’\0’</li>
<li><code>const char* str</code>,判断传入<code>char* str</code>参数是否为空</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>复制一个对象，一定需要申请新的空间</li>
<li><code>strlen(other.m_data)</code>在类中获取m_data指针</li>
<li>使用字符串函数strcpy</li>
</ul>
</li>
<li>析构函数<ul>
<li><code>delete [] m_data;</code></li>
</ul>
</li>
<li>赋值函数<ul>
<li>判断this == &amp;rhs</li>
<li>先申请空间，再释放原空间，再赋值(避免申请失败造成不了后果)</li>
</ul>
</li>
<li>重载操作符<ul>
<li>考虑返回引用(operator=)or值(operator+)</li>
<li>一般单目运算符使用成员函数重载，双目运算符使用友元</li>
<li>MyString&amp; other参数是否和this相等</li>
<li>重载operator+,判断源字符串为空</li>
<li>重载operator==，使用strcmp</li>
</ul>
</li>
</ul>
<h3 id="代码-2">代码</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">class</span> MyString
{
<span class="keyword">public</span>:
    MyString();
    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str);
    MyString(<span class="keyword">const</span> MyString&amp; other);
    ~MyString();
    MyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs);
    MyString <span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index);
    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs);
    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs);
<span class="keyword">private</span>:
    <span class="keyword">char</span>* m_data;
};

MyString::MyString()
{
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
    *m_data = <span class="string">'\0'</span>;
}

MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)
{
    <span class="keyword">if</span>(str == NULL)
    {
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];
        *m_data = <span class="string">'\0'</span>;
    }
    <span class="keyword">else</span>
    {
        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);
        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(m_data, str);
    }
}

MyString::MyString(<span class="keyword">const</span> MyString&amp; other)
{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);
    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];
    <span class="built_in">strcpy</span>(m_data, other.m_data);
}

MyString::~MyString()
{
    <span class="keyword">delete</span> [] m_data;
}

MyString&amp; MyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)
    {
        <span class="keyword">char</span>* temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(temp, rhs.m_data);
        <span class="keyword">delete</span> [] m_data;
        m_data = NULL;
        m_data = temp;
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}

MyString MyString::<span class="keyword">operator</span> + (<span class="keyword">const</span> MyString&amp; rhs)
{
    MyString newStr;
    <span class="keyword">if</span>(rhs.m_data == NULL)
        newStr = *<span class="keyword">this</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(m_data == NULL)
        newStr = rhs;
    <span class="keyword">else</span>
    {
        newStr.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];
        <span class="built_in">strcpy</span>(newStr.m_data, m_data);
        <span class="built_in">strcat</span>(newStr.m_data, rhs.m_data);
    }
    <span class="keyword">return</span> newStr;
}

<span class="keyword">char</span> MyString::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index)
{
    <span class="keyword">return</span> m_data[index];
}

<span class="keyword">bool</span> MyString::<span class="keyword">operator</span> == (<span class="keyword">const</span> MyString&amp; rhs)
{
    <span class="keyword">int</span> result = <span class="built_in">strcmp</span>(m_data, rhs.m_data);
    <span class="keyword">return</span> (<span class="number">0</span> == result);
}

ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> MyString&amp; rhs)
{
    output &lt;&lt; rhs.m_data;
    <span class="keyword">return</span> output;
}
</code></pre><h2 id="Singleton">Singleton</h2><h3 id="简单写法">简单写法</h3><pre><code>class Singleton
{<span class="keyword">
public</span>:
   <span class="keyword"> static</span> Singleton*<span class="function"> getInstance(</span><span class="function">)</span>;
    virtual<span class="function"> ~Singleton(</span><span class="function">)</span>;<span class="keyword">
private</span>:
   <span class="function"> Singleton(</span><span class="function">)</span>;
   <span class="keyword"> static</span> Singleton *instance;
};

Singleton* Singleton::instance = NU<span class="class">LL;</span>//如果允许在这里直接new出来可以避免多线程的影响
Singleton::Singleton(<span class="function">)</span>{}
Singleton::~Singleton(<span class="function">)</span>
{
    delete instance;
   <span class="instruction"> instance </span>= NU<span class="class">LL;</span>
}

Singleton*<span class="function"> Singleton::getInstance(</span><span class="function">)</span>
{
   <span class="function"> if(</span>instance == NULL<span class="function">)</span>
    {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
    }
   <span class="instruction"> return </span>instance;
}
</code></pre><h3 id="模板+资源管理+线程安全">模板+资源管理+线程安全</h3><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">Singleton</span>
{
private:
    <span class="type">Singleton</span>(){};
    <span class="keyword">static</span> auto_ptr&lt;T&gt; <span class="keyword">ptr</span>;
public:
    <span class="keyword">static</span> auto_ptr&lt;T&gt; getInstance()
    {
        <span class="type">Mutex</span> mutex;
        mutex.lock();
        <span class="keyword">if</span>(! <span class="keyword">ptr</span>.get())
        {
            auto_ptr&lt;T&gt; temp(new T);
            <span class="keyword">ptr</span> = temp;
        }
        <span class="keyword">return</span> <span class="keyword">ptr</span>;
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/常用函数/"> #常用函数 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-一般题目/">
                二叉树专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/">
                二叉树专题-二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-二叉查找树/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-二叉查找树/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/10/找工作总结-二叉树专题-基础/">
                二叉树专题-基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/10/找工作总结-二叉树专题-基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/10/找工作总结-二叉树专题-基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二叉树/"> #二叉树 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/04/找工作总结-链表专题/">
                链表专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/04/找工作总结-链表专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/04/找工作总结-链表专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="keyword">next</span>;
    ListNode(<span class="keyword">int</span> x):val(x),<span class="keyword">next</span>(<span class="keyword">NULL</span>){}
};
</code></pre><h3 id="求链表中节点个数">求链表中节点个数</h3><pre><code><span class="keyword">int</span> getLength(ListNode* head)
{
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">while</span>(head)
    {
        head = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">count</span>++;
    }
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><h3 id="单链表翻转">单链表翻转</h3><pre><code><span class="constant">ListNode*</span> reverseList(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> newHead = <span class="constant">NULL;</span>
    <span class="constant">ListNode*</span> node = head;
    <span class="keyword">while</span>(node)
    {
        <span class="constant">ListNode*</span> temp = node-&gt;<span class="keyword">next</span>;
        node-&gt;<span class="keyword">next</span> = newHead;
        newHead = node;
        node = temp-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中倒数第k个节点">查找链表中倒数第k个节点</h3><pre><code>ListNode* getLastK(ListNode* head, <span class="built_in">int</span> k)
{
    ListNode* fisrt = head;
    ListNode* <span class="built_in">second</span> = head;
    <span class="keyword">while</span>(k--)
    {
        <span class="keyword">if</span>(first)
            first = first-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            return <span class="literal">NULL</span>;
    }
    <span class="keyword">while</span>(first)
    {
        fisrt = first-&gt;<span class="keyword">next</span>;
        <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>;
    }
    return <span class="built_in">second</span>;
}
</code></pre><h3 id="删除链表中第k个节点">删除链表中第k个节点</h3><pre><code>ListNode* deleteK(ListNode* head, <span class="keyword">int</span> k)
{
    <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)
        <span class="keyword">return</span> head;
    ListNode* toBeDelete;
    ListNode* newHead;
    <span class="keyword">if</span>(k == <span class="number">1</span>)
    {
        toBeDelete = head;
        newHead = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">delete</span> toBeDelete;
        <span class="keyword">return</span> newHead;
    }
    newHead = head;
    ListNode* node = head;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">2</span>; i++)
    {
        <span class="keyword">if</span>(node)
            node = node-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> newHead;
    }
    <span class="keyword">if</span>(node == <span class="keyword">NULL</span> || node-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)
        <span class="keyword">return</span> newHead;
    toBeDelete = node-&gt;<span class="keyword">next</span>;
    node-&gt;<span class="keyword">next</span> = node-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    <span class="keyword">delete</span> toBeDelete;
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中间节点">查找链表中间节点</h3><pre><code><span class="constant">ListNode*</span> findMiddle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> first = head;
    <span class="constant">ListNode*</span> second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = fisrt-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        if(first)
            second = second-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> second;
}
</code></pre><h3 id="从尾到头打印链表">从尾到头打印链表</h3><pre><code>void reversePrint(<span class="type">ListNode</span>* head)
{
    <span class="type">ListNode</span>* node = head;
    stack&lt;<span class="type">ListNode</span>*&gt; s;
    <span class="keyword">while</span>(node)
    {
        s.push(node);
        node = node-&gt;next;
    }
    <span class="keyword">while</span>(!s.empty<span class="literal">()</span>)
    {
        cout&lt;&lt;s.top<span class="literal">()</span>-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">" "</span>;
        s.pop<span class="literal">()</span>;
    }
}
</code></pre><h3 id="单链表排序，选择排序">单链表排序，选择排序</h3><pre><code>void sortList(<span class="type">ListNode</span>* head)
{
    <span class="keyword">for</span>(<span class="type">ListNode</span>* p = head; p != <span class="type">NULL</span>; p = p-&gt;next)
    {
        <span class="type">ListNode</span>* min = p;
        <span class="keyword">for</span>(<span class="type">ListNode</span>* q = p-&gt;next; q != <span class="type">NULL</span>; q = q-&gt;next)
        {
            <span class="keyword">if</span>(q-&gt;<span class="keyword">val</span> &lt; min-&gt;<span class="keyword">val</span>)
                min = q;
        }
        <span class="built_in">int</span> temp = p-&gt;<span class="keyword">val</span>;
        p-&gt;<span class="keyword">val</span> = min-&gt;<span class="keyword">val</span>;
        min-&gt;<span class="keyword">val</span> = temp;
    }
}
</code></pre><h3 id="合并两个有序链表">合并两个有序链表</h3><pre><code>ListNode<span class="subst">*</span> mergeList(ListNode<span class="subst">*</span> list1, ListNode<span class="subst">*</span> list2)
{
    <span class="keyword">if</span>(list1 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list2;
    <span class="keyword">if</span>(list2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list1;
    ListNode<span class="subst">*</span> head <span class="subst">=</span> <span class="built_in">NULL</span>;
    ListNode <span class="subst">*</span>node1 <span class="subst">=</span> list1, <span class="subst">*</span>node2 <span class="subst">=</span> list2;
    ListNode <span class="subst">*</span>tnode <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
    {
        head <span class="subst">=</span> node1;
        node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
    }
    <span class="keyword">else</span>
    {
        head <span class="subst">=</span> node2;
        node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
    }
    tnode <span class="subst">=</span> head;
    tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">while</span>(node1 <span class="subst">&amp;&amp;</span> node2)
    {
        <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
            node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
        <span class="keyword">else</span>
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
            node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
    }
    <span class="keyword">if</span>(node1)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
    <span class="keyword">if</span>(node2)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
    <span class="keyword">return</span> head;
}
</code></pre><h3 id="判断一个链表是否有环">判断一个链表是否有环</h3><pre><code>bool hasCircle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode </span>*first = head, *second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = first-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        second = second-&gt;<span class="keyword">next</span>;
        if(first == second)
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="判断两个链表是否相交">判断两个链表是否相交</h3><pre><code>bool isJoin(<span class="constant">ListNode </span>*list1, <span class="constant">ListNode </span>*list2)
{
    if(list1 == <span class="constant">NULL </span>|| list2 == <span class="constant">NULL)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="constant">ListNode </span>*n1 = list1, *n2 = list2;
    <span class="keyword">while</span>(n1-&gt;<span class="keyword">next</span>)
        n1 = n1-&gt;<span class="keyword">next</span>;
    <span class="keyword">while</span>(n2-&gt;<span class="keyword">next</span>)
        n2 = n2-&gt;<span class="keyword">next</span>;
    <span class="keyword">return</span> (n1 == n2);
}
</code></pre><h3 id="判断两个链表相交的第一个节点">判断两个链表相交的第一个节点</h3><ol>
<li>判断两个链表是否相交，得到两个链表长度len1,len2</li>
<li>假设len1 &gt; len2，n1先走(len1-len2)步</li>
<li>n1,n2一起走，直到n1 == n2</li>
</ol>
<h3 id="如果一个链表有环，求进入环中的第一个节点">如果一个链表有环，求进入环中的第一个节点</h3><ol>
<li>使用上面的方法判断是否有环</li>
<li>在环中走一圈得到环的长度len</li>
<li>前后两个节点一个先走len步（走一个环的长度），两个一起走相遇在环的入口</li>
</ol>
<h3 id="在O(1)的时间内删除节点">在O(1)的时间内删除节点</h3><pre><code><span class="literal">void</span> deleteInO1(ListNode<span class="subst">*</span> <span class="built_in">list</span>, ListNode<span class="subst">*</span> toBeDelete)
{
    <span class="keyword">if</span>(<span class="built_in">list</span> <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> toBeDelete <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="keyword">if</span>(toBeDelete <span class="subst">==</span> <span class="built_in">list</span>)
    {
        <span class="built_in">list</span> <span class="subst">=</span> <span class="built_in">list</span><span class="subst">-&gt;</span>next;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    <span class="keyword">if</span>(toBeDelete<span class="subst">-&gt;</span>next <span class="subst">==</span> <span class="built_in">NULL</span>)
    {
        ListNode<span class="subst">*</span> node <span class="subst">=</span> <span class="built_in">list</span>;
        <span class="keyword">while</span>(node <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>next <span class="subst">!=</span> toBeDelete)
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>next;
        node<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    ListNode<span class="subst">*</span> temp <span class="subst">=</span> toBeDelete<span class="subst">-&gt;</span>next;
    toBeDelete<span class="subst">-&gt;</span>val <span class="subst">=</span> temp<span class="subst">-&gt;</span>val;
    toBeDelete<span class="subst">-&gt;</span>next <span class="subst">=</span> temp<span class="subst">-&gt;</span>next;
    delete temp;
    <span class="keyword">return</span> ;
}
</code></pre><h2 id="特殊题目">特殊题目</h2><h3 id="剑指offer57_删除链表中的重复节点">剑指offer57 删除链表中的重复节点</h3><h4 id="问题描述">问题描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法">解法</h4><p>使用preNode和node指向最后一个未删除的节点和第一个可能删除的节点</p>
<ul>
<li>如果保留重复元素的第一个<br>只需要使用node扫描一次，判断和preNode-&gt;val是否相等，分两种情况处理即可</li>
<li>如果不保留重复元素<br>需要确定新的头元素newHead,需要判断是否重复，因为需要全部删除。</li>
</ul>
<h4 id="类型1的代码">类型1的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode *deleteDuplicates(ListNode *head) {
        <span class="keyword">if</span>(<span class="keyword">NULL</span> == head || <span class="keyword">NULL</span>==head-&gt;next)
            <span class="keyword">return</span> head;
        ListNode *preNode = head;
        ListNode *node = preNode-&gt;next;
        <span class="keyword">while</span>(node)
        {
            <span class="keyword">if</span>(node-&gt;val == preNode-&gt;val)
            {
                ListNode* temp = node;
                node = node-&gt;next;
                preNode-&gt;next = node;
                delete temp;
            }
            <span class="keyword">else</span>
            {
                node = node-&gt;next;
                preNode = preNode-&gt;next;
            }
        }
        <span class="keyword">return</span> head;
    }
};
</code></pre><h4 id="类型2的代码">类型2的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> head;
        ListNode *node = head;
        ListNode *newHead = <span class="keyword">NULL</span>;
        ListNode *preNode = <span class="keyword">NULL</span>;
        <span class="keyword">while</span>(node)
        {
            bool isDuplicated = <span class="keyword">false</span>;
            <span class="keyword">if</span>(node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)
                isDuplicated = <span class="keyword">true</span>;
            <span class="keyword">if</span>(isDuplicated)
            {
                int val = node-&gt;val;
                <span class="keyword">while</span>(node!= <span class="keyword">NULL</span> &amp;&amp; node-&gt;val == val)
                {
                    ListNode *temp = node;
                    node = node-&gt;next;
                    delete temp;
                }
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(!newHead)
                {
                    newHead = node;
                    preNode = node;
                }
                <span class="keyword">else</span>
                {
                    preNode-&gt;next = node;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
        }
        <span class="keyword">if</span>(preNode)
            preNode-&gt;next = <span class="keyword">NULL</span>;
        <span class="keyword">return</span> newHead;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/链表/"> #链表 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/10/03/找工作总结-栈和队列专题/">
                栈和队列专题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-10-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/10/03/找工作总结-栈和队列专题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/03/找工作总结-栈和队列专题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法">解法</h4><p>两个栈stack1,stack2。完成push和pop函数即可。</p>
<ul>
<li>push的时候向stack1压栈。</li>
<li>pop的时候<br>(1)stack2不为空，弹出stack2.top<br>(2)stack1不为空，把stack1中的元素全部弹出到stack2，然后弹出stack2.top<br>(3)如果stack1和stack2都是空，那么抛出异常<h4 id="注意点">注意点</h4></li>
<li>模板的写法</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">MyQueue</span>
{
public:
    <span class="type">void</span> push(<span class="keyword">const</span> T&amp; item);
    T pop();
private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> <span class="type">MyQueue</span>::push(<span class="keyword">const</span> T&amp; item)
{
    stack1.push(item);
}

<span class="keyword">template</span>&lt;typename T&gt;
T <span class="type">MyQueue</span>::pop()
{
    <span class="keyword">if</span>(!stack2.empty())
    {
        T temp = stack2.top();//?是否需要引用
        stack2.pop();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(!stack1.empty())
    {
        <span class="keyword">while</span>(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }
    <span class="keyword">else</span>
        throw exception(<span class="string">"MyQueue is empty!"</span>);
}
</code></pre><h4 id="扩展问题，使用两个队列实现栈">扩展问题，使用两个队列实现栈</h4><p>有queue1，queue2两个队列，完成push,pop。</p>
<ul>
<li>push<br>如果queue1.empty &amp;&amp; queue.empty 向queue1中push<br>如果有一个不为空，向不为空的队列里push</li>
<li>pop<br>如果queue1.empty &amp;&amp; queue.empty 抛出异常<br>把不为空的队列出队到空队列，直到剩下一个元素，弹出这个元素</li>
</ul>
<h3 id="剑指offer21_包含min函数的栈">剑指offer21 包含min函数的栈</h3><h4 id="问题描述-1">问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解法-1">解法</h4><p>使用stack1,stack2两个栈，stack1压入原本的元素，stack2只压最小元素</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">int</span> tempMin;
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            tempMin = <span class="keyword">value</span>;
        <span class="keyword">else</span>
        {
            tempMin = s2.top();
            <span class="keyword">if</span>(<span class="keyword">value</span> &lt; tempMin)
                tempMin = <span class="keyword">value</span>;
        }
        s1.push(<span class="keyword">value</span>);
        s2.push(tempMin);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">pop</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span>;
        s1.pop();
        s2.pop();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s1.top();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">min</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s2.top();
    }
<span class="keyword">private</span>:
    stack&lt;<span class="keyword">int</span>&gt; s1;
    stack&lt;<span class="keyword">int</span>&gt; s2;
};
</code></pre><h3 id="剑指offer22_栈的压入弹出序列">剑指offer22 栈的压入弹出序列</h3><h4 id="问题描述-2">问题描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h4 id="解法-2">解法</h4><p>使用一个栈stack进行模拟，遍历数组元素：</p>
<ul>
<li>如果<code>vec[i] != stack.top</code>，压入</li>
<li>如果<code>vec[i] == stack.top</code>，弹出</li>
<li><code>i == vec.size</code>时，判断栈是否为空</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    bool IsPopOrder<span class="params">(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)</span> {
        <span class="keyword">if</span><span class="params">(pushV.size<span class="params">()</span> != popV.size<span class="params">()</span>)</span>
            return <span class="literal">false</span>;
        stack&lt;int&gt; s;
        int i=<span class="number">0</span>,j=<span class="number">0</span>;
        <span class="keyword">for</span><span class="params">(;j &lt; popV.size<span class="params">()</span>; j++)</span>
        {
            while<span class="params">(s.empty<span class="params">()</span> || <span class="params">(i &lt; pushV.size<span class="params">()</span> &amp;&amp; s.top<span class="params">()</span> != popV[j])</span>)</span>
                s.push<span class="params">(pushV[i++])</span>;
            <span class="keyword">if</span><span class="params">(s.top<span class="params">()</span> == popV[j])</span>
                s.pop<span class="params">()</span>;
            <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span>)</span>
                break;
        }
        <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span> &amp;&amp; j == popV.size<span class="params">()</span> &amp;&amp; s.empty<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="剑指offer65_滑动窗口最大值">剑指offer65 滑动窗口最大值</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解法-3">解法</h4><p>使用双端队列(dequeue)记录当前窗口最大值<strong>下标</strong>序列，每插入一个元素就向前删除。通过比较dequeue的第一个元素是当前窗口的最大元素<strong>下标</strong>，比较首元素下标和i-size判断删除队列头部元素。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>从后向前删除</li>
<li>最后一个窗口</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; maxInWindows(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, unsigned <span class="type">int</span> size)
    {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(num.size() &lt; size || size &lt; <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        deque&lt;<span class="type">int</span>&gt; indexes;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)
        {
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            indexes.push_back(i);
        }

        <span class="keyword">for</span>(<span class="type">int</span> i = size;i &lt; num.size(); i++)
        {
            <span class="literal">result</span>.push_back(num[indexes.front()]);
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; indexes.front() &lt;= (i-size))
                indexes.pop_front();
            indexes.push_back(i);
        }
        <span class="literal">result</span>.push_back(num[indexes.front()]);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/栈和队列/"> #栈和队列 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-一般题目/">
                数组专题-一般题目
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-一般题目/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-一般题目/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法">解法</h4><p>从右上角（这样使得这一行剩余元素都比他小，这一列剩余元素都比他大）向左下角扫描</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> width = <span class="built_in">array</span>[<span class="number">0</span>].size();
        <span class="keyword">int</span> height = <span class="built_in">array</span>.size();
        <span class="keyword">int</span> i = <span class="number">0</span>, j = width - <span class="number">1</span>;
        <span class="keyword">while</span>(i &lt; height &amp;&amp; j &gt;= <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)
                i++;
            <span class="keyword">else</span>
                j--;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer32_整数中1出现的次数（从1到n整数中1出现的次数）">剑指offer32 整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="问题描述-1">问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h4 id="解法-1">解法</h4><p>这个解法对于1-9的原理是一样的。首先找到规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从 1 至  10^i ，在它们右数第  i  位中，任意的 X 都出现了  10^(i−1)  次。这个可以用来计算高位的值。<br>计算方法：<br>当计算右数第  i  位包含的 X 的个数时：<br>取第  i  位左边（高位）的数字，乘以  10^(i−1) ，得到基础值  a 。<br>取第  i  位数字，计算修正值：<br>如果大于 X，则结果为  a+ 10^(i−1)。<br>如果小于 X，则结果为  a。<br>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  (a+b+1) 。<br>例如对于num=52134, i=3, a=52, b=34, i位数字k=1,k=x故 result=a+b+1<br>解释，a等于0~51，可推出高位的结果，a=52时，讨论低位的结果。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">int</span> NumberOf1Between1AndN_Solution(<span class="keyword">int</span> n)
    {
        <span class="keyword">int</span> x = <span class="number">1</span>;
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>, k;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)
        {
            k = n / i;
            <span class="comment">//k/10为高位数字</span>
            <span class="keyword">count</span> += (k / <span class="number">10</span>) * i;
            <span class="keyword">int</span> cur = k % <span class="number">10</span>;
            <span class="keyword">if</span>(cur &gt; x)
                <span class="keyword">count</span>+=i;               
            <span class="keyword">else</span> <span class="keyword">if</span>(cur == x)
                <span class="comment">//n%i为低位数字</span>
                <span class="keyword">count</span> += n % i + <span class="number">1</span>;
            <span class="keyword">else</span>{}
        }
        <span class="keyword">return</span> <span class="keyword">count</span>;
    }
};
</code></pre><h3 id="剑指offer44_扑克牌的顺子">剑指offer44 扑克牌的顺子</h3><h4 id="问题描述-2">问题描述</h4><p>抽出一序列牌，王代表任意数字是0，并且A看作1,J为11,Q为12,K为13。判断这个序列是否是顺子</p>
<h4 id="解法-2">解法</h4><p>对序列进行排序，看0是否能将空缺数字填满。</p>
<h4 id="注意点">注意点</h4><ul>
<li>统计0的个数和gap的数量进行比较</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool IsContinuous(vector&lt;<span class="keyword">int</span>&gt; numbers)
    {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">sort</span>(numbers.begin(), numbers.end());
        <span class="keyword">int</span> numOfZero = <span class="number">0</span>, numOfGap = <span class="number">0</span>;
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>() &amp;&amp; numbers[i] == <span class="number">0</span>; i++)
            numOfZero++;
        <span class="keyword">if</span>(i &lt; numbers.<span class="keyword">size</span>())
            i++;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == numbers[i - <span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>; 
            numOfGap += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;
        }
        <span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer52_构建乘积数组">剑指offer52 构建乘积数组</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组<code>A[0,1,...,n-1]</code>,请构建一个数组<code>B[0,1,...,n-1]</code>,其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<h4 id="解法-3">解法</h4><p>从上到下扫描，temp记录中间结果，避免重复的乘法。从上到下遍历一次，从下到上遍历一次。</p>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; multiply(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A) {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>(A.size(), <span class="number">1</span>);
        <span class="keyword">if</span>(A.size() &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)
        {
            temp *= A[i - <span class="number">1</span>];
            <span class="literal">result</span>[i] = temp;
        }
        temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)
        {
            temp *= A[i + <span class="number">1</span>];
            <span class="literal">result</span>[i] *= temp;
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h3 id="剑指offer20_顺时针打印矩阵">剑指offer20 顺时针打印矩阵</h3><h4 id="问题描述-4">问题描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h4 id="解法-4">解法</h4><p>先写一个打印一圈的函数，再遍历所有的圈。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>判断遍历是否越界</li>
<li>遍历的时候注意减回去(x—)</li>
</ul>
<h4 id="代码-4">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">matrix</span>) {
        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>.<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">int</span> start = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> start =  <span class="number">0</span>; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); start++)
            printInCircle(<span class="keyword">matrix</span>, start, vec);
        <span class="keyword">return</span> vec;
    }

    void printInCircle(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>, <span class="keyword">int</span> start, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)
    {
        <span class="keyword">int</span> x = start, y = start;
        <span class="comment">//从左向右打印</span>
        <span class="keyword">int</span> endx = <span class="keyword">matrix</span>[y].<span class="keyword">size</span>()- <span class="number">1</span> - start;
        <span class="keyword">for</span>(; x &lt;= endx; x++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        --x;

        <span class="comment">//从上向下打印</span>
        <span class="keyword">int</span> endy = <span class="keyword">matrix</span>.<span class="keyword">size</span>() - <span class="number">1</span> - start;
        <span class="keyword">if</span>(y + <span class="number">1</span> &gt; endy)
            <span class="keyword">return</span>;
        y++;
        <span class="keyword">for</span>(; y &lt;= endy; y++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y--;

        <span class="comment">//从右向左打印</span>
        <span class="keyword">if</span>(x - <span class="number">1</span> &lt; start)
            <span class="keyword">return</span>;
        x--;
        <span class="keyword">for</span>(; x &gt;= start; x--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        x++;
        <span class="comment">//从下向上打印</span>
        <span class="keyword">if</span>(y - <span class="number">1</span> &lt; start) <span class="keyword">return</span>;
        y--;
        <span class="keyword">for</span>(; y &gt; start; y--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y++;
    }

 };
</code></pre><h3 id="剑指offer30_最小的k个数">剑指offer30 最小的k个数</h3><h4 id="问题描述-5">问题描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="解法-5">解法</h4><p>使用大顶堆存储k个数，遍历原数据，每次淘汰最大的，最后堆中剩余的元素就是最小的k个数</p>
<h4 id="注意点-2">注意点</h4><ul>
<li>输入数据合法性，k的取值大于input.size()的情况</li>
<li><p>stl中<algorithm>关于堆的操作，make_heap,push_heap,pop_heap,sort_heap.默认建立大顶堆，如果想使用小顶堆需要加入比较函数。</algorithm></p>
<pre><code>make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
</code></pre></li>
</ul>
<h4 id="代码-5">代码</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    vector&lt;<span class="built_in">int</span>&gt; <span class="type">GetLeastNumbers_Solution</span>(vector&lt;<span class="built_in">int</span>&gt; input, <span class="built_in">int</span> k) {
        vector&lt;<span class="built_in">int</span>&gt; res;
        <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.size<span class="literal">()</span>)
            return res;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)
            res.push_back(input[i]);
        make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; input.size<span class="literal">()</span>; i++)
        {
            <span class="keyword">if</span>(input[i] &gt;= res[<span class="number">0</span>])
                continue;
            res.push_back(input[i]);
            push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            res.pop_back<span class="literal">()</span>;
        }
        sort_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        return res;
    }
};
</code></pre><h3 id="剑指offer33_把数组排成最小的数">剑指offer33 把数组排成最小的数</h3><h4 id="问题描述-6">问题描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="解法-6">解法</h4><p>首先要证明这样一个结论：</p>
<blockquote>
<p>若ca&lt;ac则在最后的字符串中，c应该在a的后面</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>条件：ca&lt;ac，有另一个任意<strong>字符串</strong>b与a,c进行排列组合<br>讨论：</p>
<pre><code>若b&lt;c&lt;<span class="tag">a</span> 可以得到bca是最小的
若c&lt;b&lt;<span class="tag">a</span> 可以得到cba是最小的
若c&lt;a&lt;<span class="tag">b</span> 可以得到cab是最小的
</code></pre><p>结论：c应该在a的前面</p>
<h4 id="注意点-3">注意点</h4><ul>
<li><p>sort函数中比较函数应该如何写</p>
<p>  <code>template &lt;class RandomAccessIterator, class Compare&gt;</code><br>  <code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
</li>
</ul>
<p>comp函数表示</p>
<blockquote>
<p>The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.<br>比较函数传入两个参数，返回bool，返回值表示在最终的排序结果中，第一个参数是否应该出现在第二个参数的前面。</p>
</blockquote>
<h4 id="代码-6">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span>
    </span>{
        <span class="built_in">string</span> temp1 = str1 + str2;
        <span class="built_in">string</span> temp2 = str2 + str1;
        <span class="keyword">if</span>(temp1.compare(temp2)&lt;=<span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;

    }

    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>{
        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs(numbers.size());
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)
        {
            strs[i] = numToString(numbers[i]);
        }
        <span class="built_in">std</span>::sort(strs.begin(), strs.end(), cmp);
        <span class="built_in">string</span> ans;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)
            ans += strs[i];
        <span class="keyword">return</span> ans;
    }  

    <span class="function"><span class="built_in">string</span> <span class="title">numToString</span><span class="params">(<span class="keyword">int</span> num)</span>
    </span>{
        <span class="built_in">string</span> str;
        <span class="keyword">while</span>(num)
        {
            str = (<span class="keyword">char</span>)(num % <span class="number">10</span> + <span class="string">'0'</span>) + str;
            num = num / <span class="number">10</span>;
        }
        <span class="keyword">return</span> str;
    } 
};
</code></pre><h3 id="剑指offer34_丑数">剑指offer34 丑数</h3><h4 id="问题描述-7">问题描述</h4><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="解法-7">解法</h4><p>使用递推法，<code>*numM2</code>,<code>*numM3</code>,<code>*numM5</code>表示，x2,x3,x5后产生的数</p>
<h4 id="代码-7">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> GetUglyNumber_Solution(<span class="built_in">int</span> <span class="built_in">index</span>) {
        <span class="keyword">if</span>(<span class="built_in">index</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> *a = new <span class="built_in">int</span>[<span class="built_in">index</span>];
        a[<span class="number">0</span>] = <span class="number">1</span>;
        <span class="built_in">int</span> *numM2 = a, *numM3 = a, *numM5 = a;
        for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">index</span>; i++)
        {
            <span class="built_in">int</span> <span class="built_in">min</span> = getMin((*numM2) * <span class="number">2</span>, (*numM3) * <span class="number">3</span>, (*numM5) * <span class="number">5</span>);
            a[i] = <span class="built_in">min</span>;
            <span class="keyword">while</span>((*numM2) * <span class="number">2</span> &lt;= <span class="built_in">min</span>)
                numM2++;
            <span class="keyword">while</span>((*numM3) * <span class="number">3</span> &lt;= <span class="built_in">min</span>)
                numM3++;
            <span class="keyword">while</span>((*numM5) * <span class="number">5</span> &lt;= <span class="built_in">min</span>)
                numM5++;
        }
        <span class="keyword">return</span> a[<span class="built_in">index</span>-<span class="number">1</span>];
    }

    <span class="built_in">int</span> getMin(<span class="built_in">int</span> num1,<span class="built_in">int</span> num2,<span class="built_in">int</span> num3)
    {
        <span class="keyword">return</span> <span class="built_in">min</span>(num1, <span class="built_in">min</span>(num2, num3));
    }
};
</code></pre><h3 id="剑指offer45_圆圈中最后剩下的数字（约瑟夫环问题）">剑指offer45 圆圈中最后剩下的数字（约瑟夫环问题）</h3><h4 id="问题描述-8">问题描述</h4><p>每年六一儿童节,NowCoder都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为NowCoder的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到NowCoder名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？</p>
<h4 id="解法-8">解法</h4><p>约瑟夫环递推公式：<br>f(n, m)表示n个人玩儿，报到m退出，最后剩下的人的编号。</p>
<pre><code><span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = 0, <span class="keyword">n</span>=1
<span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = (<span class="literal">f</span>(<span class="keyword">n</span> - 1) + <span class="keyword">m</span>) % <span class="keyword">n</span>, <span class="keyword">n</span> &gt; 1
</code></pre><h4 id="代码-8">代码</h4><h5 id="递推解法">递推解法</h5><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span>
    </span>{
        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">int</span> last = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)
            last=(last + m) % i;
        <span class="keyword">return</span> last;
    }
};
</code></pre><h5 id="递归解法">递归解法</h5><pre><code>int lastRemain(int <span class="keyword">n</span>, int  <span class="keyword">m</span>)
{
    <span class="keyword">if</span>(<span class="keyword">n</span> == 1)
        <span class="keyword">return</span> 0;
    <span class="keyword">return</span> (lastRemain(<span class="keyword">n</span> - 1, <span class="keyword">m</span>) % <span class="keyword">n</span>);
}
</code></pre><h4 id="问题拓展:求第i次出环的人的编号">问题拓展:求第i次出环的人的编号</h4><pre><code>int getNumOfI(int <span class="keyword">n</span>, int <span class="keyword">m</span>, int i)
{
    <span class="keyword">if</span>(i == 1)
        <span class="keyword">return</span> (<span class="keyword">n</span> + <span class="keyword">m</span> - 1) % <span class="keyword">n</span>; <span class="comment">//第一次出环 (n-1+m)%n</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> getNumOfI(<span class="keyword">n</span> - 1, <span class="keyword">m</span>, i - 1) % <span class="keyword">n</span>;
}
</code></pre><p><a href="http://www.cnblogs.com/yangyh/archive/2011/10/30/2229517.html" target="_blank" rel="external">参考</a></p>
<h3 id="剑指offer64_数据流中的中位数">剑指offer64 数据流中的中位数</h3><h4 id="问题描述-9">问题描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>实现一种数据结构，要求插入删除O(logn),取中位数O(1)</p>
<h4 id="解法-9">解法</h4><p>实现一个小顶堆和大顶堆，大数存在小顶堆，小数存在大顶堆，每次按大小压入元素，调整两个堆中的数量，使得<code>0&lt;=Num(大顶堆)-Num(小顶堆)&lt;=1</code>。</p>
<h4 id="注意点-4">注意点</h4><ul>
<li>使用priority_queue<br>初始化：<pre><code>priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;
priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;
</code></pre>压入，弹出：<pre><code><span class="tag">minHeap</span><span class="class">.push</span>(<span class="tag">maxHeap</span><span class="class">.top</span>());
<span class="tag">maxHeap</span><span class="class">.pop</span>();
</code></pre></li>
</ul>
<h4 id="代码-9">代码</h4><pre><code>class Solution {
public:
    void Insert<span class="params">(int num)</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.empty<span class="params">()</span> || num &lt;= maxHeap.top<span class="params">()</span>)</span>
            maxHeap.push<span class="params">(num)</span>;
        <span class="keyword">else</span>
            minHeap.push<span class="params">(num)</span>;
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>+<span class="number">2</span>)</span>
        {
            minHeap.push<span class="params">(maxHeap.top<span class="params">()</span>)</span>;
            maxHeap.pop<span class="params">()</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>-<span class="number">1</span>)</span>
        {
            maxHeap.push<span class="params">(minHeap.top<span class="params">()</span>)</span>;
            minHeap.pop<span class="params">()</span>;
        }
    }

    double GetMedian<span class="params">()</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>)</span>
            return <span class="params">(maxHeap.top<span class="params">()</span> + minHeap.top<span class="params">()</span>)</span>/<span class="number">2.0</span>;
        <span class="keyword">else</span>
            return maxHeap.top<span class="params">()</span>;
    }
private:
    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;

};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-两个指针/">
                数组专题-两个指针
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-两个指针/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-两个指针/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="通用解题思路">通用解题思路</h1><ul>
<li>使用快排中的partition函数</li>
<li>贪心,left++,right-直到相遇</li>
<li>二分查找，mid = (left + right) / 2</li>
</ul>
<h2 id="k-sum问题">k-sum问题</h2><p>k-sum问题解题思路:<br>先对数组进行排序(nlogn)。退化成2-sum问题，使用left,right指针向中间查找。最终把复杂度优化到O(n^(k-1))</p>
<h3 id="剑指offer41_和为S的两个数字_VS_和为S的连续正数序列">剑指offer41 和为S的两个数字 VS 和为S的连续正数序列</h3><h4 id="问题描述">问题描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<h4 id="解法">解法</h4><p>2-sum问题，乘积最小的两个数字就是left和right第一次满足条件的两个数字。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    vector&lt;<span class="built_in">int</span> &gt; FindNumbersWithSum(vector&lt;<span class="built_in">int</span>&gt; <span class="built_in">array</span>,<span class="built_in">int</span> sum) {
        vector&lt;<span class="built_in">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) return vec;
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &lt; sum)
                <span class="built_in">left</span>++;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &gt; sum)
                <span class="built_in">right</span>--;
            <span class="keyword">else</span>
            {
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">left</span>]);
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">right</span>]);
                return vec;
            }
        }
        return vec;
    }
};
</code></pre><h4 id="问题描述-1">问题描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<h4 id="解法-1">解法</h4><p>同上，不过比较条件变成。(left+right)(right-left+1)/2</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(sum &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;
        <span class="keyword">while</span>(right &lt;= (sum + <span class="number">1</span>) / <span class="number">2</span>)
        {
            <span class="keyword">int</span> temp = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(temp &lt; sum)
                right++;
            <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; sum)
                left++;
            <span class="keyword">else</span>
            {
                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)
                    vec.push_back(i);
                <span class="built_in">list</span>.push_back(vec);
                right++;
            }
        }
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }
};
</code></pre><h3 id="leetcode18_4Sum">leetcode18 4Sum</h3><h4 id="问题描述-2">问题描述</h4><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<ul>
<li>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)</li>
<li><p>The solution set must not contain duplicate quadruplets.</p>
<pre><code>For example, given<span class="instruction"> array </span>S = {1 0 -1 0 -2 2},<span class="instruction"> and </span>target = 0.

A solution set is:
(-1,  0, 0, 1<span class="function">)</span>
(-2, -1, 1, 2<span class="function">)</span>
(-2,  0, 0, 2<span class="function">)</span>
</code></pre></li>
</ul>
<h4 id="解法-2">解法</h4><p>先排序，退化到2-sum问题。</p>
<h4 id="注意点">注意点</h4><p>题目要求找出所有满足条件的数组，需要避免重复。</p>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//思路：K-Sum问题，复杂度降到O(n^(k-1))</span>
<span class="comment">//注意，不能重复，num个数不够4</span>
<span class="comment">//去重，left，right去重，i层循环去重，j层循环去重</span>
    vector&lt;vector&lt;<span class="built_in">int</span>&gt; &gt; fourSum(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>, <span class="built_in">int</span> target) {
        sort(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());
        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; list;
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() &lt; <span class="number">4</span>) 
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.size()-<span class="number">3</span>; i++)
        {
            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num</span>.size()- <span class="number">2</span>; j++)
            {
                <span class="built_in">int</span> left = j + <span class="number">1</span>, right = <span class="built_in">num</span>.size() - <span class="number">1</span>;
                <span class="keyword">while</span>(left &lt; right)
                {
                    <span class="built_in">int</span> sum = <span class="built_in">num</span>[i]+<span class="built_in">num</span>[j]+<span class="built_in">num</span>[left]+<span class="built_in">num</span>[right];
                    <span class="keyword">if</span>(sum &lt; target)
                        left++;
                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)
                        right--;
                    <span class="keyword">else</span>
                    {
                        vector&lt;<span class="built_in">int</span>&gt; vec;
                        vec.push_back(<span class="built_in">num</span>[i]);
                        vec.push_back(<span class="built_in">num</span>[j]);
                        vec.push_back(<span class="built_in">num</span>[left]);
                        vec.push_back(<span class="built_in">num</span>[right]);
                        list.push_back(vec);
                        left++;
                        right--; 
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[left] == <span class="built_in">num</span>[left - <span class="number">1</span>]) 
                            left++;
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[right] == <span class="built_in">num</span>[right + <span class="number">1</span>]) 
                            right--;
                    }
                }
                <span class="keyword">while</span>(j + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">2</span> &amp;&amp; <span class="built_in">num</span>[j] == <span class="built_in">num</span>[j + <span class="number">1</span>]) 
                    j++;
            }
            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">3</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i+<span class="number">1</span>]) 
                i++;
        }
        <span class="keyword">return</span> list;
    }
};
</code></pre><h2 id="二分查找问题">二分查找问题</h2><p>二分查找通用解题思路，left=头指针，right=尾指针，mid=(left+right)/2，通过条件判断，移动left和right最终使得left和right相遇得到最终结果。</p>
<h3 id="普通二分查找">普通二分查找</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个<strong>有序数组，可能含有重复元素</strong>。给定target，寻找target出现的下标，不存在返回-1.</p>
<h4 id="代码-3">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] == target)
            return <span class="built_in">mid</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><h3 id="等于target的第一个元素">等于target的第一个元素</h3><h4 id="问题描述-4">问题描述</h4><p>给定有序数组a,含有重复元素，求最小(或者求最大)的使得a[i]等于target的下标。不存在返回-1.<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnyv9bn30j20fg057q2z.jpg" alt=""></p>
<h4 id="代码-4">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] == target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="小于target的第一个元素">小于target的第一个元素</h3><h4 id="问题描述-5">问题描述</h4><p>给定有序数组a,含有重复元素，求最大的i使得a[i]小于target。不存在返回-1<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewnyykveyaj20bt04edfv.jpg" alt=""></p>
<h4 id="代码-5">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &gt;= target)
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] &lt; target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="求target在数组中的出现次数">求target在数组中的出现次数</h3><h4 id="解法-3">解法</h4><p>出现次数 = 最后一次出现位置 - 第一次出现位置 + 1<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnz2xlz25j20ep05ewek.jpg" alt=""></p>
<h4 id="代码-6">代码</h4><pre><code><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N, <span class="keyword">int</span> <span class="keyword">target</span>)</span>
</span>{
    <span class="keyword">int</span> first = searchFisrt(a, N, <span class="keyword">target</span>);
    <span class="keyword">if</span>(first == -<span class="number">1</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> last = searchLast(a, N, <span class="keyword">target</span>);
    <span class="keyword">return</span> (last - first + <span class="number">1</span>);
}
</code></pre><h3 id="插入的位置（小于等于target的第一个元素）">插入的位置（小于等于target的第一个元素）</h3><h4 id="问题描述-6">问题描述</h4><p>给定有序数组a,含有重复元素，若target在数组中出现，返回位置，如果不存在，返回应该插入的位置。</p>
<h4 id="解法-4">解法</h4><p>&lt;=target是可能的位置<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1ewo0ah8apsj20cf03lgln.jpg" alt=""></p>
<h4 id="代码-7">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt;= target)
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>; 
    }
    return <span class="built_in">left</span>;
}
</code></pre><h2 id="旋转数组的二分查找">旋转数组的二分查找</h2><h3 id="leetcode_33_Search_in_Rotated_Sorted_Array">leetcode 33 Search in Rotated Sorted Array</h3><h4 id="问题描述-7">问题描述</h4><p>给定有序数组，在某一个位置发生旋转，求target在数组中出现的位置。<strong>无重复元素</strong>，找到返回下标，找不到返回-1.</p>
<h4 id="解法-5">解法</h4><p>先判断mid落在了旋转数组的哪一部分，然后判断和target的关系<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewo177qwiyj20c507cq32.jpg" alt=""></p>
<h4 id="代码-8">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int <span class="keyword">left</span> = <span class="number">0</span>,<span class="keyword">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)
        {
            int mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[mid] == target)
                <span class="keyword">return</span> mid;
            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="keyword">left</span>])<span class="comment">//left-mid升序</span>
            {
                <span class="keyword">if</span>(nums[<span class="keyword">left</span>] &lt;= target &amp;&amp; target &lt; nums[mid])
                    <span class="keyword">right</span> = mid-<span class="number">1</span> ;
                <span class="keyword">else</span>
                    <span class="keyword">left</span> = mid+<span class="number">1</span>;
            }
            <span class="keyword">else</span><span class="comment">//mid-right升序</span>
            {
                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="keyword">right</span>])
                    <span class="keyword">left</span> = mid +<span class="number">1</span>;
                <span class="keyword">else</span>
                {
                    <span class="keyword">right</span> = mid-<span class="number">1</span>;
                }
            }
        }
        <span class="keyword">if</span>(nums[<span class="keyword">left</span>] == target)
            <span class="keyword">return</span> <span class="keyword">left</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> -<span class="number">1</span>;
    }
};
</code></pre><h3 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h3><h4 id="问题描述-8">问题描述</h4><p>其他条件相同，但允许数组中存在重复元素。判断target是否出现在数组中。</p>
<h4 id="解法-6">解法</h4><p>增加判断条件，当a[left] = a[mid] = a[right]，直接遍历去寻找，不能使用二分查找</p>
<h4 id="代码-9">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> target) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>,<span class="built_in">right</span> = nums.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == target)
                return <span class="literal">true</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == nums[<span class="built_in">left</span>] &amp;&amp; nums[<span class="built_in">mid</span>] == nums[<span class="built_in">right</span>])
            {
                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; i++)
                {
                    <span class="keyword">if</span>(nums[i] == target)
                        return <span class="literal">true</span>;
                }
                return <span class="literal">false</span>;
            }
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt;= nums[<span class="built_in">left</span>])
            {
                <span class="keyword">if</span>(target &gt;= nums[<span class="built_in">left</span>] &amp;&amp; target &lt; nums[<span class="built_in">mid</span>])
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(target &gt; nums[<span class="built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="built_in">right</span>])
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
            }
        }
        <span class="keyword">if</span>(nums[<span class="built_in">left</span>] == target)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="leetcode_153_Find_Minimum_in_Rotated_Sorted_Array">leetcode 153    Find Minimum in Rotated Sorted Array</h3><h4 id="问题描述-9">问题描述</h4><p>给定有序数组，<strong>无重复元素</strong>，在某一位置发生旋转，求数组中的最小元素</p>
<h4 id="解法-7">解法</h4><p>同上<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewo7wvjpz5j20as05ugln.jpg" alt=""></p>
<h4 id="注意点-1">注意点</h4><ul>
<li>对于数组旋转个数为0的考虑<br>如果使用a[mid] &gt;= a[left]判断，需要考虑数组是否并没有旋转(a[left] &lt; a[right])</li>
<li>也可以使用这样的条件进行判断 a[mid] &gt; a[right]</li>
</ul>
<h4 id="代码-10">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h3 id="leetcode_Find_Minimum_in_Rotated_Sorted_Array_II">leetcode Find Minimum in Rotated Sorted Array II</h3><h4 id="问题描述-10">问题描述</h4><p>同上，不过允许数组中存在重复元素</p>
<h4 id="解法-8">解法</h4><p>对a[mid] = a[right]时，right—。因为a[left] &lt;= a[right] == a[mid],为了使得a[mid]最小，需要对使得left和right逐渐接近，需要遍历才能找到，所以对right进行减一操作。</p>
<h4 id="代码-11">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span>--;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h2 id="一般题目">一般题目</h2><h3 id="剑指offer14_调整数组顺序使奇数位于偶数之前">剑指offer14 调整数组顺序使奇数位于偶数之前</h3><h4 id="问题描述-11">问题描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="解法-9">解法</h4><ul>
<li>使用插入排序的思想，复杂度O(n^2)</li>
<li>使用额外的O(n)存储，遍历原数组，计数从前往后放，偶数从后往前放。时间复杂度O(n)</li>
<li>补充，如果不需要保证相对位置，可以使用快排的partition函数做一次扫描。</li>
</ul>
<h4 id="方法2的代码">方法2的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">array</span>) {
        vector&lt;<span class="built_in">int</span>&gt; vec(<span class="built_in">array</span>.size());
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="built_in">int</span> leftIndex = <span class="number">0</span>, rightIndex = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
                vec[leftIndex++] = <span class="built_in">array</span>[<span class="built_in">left</span>++];
        }
        <span class="keyword">while</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">if</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
                vec[rightIndex--] = <span class="built_in">array</span>[<span class="built_in">right</span>--];
        }
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
            <span class="built_in">array</span>[i] = vec[i];
    }  
};
</code></pre><h4 id="方法3的代码">方法3的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
            {
                <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
                <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
                <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            }
        }
    }
};
</code></pre><h3 id="剑指offer36_数组中的逆序对">剑指offer36 数组中的逆序对</h3><h4 id="问题描述-12">问题描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="解法-10">解法</h4><p>使用归并排序的merge过程，统计逆序对的个数。merge过程需要merge,left~mid和mid~right。假如vec[lpos] &gt; vec[rpos],逆序对的个数需要增加<strong>mid-lpos+1</strong>个，因为vec中所有lpos之后的元素和rpos对应的元素都形成了逆序对。</p>
<h4 id="代码-12">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> InversePairs(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; temp(<span class="type">data</span>.<span class="built_in">size</span>());
        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;
        mergeSort(<span class="type">data</span>, temp, <span class="number">0</span>, <span class="type">data</span>.<span class="built_in">size</span>()-<span class="number">1</span>, <span class="built_in">count</span>);
        <span class="keyword">return</span> <span class="built_in">count</span>;
    }

    void mergeSort(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="keyword">if</span>(left &lt; right)
        {
            <span class="built_in">int</span> mid = (left + right) / <span class="number">2</span>;
            mergeSort(<span class="type">data</span>, temp, left, mid, <span class="built_in">count</span>);
            mergeSort(<span class="type">data</span>, temp, mid + <span class="number">1</span>, right, <span class="built_in">count</span>);
            <span class="built_in">merge</span>(<span class="type">data</span>, temp, left, mid, right, <span class="built_in">count</span>);
        }
    }

    void <span class="built_in">merge</span>(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> mid, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="built_in">int</span> lend = mid, rend = right;
        <span class="built_in">int</span> lpos = left, rpos = mid + <span class="number">1</span>, tpos = left;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(<span class="type">data</span>[lpos] &lt;= <span class="type">data</span>[rpos])
                temp[tpos++] = <span class="type">data</span>[lpos++];
            <span class="keyword">else</span>
            {
                <span class="built_in">count</span> += mid-lpos+<span class="number">1</span>;
                temp[tpos++] = <span class="type">data</span>[rpos++];
            }
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++]=<span class="type">data</span>[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = <span class="type">data</span>[rpos++];
        for(<span class="built_in">int</span> i = left; i &lt;= right; i++)
            <span class="type">data</span>[i] = temp[i];
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/两个指针/"> #两个指针 </a>
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/27/找工作总结-数组专题-出现次数/">
                数组专题-数组中出现的次数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-09-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/找工作总结/">找工作总结</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/09/27/找工作总结-数组专题-出现次数/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/27/找工作总结-数组专题-出现次数/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="通用的几种解题思路">通用的几种解题思路</h2><ul>
<li>使用map记录出现的次数，要求额外增加空间复杂度</li>
<li>所有数字异或可以消灭掉数组中出现偶数次的数字</li>
</ul>
<h3 id="剑指offer51_数组中重复的数字">剑指offer51 数组中重复的数字</h3><h4 id="问题描述">问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h4 id="解法">解法</h4><ul>
<li>排序后扫描，时间复杂度nlogn，空间复杂度O(1)</li>
<li>使用map记录，时间复杂度O(n)，空间复杂度O(n)</li>
</ul>
<h4 id="注意点">注意点</h4><ul>
<li>map的遍历<br><code>map&lt;int, int&gt;::iterator iter;</code><br><code>iter-&gt;first</code> <code>iter-&gt;second</code></li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{
        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;
        <span class="keyword">bool</span> ans = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)
        {
            <span class="keyword">if</span>(dict.count(numbers[i]) == <span class="number">0</span>)
                dict[numbers[i]] = <span class="number">1</span>;
            <span class="keyword">else</span>{
                dict[numbers[i]] += <span class="number">1</span>;
                ans = <span class="keyword">true</span>;
            }
        }
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;
        <span class="keyword">for</span>(iter = dict.begin();iter != dict.end();iter++)
        {
            <span class="keyword">if</span>(iter-&gt;second &gt; <span class="number">1</span>)
            {
                *duplication = iter-&gt;first;
                duplication++;
            }
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer29_数组中出现次数超过一半的数字">剑指offer29 数组中出现次数超过一半的数字</h3><h4 id="问题描述-1">问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<h4 id="解法-1">解法</h4><ul>
<li>使用快排partition函数，扫描一遍数组中间元素就是出现超过一半的数字</li>
<li>使用time记录数字出现的次数，cur记录当前数字</li>
</ul>
<h4 id="注意点-1">注意点</h4><ul>
<li>使用解法2需要判断最后的次数是否真的大于一半，如果不是，返回特定值</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="keyword">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="keyword">int</span>&gt; numbers) {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>) 
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> time = <span class="number">1</span>;
        <span class="keyword">int</span> cur = numbers[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(time == <span class="number">0</span>)
            {
                cur = numbers[i];
                time = <span class="number">1</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == cur)
                time++;
            <span class="keyword">else</span>
                time--;
        }
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == cur)
                <span class="keyword">count</span>++;
        }
        <span class="keyword">if</span>(<span class="keyword">count</span> * <span class="number">2</span> &gt; numbers.<span class="keyword">size</span>())
            <span class="keyword">return</span> cur;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre><h3 id="剑指offer40_数组中只出现一次的数字">剑指offer40 数组中只出现一次的数字</h3><h4 id="问题描述-2">问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解法-2">解法</h4><ul>
<li>对于只有一个数字出现一次，对所有数字做异或操作</li>
<li>有两个数字a,b出现了一次，其它出现偶数次。所有数字异或得temp = a^b，使用result做spliter，每一个数字和temp做与操作，把数组分成两组</li>
</ul>
<h4 id="注意点-2">注意点</h4><ul>
<li>与或非的操作符优先级</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void FindNumsAppearOnce(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>,<span class="built_in">int</span>* num1,<span class="built_in">int</span> *num2) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)
        {
            *num1 = <span class="number">0</span>;
            *num2 = <span class="number">0</span>;
            <span class="keyword">return</span> ;
        }
        <span class="built_in">int</span> temp = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;<span class="type">data</span>.<span class="built_in">size</span>(); i++)
            temp ^= <span class="type">data</span>[i];

        <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="type">data</span>.<span class="built_in">size</span>(); i++)
        {
            <span class="keyword">if</span>((<span class="type">data</span>[i] &amp; temp) == <span class="number">0</span>)
                a ^= <span class="type">data</span>[i];
            <span class="keyword">else</span>
                b ^= <span class="type">data</span>[i];

        }
        *num1 = a;
        *num2 = b;
    }
};
</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数组/"> #数组 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/9674774" alt="Rudy Zhang" />
          <p class="site-author-name">Rudy Zhang</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">50</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/Rudy-Zhang" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/rudy-zhang-93" target="_blank">zhihu</a>
            </span>
            
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Rudy Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'always';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rudy-zhang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
</body>
</html>
