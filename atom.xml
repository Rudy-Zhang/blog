<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Rudy's Blog]]></title>
  <subtitle><![CDATA[seize the day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://rudy-zhang.me/"/>
  <updated>2015-09-28T08:55:21.558Z</updated>
  <id>http://rudy-zhang.me/</id>
  
  <author>
    <name><![CDATA[Rudy Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[数组专题-简单题目]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/"/>
    <id>http://rudy-zhang.me/2015/09/27/找工作总结-数组专题/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-09-28T08:55:21.558Z</updated>
    <content type="html"><![CDATA[<h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法">解法</h4><p>从右上角（这样使得这一行剩余元素都比他小，这一列剩余元素都比他大）向左下角扫描</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> width = <span class="built_in">array</span>[<span class="number">0</span>].size();
        <span class="keyword">int</span> height = <span class="built_in">array</span>.size();
        <span class="keyword">int</span> i = <span class="number">0</span>, j = width - <span class="number">1</span>;
        <span class="keyword">while</span>(i &lt; height &amp;&amp; j &gt;= <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)
                i++;
            <span class="keyword">else</span>
                j--;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer51_数组中重复的数字">剑指offer51 数组中重复的数字</h3><h4 id="问题描述-1">问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h4 id="解法-1">解法</h4><ul>
<li>排序后扫描，时间复杂度nlogn，空间复杂度O(1)</li>
<li>使用map记录，时间复杂度O(n)，空间复杂度O(n)</li>
</ul>
<h4 id="注意点">注意点</h4><ul>
<li>map的遍历<br><code>map&lt;int, int&gt;::iterator iter;</code><br><code>iter-&gt;first</code> <code>iter-&gt;second</code></li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{
        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;
        <span class="keyword">bool</span> ans = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)
        {
            <span class="keyword">if</span>(dict.count(numbers[i]) == <span class="number">0</span>)
                dict[numbers[i]] = <span class="number">1</span>;
            <span class="keyword">else</span>{
                dict[numbers[i]] += <span class="number">1</span>;
                ans = <span class="keyword">true</span>;
            }
        }
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;
        <span class="keyword">for</span>(iter = dict.begin();iter != dict.end();iter++)
        {
            <span class="keyword">if</span>(iter-&gt;second &gt; <span class="number">1</span>)
            {
                *duplication = iter-&gt;first;
                duplication++;
            }
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer29_数组中出现次数超过一半的数字">剑指offer29 数组中出现次数超过一半的数字</h3><h4 id="问题描述-2">问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<h4 id="解法-2">解法</h4><ul>
<li>使用快排partition函数，扫描一遍数组中间元素就是出现超过一半的数字</li>
<li>使用time记录数字出现的次数，cur记录当前数字</li>
</ul>
<h4 id="注意点-1">注意点</h4><ul>
<li>使用解法2需要判断最后的次数是否真的大于一半，如果不是，返回特定值</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="keyword">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="keyword">int</span>&gt; numbers) {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>) 
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> time = <span class="number">1</span>;
        <span class="keyword">int</span> cur = numbers[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(time == <span class="number">0</span>)
            {
                cur = numbers[i];
                time = <span class="number">1</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == cur)
                time++;
            <span class="keyword">else</span>
                time--;
        }
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == cur)
                <span class="keyword">count</span>++;
        }
        <span class="keyword">if</span>(<span class="keyword">count</span> * <span class="number">2</span> &gt; numbers.<span class="keyword">size</span>())
            <span class="keyword">return</span> cur;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre><h3 id="剑指offer40_数组中只出现一次的数字">剑指offer40 数组中只出现一次的数字</h3><h4 id="问题描述-3">问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解法-3">解法</h4><ul>
<li>对于只有一个数字出现一次，对所有数字做异或操作</li>
<li>有两个数字a,b出现了一次，其它出现偶数次。所有数字异或得temp = a^b，使用result做spliter，每一个数字和temp做与操作，把数组分成两组</li>
</ul>
<h4 id="注意点-2">注意点</h4><ul>
<li>与或非的操作符优先级</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void FindNumsAppearOnce(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>,<span class="built_in">int</span>* num1,<span class="built_in">int</span> *num2) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)
        {
            *num1 = <span class="number">0</span>;
            *num2 = <span class="number">0</span>;
            <span class="keyword">return</span> ;
        }
        <span class="built_in">int</span> temp = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;<span class="type">data</span>.<span class="built_in">size</span>(); i++)
            temp ^= <span class="type">data</span>[i];

        <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="type">data</span>.<span class="built_in">size</span>(); i++)
        {
            <span class="keyword">if</span>((<span class="type">data</span>[i] &amp; temp) == <span class="number">0</span>)
                a ^= <span class="type">data</span>[i];
            <span class="keyword">else</span>
                b ^= <span class="type">data</span>[i];

        }
        *num1 = a;
        *num2 = b;
    }
};
</code></pre><h3 id="剑指offer32_整数中1出现的次数（从1到n整数中1出现的次数）">剑指offer32 整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="问题描述-4">问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h4 id="解法-4">解法</h4><p>这个解法对于1-9的原理是一样的。首先找到规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从 1 至  10^i ，在它们右数第  i  位中，任意的 X 都出现了  10^(i−1)  次。这个可以用来计算高位的值。<br>计算方法：<br>当计算右数第  i  位包含的 X 的个数时：<br>取第  i  位左边（高位）的数字，乘以  10^(i−1) ，得到基础值  a 。<br>取第  i  位数字，计算修正值：<br>如果大于 X，则结果为  a+ 10^(i−1)。<br>如果小于 X，则结果为  a。<br>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  (a+b+1) 。<br>例如对于num=52134, i=3, a=52, b=34, i位数字k=1,k=x故 result=a+b+1<br>解释，a等于0~51，可推出高位的结果，a=52时，讨论低位的结果。</p>
<h4 id="代码-4">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">int</span> NumberOf1Between1AndN_Solution(<span class="keyword">int</span> n)
    {
        <span class="keyword">int</span> x = <span class="number">1</span>;
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>, k;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)
        {
            k = n / i;
            <span class="comment">//k/10为高位数字</span>
            <span class="keyword">count</span> += (k / <span class="number">10</span>) * i;
            <span class="keyword">int</span> cur = k % <span class="number">10</span>;
            <span class="keyword">if</span>(cur &gt; x)
                <span class="keyword">count</span>+=i;               
            <span class="keyword">else</span> <span class="keyword">if</span>(cur == x)
                <span class="comment">//n%i为低位数字</span>
                <span class="keyword">count</span> += n % i + <span class="number">1</span>;
            <span class="keyword">else</span>{}
        }
        <span class="keyword">return</span> <span class="keyword">count</span>;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数]]>
    </summary>
    
      <category term="啊啊" scheme="http://rudy-zhang.me/tags/%E5%95%8A%E5%95%8A/"/>
    
      <category term="版本" scheme="http://rudy-zhang.me/tags/%E7%89%88%E6%9C%AC/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串专题]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/"/>
    <id>http://rudy-zhang.me/2015/09/27/找工作总结-字符串专题/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-09-27T11:56:15.393Z</updated>
    <content type="html"><![CDATA[<h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一遍，记录空格个数。申请newSize，从后向前填充数组。</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string replaceSpace(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="built_in">int</span> numOfSpace=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">str</span>.<span class="built_in">size</span>();++i)
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
                ++numOfSpace;
        <span class="built_in">int</span> newSize=<span class="built_in">str</span>.<span class="built_in">size</span>()+<span class="number">2</span>*numOfSpace;
        string ans;
        ans.resize(newSize);
        <span class="built_in">int</span> i=<span class="built_in">str</span>.<span class="built_in">size</span>()-<span class="number">1</span>,j=newSize-<span class="number">1</span>;
        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)   
        {
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
            {
                ans[j--]=<span class="string">'0'</span>;
                ans[j--]=<span class="string">'2'</span>;
                ans[j--]=<span class="string">'%'</span>;
                --i;
            }
            <span class="keyword">else</span>
                ans[j--]=<span class="built_in">str</span>[i--];
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer54_表示数值的字符串">剑指offer54 表示数值的字符串</h3><p>问题描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>解法：首先可以写出这个字符串的正则表达式</p>
<pre><code>(+|-)？\<span class="keyword">d</span>+(.\<span class="keyword">d</span>+)?(<span class="keyword">e</span>|<span class="literal">E</span>(+|-)?\<span class="keyword">d</span>+)?
</code></pre><p>对于正则表达式中的符号，<code>?</code>表示0或1，使用<code>if</code>判断，+表示1或者更多，直接扫描判断。</p>
<p>注意点：<br>(1) 非法输入，传入str == NULL<br>(2) 结束条件的判断</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isNumeric(<span class="keyword">char</span>* <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'.'</span>)
        {
            <span class="keyword">str</span>++;
            <span class="comment">//根据题目要求是否允许"32."这样的数据</span>
            <span class="comment">//if(*str == '\0')</span>
            <span class="comment">//    return false;</span>
            scanDigits(<span class="keyword">str</span>);
        }
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'e'</span> || *<span class="keyword">str</span> == <span class="string">'E'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">void</span> scanDigits(<span class="keyword">char</span> *(&amp;<span class="keyword">str</span>))
    {
        <span class="keyword">while</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'9'</span>)
            <span class="keyword">str</span>++;
    }
};
</code></pre><h3 id="剑指offer55_字符流中第一个不重复的字符">剑指offer55 字符流中第一个不重复的字符</h3><p>问题描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>解法：字符只有256个，所以可以使用<code>int dict[256]</code>数组来记录所有字符出现的情况。0表示未出现过，-1表示出现过大于1次，&gt;0时dict[i]表示字符i第一次出现的index</p>
<p>注意点：<br>通过遍历dict[26]找到minIndex找到<strong>第一次出现</strong>的字符</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>
</span>{
<span class="keyword">public</span>:
      <span class="comment">//Insert one char from stringstream</span>
    <span class="keyword">void</span> Insert(<span class="keyword">char</span> ch)
    {
        <span class="keyword">if</span>(dict[ch] == <span class="number">0</span>) <span class="comment">//没出现过</span>
            dict[ch] = <span class="keyword">index</span>;
        <span class="keyword">else</span> <span class="comment">//出现过</span>
            dict[ch] = -<span class="number">1</span>;
        <span class="keyword">index</span>++;
    }
      <span class="comment">//return the first appearence once char in current stringstream</span>
    <span class="keyword">char</span> FirstAppearingOnce()
    {
        <span class="keyword">char</span> ans=<span class="string">'#'</span>;
        <span class="keyword">int</span> minIndex = INT_MAX;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
        {
            <span class="keyword">if</span>(dict[i] &gt; <span class="number">0</span> &amp;&amp; dict[i] &lt; minIndex)
            {
                ans = i;
                minIndex = dict[i];
            }
        }
        <span class="keyword">return</span> ans;
    }

    Solution()
    {
        <span class="keyword">index</span> = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
            dict[i] = <span class="number">0</span>;
    }
<span class="keyword">private</span>:
    <span class="keyword">int</span> dict[<span class="number">256</span>];
    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">1</span>;
};
</code></pre><h3 id="剑指offer42_反转单词顺序_VS_左旋字符串">剑指offer42 反转单词顺序 VS 左旋字符串</h3><p>反转字符串函数：</p>
<pre><code>void reverseString(<span class="built_in">string</span> &amp;str, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        char temp = str[<span class="built_in">left</span>];
        str[<span class="built_in">left</span>] = str[<span class="built_in">right</span>];
        str[<span class="built_in">right</span>] = temp;
        <span class="built_in">left</span>++;
        <span class="built_in">right</span>--;
    }
}
</code></pre><h4 id="反转单词顺序">反转单词顺序</h4><p>问题描述：JOBDU最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>解法：先反转每一个单词，再反转整句</p>
<p>注意点：</p>
<ol>
<li>功能测试：”student. a am I”</li>
<li>特殊测试用例”aaa “,” aaa”</li>
</ol>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string ReverseSentence(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;
        <span class="keyword">while</span>(right &lt; <span class="built_in">str</span>.<span class="built_in">size</span>())
        {
            <span class="keyword">while</span>(<span class="built_in">str</span>[left] == <span class="string">' '</span>)
            {
                left++;
                right++;
            }
            <span class="comment">//应对用例"aa "</span>
            <span class="keyword">if</span>(left &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>()) 
                <span class="keyword">break</span>;
            <span class="keyword">while</span>(<span class="built_in">str</span>[right] != <span class="string">' '</span> &amp;&amp; <span class="built_in">str</span>[right] != <span class="string">'\0'</span>)
                right++;
            reverseString(<span class="built_in">str</span>,left,right-<span class="number">1</span>);
            left = right;
        }
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre><h4 id="左旋字符串">左旋字符串</h4><p>问题描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>解法：先反转3分割的两部分，再旋转这个字符串</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string LeftRotateString(string <span class="built_in">str</span>, <span class="built_in">int</span> n) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="keyword">if</span>(n &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, n - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, n, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一]]>
    </summary>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://rudy-zhang.me/2015/09/27/排序算法总结/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-09-27T08:15:56.891Z</updated>
    <content type="html"><![CDATA[<h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>void insertSort(int a[], int N)
<span class="comment">{
    for(int i = 1; i &lt; N; i++)
    {
        int temp = a[i];
        int j;
        for(j = i; j &gt; 0 &amp;&amp; temp &lt; a[j-1]; j--)
            a[j] = a[j-1];
        a[j] = temp;
    }</span>
}
</code></pre><h3 id="希尔排序">希尔排序</h3><p>原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<blockquote>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> incre = N / <span class="number">2</span>; incre &gt; <span class="number">0</span>; incre /= <span class="number">2</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = incre; i &lt; N; i++)
        {
            <span class="keyword">int</span> temp = a[i];
            <span class="keyword">int</span> j;
            <span class="keyword">for</span>(j = i; j &gt;= incre &amp;&amp; temp &lt; a[j - incre]; j -= incre)
                a[j] = a[j - incre];
            a[j] = temp;
        }
    }
}
</code></pre><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。</p>
<pre><code>void bubbleSort(int <span class="literal">a</span>[], int N)
{
    for(int i = <span class="number">0</span><span class="comment">; i &lt; N; i++)</span>
    {
        for(int j = i<span class="comment">; j &lt; N - i - 1; j++)</span>
        {
            <span class="keyword">if</span>(<span class="literal">a</span>[j] &gt; <span class="literal">a</span>[j+<span class="number">1</span>])
            {
                int temp = <span class="literal">a</span>[j]<span class="comment">;</span>
                <span class="literal">a</span>[j] = <span class="literal">a</span>[j+<span class="number">1</span>]<span class="comment">;</span>
                <span class="literal">a</span>[j+<span class="number">1</span>] = temp<span class="comment">;</span>
            }
        }
    }
}
</code></pre><p>补充说明：使用didSwap=true/false可以避免重复的比较，使得最好情况的复杂度变为O(n)</p>
<h3 id="快速排序">快速排序</h3><p>原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>实现：</p>
<pre><code>void quickSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> temp = a[<span class="built_in">left</span>];
        <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">right</span>;
        <span class="keyword">while</span>(i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &lt;= a[j])
                j--;
            <span class="keyword">if</span>(i &lt; j)
                a[i++] = a[j];
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &gt;= a[i])
                i++;
            <span class="keyword">if</span>(i &lt; j)
                a[j--] = a[i];
        }
        a[i] = temp;
        quickSortCore(a, <span class="built_in">left</span>, i-<span class="number">1</span>);
        quickSortCore(a, i+<span class="number">1</span>, <span class="built_in">right</span>);
    }

}

void quickSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    quickSortCore(a, <span class="number">0</span>, N-<span class="number">1</span>);
}
</code></pre><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p>原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)
    {
        <span class="keyword">int</span> k = i;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)
        {
            <span class="keyword">if</span>(a[j] &lt; a[k])
                k = j;
        }
        <span class="keyword">int</span> temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
}
</code></pre><h3 id="堆排序">堆排序</h3><p>堆序性质： 堆分为大顶堆和小顶堆，满足<code>Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code>称为大顶堆，满足 <code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]</code>称为小顶堆。</p>
<p>原理：利用大顶堆或小顶堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。如从小到大排序，建立大顶堆，堆顶元素与堆尾不断交换，同时缩小堆的范围，最终得到排序结果。</p>
<pre><code>void percDown(int a[], int i, int N)
<span class="comment">{
    int temp = a[i], child;
    for(; 2 * i + 1 &lt; N; i = child)
    {
        child = 2 * i + 1;
        if(child + 1 &lt; N &amp;&amp; a[child] &lt; a[child + 1])
            child++;
        if(temp &lt; a[child])
            a[i] = a[child];
        else
            break;
    }</span>
    a[i] = temp;
}

void heapSort(int a[], int N)
<span class="comment">{
    for(int i = N / 2; i &gt;= 0; i--)
        percDown(a, i, N);
    for(int i = N-1; i &gt; 0; i--)
    {
        int temp = a[i];
        a[i] = a[0];
        a[0] = temp;
        percDown(a, 0, i);
    }</span>
}
</code></pre><h2 id="归并排序">归并排序</h2><p>原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。</p>
<pre><code>void merge(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> lpos = <span class="built_in">left</span>, lend = <span class="built_in">mid</span>;
        <span class="built_in">int</span> rpos = <span class="built_in">mid</span> + <span class="number">1</span>, rend = <span class="built_in">right</span>;
        <span class="built_in">int</span> tpos = <span class="built_in">left</span>;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(a[lpos] &lt;= a[rpos])
                temp[tpos++] = a[lpos++];
            <span class="keyword">else</span>
                temp[tpos++] = a[rpos++];
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++] = a[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = a[rpos++];
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">right</span>; i++)
            a[i] = temp[i];
    }
}
void mergeSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
        mergeSortCore(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>);
        mergeSortCore(a, temp, <span class="built_in">mid</span>+<span class="number">1</span>, <span class="built_in">right</span>);
        merge(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);
    }
}
void mergeSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    <span class="built_in">int</span> *temp = <span class="keyword">new</span> <span class="built_in">int</span>[N];
    mergeSortCore(a, temp, <span class="number">0</span>, N-<span class="number">1</span>);
    delete [] temp;
}
</code></pre><h2 id="各种排序算法的复杂度稳定性分析">各种排序算法的复杂度稳定性分析</h2><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">复杂度分析</th>
<th>稳定性</th>
<th>稳定性原因分析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">简单插入</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">平均接近nlogn,最好O(n),最坏O(n^2)</td>
<td>不稳定</td>
<td>增量分组，有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">交换排序</td>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">平均nlogn,最好nlogn,最坏O(n^2)</td>
<td>不稳定</td>
<td>有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">直接选择</td>
<td style="text-align:left">平均O(n^2),最好O(n^2),最坏O(n^2)</td>
<td>不稳定</td>
<td>5 8 5 2</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">平均,最好,最坏nlogn</td>
<td>不稳定</td>
<td>3 2 3 2</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">平均,最好,最坏nlogn，有O(n)空间复杂度</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
</tbody>
</table>
<h2 id="扩展问题">扩展问题</h2><ul>
<li>单链表可以做快速排序吗？为什么？</li>
</ul>
<p>可以。快速排序的核心函数partition，选择某个元素为枢纽元x(通常是第一个)，一遍扫描之后使得比x小的在枢纽元左边，比x大的在枢纽元的右边。使用链表时，x指向链表头(枢纽元)，扫描这个链表，小元素拼在链表头，大元素拼在链表尾部，从而完成一次partition函数的流程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>vo]]>
    </summary>
    
      <category term="排序" scheme="http://rudy-zhang.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://rudy-zhang.me/2015/08/21/effectiveCPP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rudy-zhang.me/2015/08/21/effectiveCPP读书笔记/</id>
    <published>2015-08-20T23:23:33.000Z</published>
    <updated>2015-08-30T07:56:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C++ 使用模板编程</li>
<li>STL</li>
</ul>
<p>每一个部分都有各自的规约</p>
<h2 id="条款2，_尽量以const，enum，inline替换#define">条款2， 尽量以const，enum，inline替换#define</h2><ul>
<li>#define只有替换功能，在预处理阶段完成，没有<strong>类型检查</strong>，也没有封装性</li>
<li>使用const替代变量定义，inline替代函数定义</li>
<li>预处理器中，#include必不可少，#ifdef，#else可以用来进行控制编译</li>
</ul>
<h2 id="条款3，尽可能使用const">条款3，尽可能使用const</h2><p>只要是事实，就把它说出来。只要是const就要声明为const类型。</p>
<ul>
<li>const修饰变量<br>const char <em>p = greeting等价于char const </em>p = greeting<br>char * const p = greeting 指针不可更改指向对象</li>
<li>const修饰函数，是最有威力的应用</li>
</ul>
<p>(1) const 返回值</p>
<p>(2) const 函数参数，使用最多</p>
<p>(3) const 成员函数，表明这个函数不能修改任何成员变量（static变量可以修改），也不能调用任何非const成员</p>
<p>补充，<br>volidate int a，告诉编译器这个值可能被未知因素修改，每次都要从内存中重新读取<br>mutable int a，可以突破const成员函数限制，在函数中被修改</p>
<h2 id="条款4，确定对象被使用前已先被初始化">条款4，确定对象被使用前已先被初始化</h2><ul>
<li><p>成员初始化应该在构造函数之前，意味着要使用<strong>成员初始化列表</strong>进行成员变量的初始化<br>说明：成员变量总是以声明的次序被初始化</p>
</li>
<li><p>对于static变量，使用Singleton+inline，保证在对象使用前初始化</p>
</li>
</ul>
<h2 id="条款5，了解C++默默编写并调用了哪些函数">条款5，了解C++默默编写并调用了哪些函数</h2><p>构造函数，拷贝构造函数，赋值函数，析构函数</p>
<h2 id="条款6，若不想使用编译器自动生成的函数，就该明确拒绝">条款6，若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul>
<li>如果某些对象不可复制（不能使用copy constructor）<br>不是很安全的做法：把拷贝构造函数声明为private<br>更好的做法：写一个<strong>UnCopyable基类</strong>，copy constructor声明为private</li>
</ul>
<h2 id="条款7，为多态基类声明virtual析构函数">条款7，为多态基类声明virtual析构函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span></span>{}
A *b=<span class="keyword">new</span> B()
<span class="keyword">delete</span> b
</code></pre><p>因为b是A类型的指针，所以会导致局部销毁（只有A的部分被销毁）</p>
<p>原则：</p>
<ul>
<li><strong>企图作为（多态的）base class的类理论上都应该有virtual函数</strong>，否则不应该作为base class（虚指针会额外增加空间）</li>
<li>任何带有virtual 函数的类都应该把析构函数声明为virtual<br>不要试图继承任何STL容器，因为他们没有virtual的析构函数</li>
</ul>
<h2 id="条款8，别让异常逃离析构函数">条款8，别让异常逃离析构函数</h2><ul>
<li>析构函数不能抛出异常，否则会导致不明行为。</li>
<li>析构函数应该吞下这个异常，防止传播</li>
<li><strong>调用一个自己的函数，使得用户有机会来处理这个异常</strong>。 </li>
</ul>
<h2 id="条款9，_绝不要在构造或者析构过程中调用virtual函数">条款9， 绝不要在构造或者析构过程中调用virtual函数</h2><ul>
<li><p>构造过程</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:     
    A(){
         virtual <span class="function"><span class="title">fun</span><span class="params">()</span></span>
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{}</span></span>
B b;
</code></pre></li>
</ul>
<p>构造B-&gt;构造A-&gt;调用fun(),这时B还没构造完（被编译器看成A对象），导致virtual 函数不会下降到子类执行。</p>
<ul>
<li>析构过程<br>析构B-&gt;析构A-&gt;调用fun()，这时B已经被析构掉了，同样virtual函数不会下降，得不到想要的结果。</li>
</ul>
<h2 id="条款10，令operator=_返回一个reference_to_*this">条款10，令operator= 返回一个reference to *this</h2><p>为了保证连续运算如：A=B=C 相当于A = (B = C)<br>返回一个引用，不会调用copy constructor<br>对于+=同样适用</p>
<h2 id="条款11，在operator=_中处理自我赋值">条款11，在operator= 中处理自我赋值</h2><p>判断一下，if (this == &amp;rhs) return *this</p>
<h2 id="条款12，复制对象时勿忘其每一个成分">条款12，复制对象时勿忘其每一个成分</h2><p>可能出现的问题</p>
<p>（1）对象中的非内置类型不能得到赋值</p>
<p>（2）对象从父类继承而来的变量不能得到赋值</p>
<ul>
<li>赋值所有local成员（内置类型，对象）</li>
<li>调用所有base class中的适当的copy constructor</li>
</ul>
<h2 id="条款13，以对象管理资源">条款13，以对象管理资源</h2><p>C++申请释放的资源：堆内存（最常用），文件，互斥锁，数据库连接等。一旦申请资源，就必须释放，否则就会造成内存泄露。</p>
<p>以对象管理资源相当于，使用一个类（RAII类）封装这个资源，在构造时初始化，在析构时释放。声明这个对象时使用栈内存声明。</p>
<p>常用：</p>
<p><code>auto_ptr</code> ,封装对象，重写了指针行为，看起来像一个指针。只能指向一个对象。复制或者赋值，会删除原来的指针。</p>
<p><code>shared_ptr</code>，类似于auto_ptr，不过允许多个指针指向同一个对象，内部提供引用计数。<br>这两个是最常见的RAII类，在构造时初始化，析构时delete。（注意不能<code>auto_ptr</code>(new std::string[10])数组对象）</p>
<h2 id="条款14，在资源管理类中小心copying行为">条款14，在资源管理类中小心copying行为</h2><p>类似于<code>auto_ptr</code>或者<code>shared_ptr</code>的处理方式，对于复制。可以：</p>
<ul>
<li>禁止复制</li>
<li>引用计数，类似于shared_ptr</li>
</ul>
<h2 id="条款15，在资源管理类中提供对原始资源的访问">条款15，在资源管理类中提供对原始资源的访问</h2><p>隐式：如<code>auto_ptr</code>重写了指针行为，*ptr,<code>ptr-&gt;</code>使得这个变量看起来像一个指针。从而可以访问封装的资源</p>
<p>显示：提供get()函数返回资源</p>
<h2 id="条款16，使用new和delete时要采用相同的形式">条款16，使用new和delete时要采用相同的形式</h2><p>A *a=new A() ,释放时 使用delete a</p>
<p>int *a=new a[100],释放时使用delete []a</p>
<h2 id="条款17，以独立语句将newed对象置入智能指针">条款17，以独立语句将newed对象置入智能指针</h2><pre><code>std::tr1::shared_ptr&lt;Widget&gt; <span class="function"><span class="title">pw</span><span class="params">(new Widget)</span></span>
<span class="function"><span class="title">processWidget</span><span class="params">(pwd, priority()</span></span>)
</code></pre><p>使用单独语句，不要放到一起可能会造成编译先后导致指针丢失。<br>其实不是很明白这点</p>
<h2 id="条款18，让接口容易被使用，不易被误用">条款18，让接口容易被使用，不易被误用</h2><ul>
<li><p>导入新类型</p>
<pre><code><span class="built_in">Date</span>(<span class="built_in">int</span> <span class="built_in">month</span>, <span class="built_in">int</span> <span class="built_in">day</span>, <span class="built_in">int</span> <span class="built_in">year</span>)
</code></pre></li>
</ul>
<p>多个参数，使用Month，Day，Year类型，可以预防接口被误用</p>
<ul>
<li>接口一致性</li>
</ul>
<p>如:stl每个容器都有size()方法</p>
<h2 id="条款19，设计class犹如设计type">条款19，设计class犹如设计type</h2><p>设计一个类时需要考虑很多问题：</p>
<ol>
<li>创建和销毁</li>
<li>初始化（初始化列表），拷贝构造函数</li>
<li>pass by value &amp;&amp; pass by reference</li>
<li>继承关系</li>
<li>类型转换</li>
<li>操作符重载</li>
<li>标准函数驳回（private copy constructor）</li>
<li>public private</li>
<li>效率，异常</li>
<li>不够一般化，太过一般化</li>
<li>是否真的需要这个类型</li>
</ol>
<h2 id="条款20，_宁以pass_by_reference_to_const_替换_pass_by_value">条款20， 宁以pass by reference to const 替换 pass by value</h2><ul>
<li>区别</li>
</ul>
<p>pass by value:</p>
<p>要调用copy constructor，可能是费时的操作</p>
<p>pass by reference to const:</p>
<p>const Student &amp;s，const保证变量在函数内不会被修改</p>
<ul>
<li><p>pass by value可能导致多态失效</p>
<pre><code><span class="keyword">void</span> printNameAndDisplay（Window w）
</code></pre></li>
</ul>
<p>传入子类对象，不能实现多态</p>
<ul>
<li>在编译器底层，reference是通过指针来实现的</li>
</ul>
<h2 id="条款21，必须返回对象时，别妄想返回其reference">条款21，必须返回对象时，别妄想返回其reference</h2><pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator* (<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs)
</code></pre><p>如果返回reference</p>
<ul>
<li>返回local stack的对象（Rational r），则函数退出时，这个对象已经被销毁了</li>
<li>返回heap-allocate对象，会造成何时delete的问题。</li>
<li>返回static对象，if(a<em>b == c</em>d),导致一个static对象不够用的问题</li>
</ul>
<p>原则，必须在返回reference和object作出一个选择，程序员的工作就是选出正确的那个</p>
<h2 id="条款22，将变量声明为private">条款22，将变量声明为private</h2><ul>
<li>public接口内全部都是函数，可以产生用户使用这个类时，良好的一致性</li>
<li>private parameter可以产生封装的效果，封装使得变更更加容易</li>
<li>假如有一个public变量，如果取消它，所有使用它的客户代码都会被破坏<br>假如有一个protect变量，如果取笑它，所有使用它的derived class都会被破坏<br>所以protect并不比public更具有封装性</li>
</ul>
<h2 id="条款23，宁以non-member、non-friend替换member函数">条款23，宁以non-member、non-friend替换member函数</h2><ul>
<li>多个操作具有先后顺序，应该把他们绑定到一起</li>
<li>封装-&gt;客户端难修改-&gt;更多弹性去改变</li>
<li>non-member（non-friend）函数VSmember函数</li>
</ul>
<p>non-member函数不能访问private成分，提供更大的封装性</p>
<h2 id="条款24，若所有参数皆需类型转换，请为此采用non-member函数">条款24，若所有参数皆需类型转换，请为此采用non-member函数</h2><p>实现有理数类Rational，乘法的操作符重载<br>开始可能会向使用成员函数的写法 </p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp; rhs) <span class="keyword">const</span>
</code></pre><p>但是希望完成乘法交换律</p>
<pre><code><span class="type">Rational</span> r
<span class="type">Rational</span> <span class="literal">result</span> = <span class="number">2</span> * r
</code></pre><p>需要对2进行隐式类型转换，方法</p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs) 
</code></pre><p>使用non-member函数。</p>
<p>不是很明白</p>
<h2 id="条款25，考虑写出一个不抛出异常的swap函数">条款25，考虑写出一个不抛出异常的swap函数</h2><p>std::swap(T&amp; a, T&amp; b)可以对两个对象进行交换</p>
<p>如果这样做的效率不高，可以考虑自己写一个不会抛出异常的swap成员函数</p>
<p>例如：stl 容器中就有很多swap函数，只交换指针，而不会复制对象。</p>
<ol>
<li>自行实现这样一个swap成员函数(可以使用std::swap调换指针)</li>
<li>在命名空间内提供一个swap<widget>(Widget &amp;a,Widget &amp;b)去实现一个非成员函数来调用前者。</widget></li>
</ol>
<h2 id="条款26，尽可能延后变量定义式的出现时间">条款26，尽可能延后变量定义式的出现时间</h2><p>对变量进行定义，意味着承受构造的成本。</p>
<p>原则：应该延后变量定义到使用前的一刻为止。</p>
<h2 id="条款27，尽量少做转型动作">条款27，尽量少做转型动作</h2><p>C风格的转型</p>
<pre><code><span class="list">(<span class="keyword">int</span>)</span><span class="number">2.1</span>
int<span class="list">(<span class="number">2.1</span>)</span>
</code></pre><p>C++的新式转型：</p>
<ul>
<li><code>const_cast&lt;T&gt;(expression)</code> 将对象的常量性移除</li>
<li><code>dynamic_cast&lt;T&gt;(expression)</code> 主要用来进行安全向下转型<br>例如：只有基类可以使用，但是想调用子类的函数。尝试使用多态来代替。</li>
<li><code>static_cast&lt;T&gt;(expression)</code> 主要用来强制类型转换<br>例如：<code>static_cast&lt;int&gt;(2.1)</code><br>尽量使用C++风格的转型</li>
</ul>
<h2 id="条款28，避免返回handles指向对象内部成分">条款28，避免返回handles指向对象内部成分</h2><pre><code><span class="keyword">class</span> <span class="title">A</span>{
<span class="keyword">public</span>：
     <span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span>;
}
<span class="keyword">class</span> <span class="title">B</span>{
<span class="keyword">private</span>:
     A *a
}
</code></pre><p>如果在B类中提供<code>A&amp;</code>的返回（假设为rt），那么用户可以调用<code>rt.func()</code>修改B中的private成员了。<br>这是一种放松封装的行为。</p>
<h2 id="条款29，为“异常安全”而努力是值得的">条款29，为“异常安全”而努力是值得的</h2><p>异常安全的函数提供以下三个保证之一（从弱到强）：</p>
<ul>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下</li>
<li>强烈保证：函数调用成功，则完全成功。函数调用失败，则程序回复到调用之前的状态</li>
<li>nothrow：保证绝对不抛出异常。（通常完全使用内置类型的操作，提供不抛出异常的保证）<br>一个软件系统，要么具备异常安全性，要么不具备。只提供部分异常安全性函数，不能叫做具备异常安全性的系统。<br>以对象管理资源，是一种很好的防止内存泄露，保证异常安全性的方法。</li>
</ul>
<h2 id="条款30，透彻了解inlining的里里外外">条款30，透彻了解inlining的里里外外</h2><ul>
<li>inline函数意味着对这个函数的每一次调用，使用函数本体替换</li>
</ul>
<p>好处：减少调用成本</p>
<p>坏处：增加代码体积</p>
<ul>
<li>inline函数适合小型被频繁调用的函数</li>
</ul>
<p>函数内部有for循环不适合inline，因为本身的开销已经够大，减少调用的开销意义不大。</p>
<ul>
<li>inline只是一个向编译器发出的申请，编译器可以忽略它。</li>
</ul>
<p>如编译器拒绝复杂函数inline(带有递归，循环),virtual函数也会使inline落空。</p>
<h2 id="条款31，将文件间的编译依存关系降到最低">条款31，将文件间的编译依存关系降到最低</h2><p>方法1，使用Handle class</p>
<p>增加一个实现类去真正实现类的功能，原来的类只维护一个指向实现类的指针</p>
<p>方法2，使用Interface class</p>
<p>基类是虚基类，不包括任何成员变量。</p>
<h2 id="条款32，确定你的public继承是is-a的关系">条款32，确定你的public继承是is-a的关系</h2><p>如题</p>
<h2 id="条款33，避免遮掩继承而来的名称">条款33，避免遮掩继承而来的名称</h2><p>假如：Derived:Base</p>
<p>当编译器通过函数名称去找相应函数，会先从Derived类作用域找，然后再从Base类的作用域找<br>当使用函数重载的时候就可能出现问题。</p>
<p>使用using Base::func可以避免这种情况。 </p>
<h2 id="条款34，区分接口继承和实现继承">条款34，区分接口继承和实现继承</h2><ul>
<li>对于non-virtual函数的继承</li>
</ul>
<p>意味着，子类必须有和父类一样的实现</p>
<ul>
<li>对于virtual</li>
</ul>
<p>（1）pure-virtual, 只继承接口，意味着每个子类的行为都很有可能不一样</p>
<p>（2）imprure-virtual， 提供缺省的实现，意味着有一些子类的行为可能一样</p>
<p>可以使用pure-virtual+缺省行为分离(另外写一个函数)的方法，解决有可能子类在不知情的情况下继承了并不需要的缺省的实现。 </p>
<h2 id="条款35，考虑virtual函数以外的其他选择">条款35，考虑virtual函数以外的其他选择</h2><ul>
<li><p>NVI Non-virtual Interface<br>使用public non-virtual 函数调用private virtual函数(做一下修饰而已)</p>
</li>
<li><p>使用函数指针</p>
</li>
<li><p>使用tr1::function封装函数指针，代替函数指针的行为</p>
</li>
<li><p>使用strategy设计模式</p>
</li>
</ul>
<p>将想要virtual的行为封装成一个类(Calculator)，在类内部进行多态计算，通过传入的对象指针来判断。</p>
<h2 id="条款36，绝不重新定义继承而来的non-virtual函数">条款36，绝不重新定义继承而来的non-virtual函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{</span></span>
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
A *ptA=new B()
B *ptB=new B()
</code></pre><p>ptA-&gt;fun()调用A中的fun<br>ptB-&gt;fun()调用B中的fun<br>因为non-virtual函数不能进行动态绑定，调用函数只跟指针类型有关，所以</p>
<ol>
<li>不要重写父类的non-virtual函数</li>
<li>父类的non-virtual函数意味着，所有子类的实现都是这样</li>
</ol>
<h2 id="条款37，绝不重新定义进程而来的缺省参数值">条款37，绝不重新定义进程而来的缺省参数值</h2><p>缺省参数都是静态绑定的，即使是在virtual的函数中</p>
<h2 id="条款38，复合（组合）是has-a的关系">条款38，复合（组合）是has-a的关系</h2><h2 id="条款39，明智而审慎地使用private继承">条款39，明智而审慎地使用private继承</h2><p>private继承意味着所有父类的成员在子类中都变为private，</p>
<p>好处：可以让基类部分最优化，减少尺寸。</p>
<h2 id="条款40，明智而审慎地使用多重继承">条款40，明智而审慎地使用多重继承</h2><ul>
<li>一个class继承自多个base class，那么父类成分有相同函数，就需要显示指定。</li>
<li>对于钻石型继承，B:A,C:A,D:B,D:C，需要指定虚继承，来避免重复继承A中的成分</li>
<li>虚继承需要编译器做很多工作，要付出一定成本，一般不用。</li>
<li>如果有单一继承可以满足需求，一般这个方案一定比多重继承要好。</li>
</ul>
<h2 id="条款41，了解隐式接口和编译器多态">条款41，了解隐式接口和编译器多态</h2><ul>
<li><p>运行时多态，通过虚指针和虚函数实现</p>
</li>
<li><p>编译时多态</p>
</li>
</ul>
<p>(1) 函数重载，相同函数名不同参数列表</p>
<p>(2) 在模板特化的时候，根据类型生成具体的函数</p>
<h2 id="条款42，了解typename的双重意义">条款42，了解typename的双重意义</h2><pre><code><span class="keyword">template</span>&lt; class T&gt; class <span class="type">Widget</span>;
<span class="keyword">template</span>&lt;typename T&gt;class <span class="type">Widget</span>;
</code></pre><p>并没有什么不同</p>
<p>当使用嵌套从属名称，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename C&gt;
typename C::const_iterator iter(container.begin())
</code></pre><p>const_iterator是依赖于C的名称，这时候必须用typename</p>
<h2 id="条款43，学习处理模板化基类内的名称">条款43，学习处理模板化基类内的名称</h2><p>对于模板C++的继承，由于基类模板可能被特化，特化使得基类内的成员不确定，C++会拒绝从模板化基类中寻找继承而来的名称</p>
<p>解决办法：</p>
<ol>
<li>在使用base class之前使用this-&gt;</li>
<li>使用using</li>
</ol>
<h2 id="条款44，将与参数无关的代码抽离templates">条款44，将与参数无关的代码抽离templates</h2><p>使用带参template可能会引起代码膨胀，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename T,std:size_t n&gt;
</code></pre><p>解决办法：<br>使用模板父类去处理由于size_t而造成的代码膨胀的问题</p>
<h2 id="条款45，运用成员函数模板接受所有兼容类型的参数">条款45，运用成员函数模板接受所有兼容类型的参数</h2><ul>
<li>智能指针是使用模板实现的，那如果我们要智能指针之间（具有继承关系的）能够相互转化，赋值，解决办法：</li>
<li>使用成员函数模板，对兼容的类型进行构造和赋值</li>
</ul>
<h2 id="条款46，需要类型转换时请为模版定义非成员函数">条款46，需要类型转换时请为模版定义非成员函数</h2><pre><code><span class="type">Rational</span>&lt;<span class="type">int</span>&gt; a(<span class="number">1</span>,<span class="number">2</span>);
<span class="type">Rational</span>&lt;<span class="type">int</span>&gt; <span class="literal">result</span> = a*<span class="number">2</span>; // <span class="type">Error</span>
</code></pre><p>模板化实例，不进行隐式类型转换，使用friend方法。</p>
<h2 id="条款47，请使用traits_classes表现类型信息">条款47，请使用traits classes表现类型信息</h2><p>引用：</p>
<blockquote>
<p>traits class是个类模板，在不修改一个实体（通常是数据类型或常量）的前提下，把属性和方法关联到一个编译时的实体。在c++中的具体实现方式是：首先定义一个类模板，然后进行显式特化或进行相关类型的部分特化。<br>我的理解是：traits是服务于泛型编程的，其目的是让模板更加通用，同时把一些细节向普通的模板用户隐藏起来。当用不同的类型去实例化一个模板时，不可避免有些类型会存在一些与众不同的属性，若考虑这些特性的话，可能会导致形成的模板不够“泛型”或是过于繁琐，而traits的作用是把这些特殊属性隐藏起来，从而实现让模板更加通用。</p>
</blockquote>
<h2 id="条款48，认识template元编程">条款48，认识template元编程</h2><ul>
<li>模版元编程有两个效力：第一，它让某些事情更容易；第二，可将工作从运行期转移到编译期。</li>
<li>引用：<blockquote>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。</p>
</blockquote>
</li>
</ul>
<h2 id="条款49，了解new_handler的行为">条款49，了解new_handler的行为</h2><p>new_handler 的意思就是说，当使用operator new 无法分配内存时，转交给用户，用户来做一些事情。</p>
<h2 id="条款50，了解new和delete的合理替换时机">条款50，了解new和delete的合理替换时机</h2><p>有时候，我们替换掉编译器提供的new或者delete。重写operator new。三个常见理由：</p>
<ol>
<li>用来检测运用上的错误，超额分配一些内存，再额外的空间放置一些内存；</li>
<li>为了强化效能，编译器提供的new/delete是通用的，通用就意味着冗余和效率低下，为什么？这个很好理解，因为他要支持很多情况下，也必须考虑很多情况。我们重写new/delete，也就是说，对于特定情况，给出特定的实现。</li>
<li>为了收集使用上的统计数据。</li>
</ol>
<h2 id="条款51，编写new和delete时需固守常规">条款51，编写new和delete时需固守常规</h2><p>自定义new/delete的时候，需要遵守一些规则。</p>
<ol>
<li>循环申请，直到成功或者抛出异常</li>
<li>class专属版本处理，分配大小与class大小不一致的错误。</li>
<li>delete的时候，判断是否为null。</li>
</ol>
<h2 id="条款52，写了placement_new也要写placement_delete">条款52，写了placement new也要写placement delete</h2><h2 id="条款53，不要轻忽编译器的警告">条款53，不要轻忽编译器的警告</h2><h2 id="条款54，让自己熟悉包括TR1在内的标准程序库">条款54，让自己熟悉包括TR1在内的标准程序库</h2><p>C++11（原名C++0x）于2011年8月12日公布。<br>TR1是一份文档，由编译器实现，在std::tr1命名空间下<br>C++11纳入了大部分TR1的内容</p>
<h2 id="条款55，让自己熟悉Boost">条款55，让自己熟悉Boost</h2><p>Boost是一个社区，提供很多程序库，作为新的C++标准的试验场。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C]]>
    </summary>
    
      <category term="C++" scheme="http://rudy-zhang.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://rudy-zhang.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图灵到图灵测试再到图灵停机]]></title>
    <link href="http://rudy-zhang.me/2015/05/31/%E4%BB%8E%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95%E5%88%B0%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA/"/>
    <id>http://rudy-zhang.me/2015/05/31/从图灵测试到图灵停机/</id>
    <published>2015-05-31T07:23:33.000Z</published>
    <updated>2015-05-31T08:02:36.000Z</updated>
    <content type="html"><![CDATA[<p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮助盟军破解德军密码系统Enigma的故事。图灵，这个计算机之父，影响着计算机技术发展的方方面面，计算机的最高奖图灵奖也是以他的名字命名的，没办法人家是祖师爷呀。</p>
<h2 id="图灵生平">图灵生平</h2><blockquote>
<p>阿兰·麦席森·图灵（Alan Mathison Turing），生于1912年6月23日，逝于1954年6月7日 ，被誉为“<strong>计算机科学之父</strong>”和“人工智能之父”。图灵和同事破译的情报，在盟军诺曼底登陆等重大军事行动中发挥了重要作用，图灵因此在1946年获得“不列颠帝国勋章”。历史学家认为，他让二战提早了2年结束，至少拯救了2000万人的生命 。<br>计算机逻辑的奠基者，提出了“图灵机”和“图灵测试”等重要概念。美国计算机协会（ACM）1966年设立的以其名命名的“<strong>图灵奖</strong>”是计算机界最负盛名和最崇高的一个奖项，有“计算机界的诺贝尔奖”之称。</p>
<p>1912年6月23日出生于英国帕丁顿，1931年进入剑桥大学国王学院，师从著名数学家哈代，1938年在美国普林斯顿大学取得博士学位，二战爆发后返回剑桥，曾经协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。</p>
<p>因图灵的同性恋倾向，他于1952年被起诉（这种行为在当时的英国仍属刑事犯罪）。 为了继续科研工作，他接受了治疗雌激素注射（ 化学阉割 ）代替牢狱之刑。 图灵于1954年6月7日去世（食用氰化物泡过的苹果中毒）， 勘验确定他的死亡是自杀。 英国女王伊丽莎白二世在2013年追授特赦。</p>
<p>阿兰·麦席森·图灵是一名世界级的长跑运动员。他的马拉松最好成绩是2小时46分3秒，比1948年奥林匹克运动会金牌成绩慢11分钟。1948年的一次跨国赛跑比赛中，他跑赢了同年奥运会银牌得主汤姆·理查兹（Tom Richards）。</p>
</blockquote>
<h2 id="图灵测试">图灵测试</h2><blockquote>
<p>如果一台机器能够与人类展开对话（通过电传设备）而不能被辨别出其机器身份，那么称这台机器具有智能。</p>
</blockquote>
<p>这也是《机械姬》这部电影讨论的核心所在。善良单纯的天才程序员被大Boss天才坑蒙拐骗参加设计的图灵测试，机器人ava通过利用程序员的同情心（程序员多么可怜），诱骗他完成了逃离实验基地的任务。最终是否通过测试不是由程序员判断的，而是由机器人能否骗到程序员决定的。多么精巧的设计！一个高智商的程序员，明知道很有可能被骗，但还是被骗了，这无疑是真正的人工智能。</p>
<p>最后实验失控，大Boss被AI杀死（预示着人类要灭亡么？），AI进入到人群之中。</p>
<p>这是一部好电影，但这篇文章不是一篇影评，就不赘述电影的细节了。</p>
<h2 id="图灵停机问题">图灵停机问题</h2><p>突然想起来本科离散数学提到的一个很有意思的问题，图灵停机问题（The Halting Problem））。描述如下：</p>
<blockquote>
<p>不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。</p>
</blockquote>
<p>精妙的是这个问题的证明过程。通过反证法可以证明这个命题。</p>
<p>假设我们某一天真做出了这么一个极度聪明的万能算法（就叫God_algo吧），你只要给它一段程序（二进制描述），再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束（停机），我们来编写一下我们的这个算法吧：</p>
<pre><code>bool God_algo(<span class="keyword">char</span>* <span class="keyword">program</span>, <span class="keyword">char</span>* <span class="keyword">input</span>)
{
    <span class="keyword">if</span>(&lt;<span class="keyword">program</span>&gt; halts <span class="keyword">on</span> &lt;<span class="keyword">input</span>&gt;)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> false;
}
</code></pre><p>这里我们假设if的判断语句里面是你天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在，我们从这个God_algo出发导出一个新的算法：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span><span class="params">(<span class="keyword">char</span>* program)</span>
</span>{
    <span class="keyword">if</span>( God_algo(program, program) )
    {
           <span class="keyword">while</span>(<span class="number">1</span>);        <span class="comment">// loop forever!</span>
           <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// can never get here!</span>
    }
    <span class="keyword">else</span>
       <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<pre><code>Satan_algo<span class="list">(<span class="keyword">Satan_algo</span>)</span><span class="comment">;</span>
</code></pre><p>我们来分析一下这行简单的调用：</p>
<ol>
<li><p>Satan_algo(Satan_algo)这个调用要么能够运行结束返回（停机），要么不能返回（loop forever）。</p>
</li>
<li><p>如果它能够结束，那么Santa_algo算法里面的那个if判断就会成立（因为God_algo(Santa_algo,Santa_algo)将会返回true），从而程序便进入那个包含一个无穷循环while(1);的if分支，于是这个Satan_algo(Satan_algo)调用便永远不会返回（结束）了。</p>
</li>
<li><p>如果不能结束（停机），则if判断就会失败，从而选择另一个if分支并返回true，即Satan_algo(Satan_algo)又能够返回（停机）。</p>
</li>
</ol>
<p>总之，我们有：</p>
<p>Satan_algo(Satan_algo)能够停机=&gt; 它不能停机</p>
<p>Satan_algo(Satan_algo)不能停机=&gt; 它能够停机</p>
<p>所以它停也不是，不停也不是，左右矛盾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮]]>
    </summary>
    
      <category term="杂七杂八" scheme="http://rudy-zhang.me/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux命令sed和awk]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E5%91%BD%E4%BB%A4sed%E5%92%8Cawk/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux命令sed和awk/</id>
    <published>2015-05-25T23:39:28.000Z</published>
    <updated>2015-05-25T23:57:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p>
<h3 id="常见应用">常见应用</h3><ol>
<li>抽区域</li>
<li>匹配正则表达式</li>
<li>比较域</li>
<li>增加，附加，替换</li>
</ol>
<h3 id="执行过程">执行过程</h3><p>sed一次处理一行或多行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行或多行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向或写入命令存储输出。</p>
<h3 id="调用方式">调用方式</h3><ul>
<li>命令行输入</li>
</ul>
<p>sed [选项] ‘sed命令’ 输入文件</p>
<ul>
<li>使用sed脚本<br>sed [选项] –f sed脚本文件 输入文件</li>
</ul>
<h3 id="常用选项">常用选项</h3><p>-n：不打印，不写编辑行到标准输出，缺省情况下打印所有行[编辑/未编辑]p命令可以打印编辑行</p>
<p>-c：下一命令是编辑命令，使用多项编辑时加入此选项</p>
<p>-f： 调用sed脚本 sed –f sedScriptFile targetFile</p>
<p>-i：将修改附加到源文件上</p>
<h3 id="使用技巧">使用技巧</h3><p>重定向sed结果输出<br>$sed ‘sed-command’ inputfile &gt; outputfile</p>
<p>定位内容的方式</p>
<p><code>x</code> 行x</p>
<p><code>x,y</code> 行x到行y</p>
<p><code>/pattern/</code> 模式</p>
<p><code>/pattern/pattern/</code> 两个模式</p>
<p><code>/pattern/,x</code>     模式+行【在给定行号上查询模式】</p>
<p><code>X,y</code> /pattern/ 通过行号和模式查询匹配行</p>
<p><code>X,y!</code> 不包含指定行号</p>
<h3 id="基本的sed命令">基本的sed命令</h3><p>P 打印匹配行 print</p>
<p>= 打印匹配行行号</p>
<p>a\ 定位行号后附加新文本信息 append</p>
<p>i\ 定位行号后插入   insert</p>
<p>d 删除定位行   delete</p>
<p>c\ 用新文本替换定位文本   change</p>
<p>s 使用替换模式替换相应模式 </p>
<p>r 从另一个文件中读文本  read</p>
<p>w 写文本到一个文件   write</p>
<p>q 第一个模式匹配完成后退出或立即退出</p>
<p>{} 定位执行命令组</p>
<p>n 从另一个文件中读文本下一行，并附加在下一行</p>
<p>g 将模式2黏贴到/pattern n/</p>
<p>y 传送字符</p>
<h3 id="实例：">实例：</h3><ul>
<li>显示文本</li>
</ul>
<p><code>$sed -n &#39;1,4p&#39; file</code></p>
<p>显示1-4行</p>
<p><code>$sed -n &#39;4,/Str/p&#39;</code></p>
<p>显示第4行到匹配到Str的一行，/str/代表匹配到的一行</p>
<ul>
<li>插入修改文本</li>
</ul>
<p><code>$sed &#39;/str/a\ &quot;inserted line&quot;&#39; file</code></p>
<p>在满足条件的行后，插入内容</p>
<p><code>sed &#39;/str/i\ &quot;appended line&quot;&#39; file</code></p>
<p>在满足条件的行前插入内容</p>
<p><code>$sed &#39;3 c\ &quot;changed line&quot;&#39; file</code></p>
<p>满足条件的行，整行替换掉</p>
<ul>
<li>删除文本</li>
</ul>
<p><code>$sed &#39;1,3d&#39; file</code></p>
<p>删除1-3行</p>
<p><code>$sed &#39;/str/d&#39; file</code></p>
<p>删除匹配行</p>
<p><code>$sed -n &#39;/Begin/,/End/p&#39; file | more</code></p>
<p>删除两个匹配行之间的数据</p>
<ul>
<li>替换文本</li>
</ul>
<p>格式：<code>[address[,address]] s/pattern-find/replacement-pattern/[g,p,w,n]</code></p>
<p>n    1到512之间的一个数字，表示对本模式中指定模式第n次出现的情况进行替换。</p>
<p>g    对模式空间所有出现的情况进行全局更改【缺省只替换首次出现的模式 】</p>
<p>p    打印模式空间的内容</p>
<p>w    file</p>
<p><code>$sed &#39;s/str/tostr/&#39; file</code> </p>
<p>替换每一行首次出现的str为tostr</p>
<p><code>$sed &#39;s/str/tostr/g&#39; file</code></p>
<p>替换所有的行内，出现的所有str为tostr</p>
<p><code>$sed &#39;s/str/tostr/w output&#39; file</code></p>
<p>替换后重定向到output</p>
<p>转换字符</p>
<p><code>sed &#39;y/cp/wd/&#39; test.txt</code></p>
<p>c转换成w，p转换成d</p>
<ul>
<li>Shell向sed传值</li>
</ul>
<p><code>echo $input | sed &#39;s/bb/&#39;$str&#39;/&#39;</code></p>
<p><code>echo $input | sed &quot;s/bb/$str/&quot;</code></p>
<h2 id="awk">awk</h2><h3 id="主要功能-1">主要功能</h3><p>awk是一种用于处理文本的工具，主要用于格式化报文，或从一个大文本中抽取数据。</p>
<h3 id="执行过程-1">执行过程</h3><p>awk每次读入一行，执行’ ‘中的内容，按模式匹配来采取动作</p>
<h3 id="格式">格式</h3><p><code>awk &#39;pattern+{action}&#39; file</code></p>
<p>pattern用于筛选查询匹配行，决定了动作何时触发，可以使用条件语句，正则表达式</p>
<p>action用于对筛选后的内容进行处理</p>
<p>BEGIN可以设置计数和打印头（可选）</p>
<p>END打印输出文本总数和结尾状态标识(可选)</p>
<h3 id="常用参数">常用参数</h3><p>-F 指定读取一行数据的分隔符，默认为空格<br>-f 指定处理程序的脚本文件，这个文件必须符合awk语法</p>
<h3 id="调用方式：">调用方式：</h3><p><code>awk –f awk-script-file input-files</code></p>
<h3 id="常用内置参数">常用内置参数</h3><p><code>$0,$1,....$n</code>   <code>$0</code>代表当前行的内容，<code>$i</code>代表当前行被分割后的第i个字段的内容</p>
<p>ARGC 命令行参数个数</p>
<p>ARGV 命令行参数排列</p>
<p>ENVIRON 支持队列中系统环境变量的使用</p>
<p>FILENAME 实际操作的文件名</p>
<p>FNR 浏览文件记录数，&lt;=NR</p>
<p>FS <strong>设置输入域分隔符，等价于命令行-F选项</strong> ，可在BEGIN中进行设置,然后执行的时候均以设置的符号为分隔符</p>
<p>NF <strong>浏览记录 域的个数</strong>，在记录被读取时设置【number of fields】一共有多少个域</p>
<p>NR <strong>已读取记录数</strong>【number of rows】</p>
<p>RS 控制记录分隔符，缺省：新行\n，Row Separator记录分隔符，可以根据具体数据需求，设置读取一条记录的区间</p>
<p>OFS <strong>输出域的分隔符</strong>，缺省空格，输出结果 print $1,$2默认加的是空格，可以在BEGIN中设置，改为其他分隔符</p>
<p>ORS 输出记录的分隔符，缺省：新行\n，整体记录的</p>
<h3 id="实例">实例</h3><ul>
<li>打印</li>
</ul>
<p>打印所有行</p>
<p><code>awk &#39;{print $0}&#39; file</code></p>
<p>打印包含头尾</p>
<p><code>awk &#39;BEGIN{print &quot;Name Age&quot;}{print $1,$2}END{print &quot;END_OF_REPORT&quot;}&#39;</code></p>
<ul>
<li>使用判断语句</li>
</ul>
<p><code>&lt;  &lt;=  &gt;  &gt;=  ==  !=</code>  </p>
<p>~匹配正则   !~不匹配正则</p>
<p><code>|| &amp;&amp; !</code> 或且非</p>
<p><code>awk &#39;{if($2!~/Rudy/) print $0}&#39; content</code></p>
<p><code>awk &#39;{if($1==&quot;001&quot; &amp;&amp; $2~/^Ru/) print $0}&#39; content</code></p>
<ul>
<li>使用内置的变量 </li>
</ul>
<p><code>awk &#39;BEGIN{OFS=&#39;\t&#39;}{print NF,NR,$0}END{print FILENAME}&#39; content &gt; output</code></p>
<p>设置输出的分隔符为’\t’，输出一些内置变量的信息</p>
<ul>
<li>AWK变量中的字符串和数字的转换</li>
</ul>
<p>字符串-&gt;整数</p>
<p><code>$ awk &#39;BEGIN{a=&quot;100&quot;;b=&quot;10test10&quot;;print (a+b+0);}&#39;</code></p>
<p><code>110</code></p>
<p>只需要将变量通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。</p>
<p>整数-&gt;字符串</p>
<p><code>awk &#39;BEGIN{a=100;b=100;c=(a&quot;&quot;b);print c}&#39;</code>      </p>
<p><code>100100</code></p>
<p>只需要将变量与””符号连接起来运算即可。</p>
<ul>
<li>使用内置的字符串函数</li>
</ul>
<p><code>gsub(r,s)</code> 在整个$0中<strong>用s代替r</strong></p>
<p><code>gsub(r,s,t)</code> 在整个t中用s替代r</p>
<p><code>index(s,t)</code> 返回s中字符串t的第一位置</p>
<p><code>length(s)</code> <strong>返回s长度</strong></p>
<p><code>match(s,r)</code> 测试s是否包含匹配r的字符串</p>
<p><code>split(s,a,fs)</code> 在fs上将s分成序列a.fs为分隔符</p>
<p><code>sprint(fmt,exp)</code> 返回经fmt格式化后的exp</p>
<p><code>sub(r,s)</code> 用$0中最左边最长的子串代替s</p>
<p><code>substr(s,p)</code> 返回字符串s中从p开始的后缀部分</p>
<p><code>substr(s,p,n)</code> 返回字符串s中从p开始长度为n的后缀部分</p>
<p>替换字符串</p>
<p><code>awk &#39;BEGIN{FS=&#39;\t&#39;}{gsub(/Rudy/,&quot;RUDY&quot;);{print $0}}&#39; content</code></p>
<ul>
<li>使用printf进行格式化输出</li>
</ul>
<p><code>%c</code> ASCII字符</p>
<p><code>%d</code> 整数</p>
<p><code>%e</code> 浮点数，可科学计数法</p>
<p><code>%f</code> 浮点数，小数形式</p>
<p><code>%g</code> 由awk决定使用哪种浮点数转换e或f</p>
<p><code>%o</code> 八进制</p>
<p><code>%s</code> 字符串</p>
<p><code>%x</code> 十六进制</p>
<p>格式化输出一个字符串</p>
<p><code>awk -F&#39;\t&#39; &#39;{printf(&quot;%s\t%s\n&quot;,$2,$1)}&#39; content</code></p>
<ul>
<li>向awk中传递参数</li>
</ul>
<p><code>awk &#39;{if($3&lt;=AGE){print $0}}&#39; AGE=20 content</code> </p>
<ul>
<li><p>写一个awk脚本</p>
<pre><code><span class="comment">#!bin/awk -f</span>
BEGIN{
        FS=<span class="string">"['\t']"</span>
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="string">"NUMBER"</span>,<span class="string">"NAME"</span>,<span class="string">"AGE"</span>)
}
{
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)
}
END{
        <span class="keyword">print</span> <span class="string">"END OF FILE"</span>
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p]]>
    </summary>
    
      <category term="linux命令" scheme="http://rudy-zhang.me/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="linux" scheme="http://rudy-zhang.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux正则表达式和grep]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cgrep/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux正则表达式和grep/</id>
    <published>2015-05-25T23:27:44.000Z</published>
    <updated>2015-05-25T23:54:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk: 伪装成实用程序的强大编程语言，主要用于文本处理</li>
</ul>
<h3 id="常用符号">常用符号</h3><h4 id="基本元字符">基本元字符</h4><p><code>^</code> 行首定位符，表示以..开始</p>
<p><code>$</code> 行尾定位符，表示以..结束</p>
<p><code>.</code>  匹配单个字符</p>
<p><code>*</code> 匹配0个或任意多个字符</p>
<p><code>[]</code> 匹配[]中出现字符范围内的一个字符</p>
<p><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h4 id="扩展元字符">扩展元字符</h4><p><code>?</code> 匹配0个或者1个</p>
<p><code>+</code> 匹配1个或者多个</p>
<p><code>|</code> 或者</p>
<p><code>()</code>分组符号</p>
<h4 id="特殊匹配字符">特殊匹配字符</h4><p><code>[:alnum:]</code> 字母与数字字符</p>
<p><code>[:alpha:]</code> 字母</p>
<p><code>[:ascii:]</code> ASCII字符</p>
<p><code>[:blank:]</code> <strong>空格或制表符</strong></p>
<p><code>[:cntrl:]</code> ASCII控制字符</p>
<p><code>[:digit:]</code> 数字</p>
<p><code>[:graph:]</code> 非控制、空格字符</p>
<p><code>[:lower:]</code> 小写字母</p>
<p><code>[:print:]</code> 可打印字符</p>
<p><code>[:punct:]</code> 标点符号字符</p>
<p><code>[:space:]</code> <strong>空白字符，包括垂直制表符</strong></p>
<p><code>[:upper:]</code> 大写字母</p>
<p><code>[:xdigit:]</code> 十六进制数字</p>
<h3 id="实例">实例</h3><ul>
<li>^ $<br><code>ls -l | grep ^d</code></li>
</ul>
<p>匹配以d开头的所有内容</p>
<ul>
<li><code>ls -l | grep d$</code></li>
</ul>
<p>匹配以d结束的所有内容</p>
<ul>
<li><code>^$</code> </li>
</ul>
<p>匹配空行</p>
<ul>
<li><code>^.$</code></li>
</ul>
<p>只包含一个字符的</p>
<ul>
<li><code>* ？ +</code></li>
</ul>
<p><code>compu*ter</code> 匹配u，重复0次或多次</p>
<p><code>compu?ter</code> 匹配0个或者1个u</p>
<p><code>compu+ter</code> 匹配1个或多个u</p>
<p><strong>需要注意的是+和？是扩展字符，需要看具体使用正则表达式的环境<br>如果使用grep需要使用-E指定为扩展模式才能正常使用+和？</strong></p>
<ul>
<li><code>\</code>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
</ul>
<p><code>\.pass</code>  匹配<code>*.pass</code></p>
<ul>
<li><code>[]</code></li>
</ul>
<p><code>[1234]</code> 匹配1,2,3,4中的一个</p>
<p><code>[1-9]</code> 数字1-9中的一个</p>
<p><code>[A-Za-z]</code> 所有字母</p>
<p><code>[^0-9]</code> 一个非数字的字符</p>
<ul>
<li><code>\{\}</code></li>
</ul>
<p><code>A\{2\}B</code>   匹配AAB</p>
<p><code>A\{4,\}B</code>   匹配A出现至少4次B</p>
<p><code>A\{2,4\}B</code>  匹配A出现在2至4次之间</p>
<h2 id="grep">grep</h2><p>功能：grep是文本搜索工具，使用正则表达式搜索文本并打印匹配行</p>
<p>格式：<code>grep [options] PATTERN [Files]</code></p>
<p>注：</p>
<p>输入字符串<strong>作为参数，最好双引号括起</strong>  “mystr”</p>
<p>在<strong>调用变量时，也使用双引号括起</strong>  “$MYSTR”</p>
<p>使用<strong>正则[匹配模式]是，应使用单引号括起</strong>  ‘49[32]’</p>
<p>常用选项：</p>
<p><code>-c</code> 只输出匹配的行数,而不输出匹配的行</p>
<p><code>-i</code> 不区分大小写</p>
<p><code>-n</code> 显示匹配行及行号</p>
<p><code>-q</code>  安静模式，不输出任何东西，如果找到了返回0</p>
<p><code>-E</code> 启用扩展表达式，可使用扩展字符，如：+ ? | () {} , 或者直接使用egrep</p>
<p><code>-v</code> 显示不包含匹配文本的所有行</p>
<p>实例：</p>
<ol>
<li><p>在多个文件中查找<br><code>grep “sort” filea fileb</code>  在filea,fileb中查找</p>
</li>
<li><p>计算匹配行数<br><code>grep -c &quot;sort&quot; file</code></p>
</li>
<li><p>使用正则表达式查找<br><code>grep &#39;48[34]&#39; file</code></p>
</li>
<li><p>使用扩展元字符<br><code>grep -E &#39;aaa|bbb&#39; file</code></p>
</li>
<li><p>匹配空行<br><code>grep &#39;^$&#39; file</code></p>
</li>
<li><p>特殊匹配字符，grep 允许使用国际字符串模式匹配或匹配模式的类名<br><code>grep ‘5[[:upper:]] [[:upper:]]’</code> data  5开头，两个大写</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk:]]>
    </summary>
    
      <category term="linux命令" scheme="http://rudy-zhang.me/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="正则表达式" scheme="http://rudy-zhang.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="linux" scheme="http://rudy-zhang.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming学习文档]]></title>
    <link href="http://rudy-zhang.me/2015/05/24/HadoopStreaming/"/>
    <id>http://rudy-zhang.me/2015/05/24/HadoopStreaming/</id>
    <published>2015-05-24T01:30:00.000Z</published>
    <updated>2015-05-24T08:54:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架允许任何程序语言实现的程序（只要该程序支持标准输入输出即可），在Hadoop MapReduce中使用，方便已有程序向Hadoop平台移植。</p>
<h2 id="Streaming原理">Streaming原理</h2><p>使用Java实现了一个包装<strong>用户程序</strong>（mapper，reducer方法）的MapReduce程序，该程序调用MapReduce的Java接口，创建一个<strong>新的进程</strong>包装用户程序，将数据通过<strong>管道</strong>传递给包装的用户程序。</p>
<p><img src="http://i.imgur.com/dlebclb.jpg" alt=""></p>
<h2 id="考虑的问题">考虑的问题</h2><p>在实际的开发过程中，开发人员需要考虑下面几个方面的问题，其中1,2是必须实现的：</p>
<ol>
<li>Mapper程序：对输入key/value数据进行处理；</li>
<li>Reducer程序：对mapper的输出进行归并处理；</li>
<li>Combiner：在本地对一个计算节点上的mapper输出进行归并；</li>
<li>Partitioner：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li>InputFormat/OutputFormat：对输入数据进行切分，保存输出数据。</li>
</ol>
<h2 id="执行">执行</h2><pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “cat” \
    -reducer “cat” \
    -jobconf mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">1</span>\
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”dist-sort”
</code></pre><p>这是一个实现了分布式排序的程序。可以通过shell脚本，shell命令，或者其它语言的<strong>可执行程序</strong>来进行mapper和reducer程序的运行</p>
<h2 id="常用参数的使用">常用参数的使用</h2><p>例1：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">2</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"Python/bin/python $app/mapper.py"</span> \
    -reducer <span class="string">"Python/bin/python $app/reducer.py"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archive</span>
</code></pre><p>-D表示配置参数，剩余项是和输入输出相关的文件和可执行程序</p>
<p><code>-D mapred.job.name=&quot;jobname&quot; \</code>,作业名</p>
<p><code>-D mapred.job.priority=VERY_HIGH \</code> 作业优先级</p>
<p><code>-D mapred.job.map.capacity=500 \</code>,最多同时运行map任务数</p>
<p><code>-D mapred.job.reduce.capacity=300 \</code>最多同时运行reduce任务数</p>
<p><code>-D mapred.map.tasks=500 \</code>,map任务个数</p>
<p><code>-D mapred.reduce.tasks=300 \</code>,reduce任务个数</p>
<p>capacity是同时运行任务的个数，tasks是运行任务的总的个数，一般task更大，capacity是同时运行任务的上限</p>
<p><code>-D stream.num.map.output.key.fields=2 \</code>,表示在第2个分隔符（默认为\t）之前作为key，之后作为value，也可以使用参数<code>-D stream.map.output.field.separator=. \</code>指定分隔符为’.’或者其它字符。</p>
<p><code>-mapper &quot;Python/bin/python $app/mapper.py&quot; \</code>指定map任务，需要可执行，读入标准输入流，输出标准输出流</p>
<p><code>-reducer &quot;Python/bin/python $app/reducer.py&quot; \</code>指定reducer任务</p>
<p><code>-input $input \</code>指定输入文件</p>
<p><code>-output $output \</code>指定输出文件</p>
<p><code>-cacheArchive $archive</code>分发压缩包。<code>$archive</code>格式为<code>hdfs://host:port/path/to/archivefile#linkname</code>，表示hdfs上这个压缩包的路径为<code>hdfs://host:port/path/to/archivefile</code>,可以使用<code>linkname/children/path</code>访问这个压缩包的内容</p>
<p>例2：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">3</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.partitioner</span><span class="class">.options</span>=<span class="string">"-k1,1"</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.comparator</span><span class="class">.options</span>=<span class="string">"-k1,1 -k3,3nr"</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"cat"</span> \
    -reducer <span class="string">"cat"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archives</span>
</code></pre><p><code>-D mapred.text.key.partitioner.options=&quot;-k1,1&quot; \</code>表示对key进行分割，分割符默认为\t，取分割后的1,1部分作为主key，剩下的作为辅key</p>
<p><code>-D mapred.text.key.comparator.options=&quot;-k1,1 -k3,3nr&quot; \</code>指定排序依据，主key按第一部分排字母序，辅key按第三部分数字序倒序排</p>
<p>例3：</p>
<pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -D stream<span class="class">.map</span><span class="class">.output</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">4</span> \
    -D map<span class="class">.output</span><span class="class">.key</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D num<span class="class">.key</span><span class="class">.fields</span><span class="class">.for</span><span class="class">.partition</span>=<span class="number">2</span> \ 
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “mymapper.sh” -reducer “ myreducer.sh” \
    -partitioner org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.lib</span><span class="class">.KeyFieldBasedPartitioner</span> \
    -file /home/work/mymapper<span class="class">.sh</span> \
    -file /home/work/myreducer<span class="class">.sh</span> \
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”jobname”
</code></pre><p><code>-D stream.map.output.field.separator=. \</code><br><code>-D stream.num.map.output.key.fields=4 \</code><br>表示输出分隔符为’.’，并且第4个.之后为value，之前为key</p>
<p><code>-D map.output.key.field.separator=. \</code><br><code>-D num.key.fields.for.partition=2 \</code><br>表示key内的分隔符为’.’，第2个’.’之前作为主key，之后作为辅key</p>
<p><code>-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner \</code>指定要使用KeyFieldBasedPartitioner，也就是key域内的partioner。这样的话会把主key的内容作为partition的依据，相同的主key分配到同一个reducer中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop基本原理]]></title>
    <link href="http://rudy-zhang.me/2015/05/23/Hadoop%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://rudy-zhang.me/2015/05/23/Hadoop基本原理/</id>
    <published>2015-05-23T02:38:00.000Z</published>
    <updated>2015-05-24T14:11:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据处理速度快（Velocity） 数据真实性高（Veracity） 合起来被称为4V。</p>
<p>处理大数据是为了挖掘数据中的隐含价值</p>
<h4 id="如何处理大数据？">如何处理大数据？</h4><p>集中式计算VS分布式计算</p>
<p>集中式计算：通过不断增加处理器的个数来增强耽搁计算机的计算能力，从而提高处理的速度。需要的内存很大，计算的速度很快。</p>
<p>分布式计算：一组通过网络连接的计算机，形成一个分散的系统。将需要处理的大量数据分散成多个部分，交由系统中的耽搁计算机分别处理，最后将这些计算结果合并得到最终结果。（MapReduce的核心思想）</p>
<h3 id="Hadoop是怎么产生的">Hadoop是怎么产生的</h3><h4 id="技术基础">技术基础</h4><p>google三驾马车：GFS、MapReduce和BigTable。Hadoop是在google三驾马车基础上的开源实现。</p>
<ol>
<li>GFS（Google File System）分布式文件系统，对应Hadoop当中的HDFS。</li>
<li>MapReduce分布式计算框架，也是Hadoop处理大数据的核心思想。</li>
<li>BigTable是基于GFS的数据存储系统，对应Hadoop的HBase。</li>
</ol>
<h4 id="三大分布式计算系统">三大分布式计算系统</h4><p>Hadoop，Spark，Storm是主流的三大分布式计算系统</p>
<p>Spark VS Hadoop</p>
<p>Hadoop使用硬盘来存储数据，而Spark是将数据存在内存中的，因此Spark何以提供超过Hadoop 100倍的计算速度。内存断电后会丢失，所以Spark不<br>适用于需要长期保存的数据。</p>
<p>Storm VS Hadoop</p>
<p>Storm在Hadoop基础上提供了实时运算的特性，可以实时处理大数据流。不同于Hadoop和Spark，Storm不尽兴数据的手机和存储工作，直接通过网络接受并实时处理数据，然后直接通过网络实时传回结果。</p>
<p>所以三者适用于的应用场景分别为：</p>
<ol>
<li>Hadoop常用于离线的复杂的大数据处理</li>
<li>Spark常用于离线的快速的大数据处理</li>
<li>Storm常用于在线实时的大数据处理</li>
</ol>
<h3 id="Hadoop定义">Hadoop定义</h3><h4 id="Hadoop是什么">Hadoop是什么</h4><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架</p>
<h4 id="Hadoop特点">Hadoop特点</h4><ol>
<li>可靠。Hadoop假设计算元素和存储会失败，所以会维护多个工作数据的副本，对失败的节点会重新处理</li>
<li>高效。通过并行方式工作，加快处理速度。</li>
<li>可伸缩。可以处理PB级的数据。</li>
<li>高扩展。可以方便地扩展到数以千计的节点。</li>
<li>低成本。Hadoop是开源的，Hadoop节点可以是很便宜的机器。</li>
</ol>
<h4 id="应用场景">应用场景</h4><p>Hadoop适用于：海量数据，离线数据，复杂数据</p>
<p>场景1：数据分析，如海量日志分析，商品推荐，用户行为分析</p>
<p>场景2：离线计算，（异构计算+分布式计算）天文计算</p>
<p>场景3：海量数据存储，如Facebook的存储集群。</p>
<p><a href="http://cloud.zol.com.cn/441/4415033_all.html" target="_blank" rel="external">更多应用场景</a></p>
<h3 id="Hadoop原理">Hadoop原理</h3><h4 id="HDFS">HDFS</h4><p>HDFS（Hadoop File System），是Hadoop的分布式文件存储系统</p>
<ol>
<li>将大文件分解为多个Block，每个Block保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。</li>
<li>默认每个Block保存3个副本，64M为1个Block。</li>
<li>将Block按照key-value映射到内存当中。</li>
</ol>
<p>HDFS架构图如下：</p>
<p><img src="http://i.imgur.com/ZliSEXb.png" alt=""></p>
<h5 id="NameNode">NameNode</h5><p>HDFS使用主从结构，NameNode是Master节点，是领导。所有的客户端的读写请求，都需要首先请求NameNode。</p>
<p>NameNode存储</p>
<ol>
<li>fsimage：元数据镜像文件（文件系统的目录树，文件的<strong>元数据</strong>信息）。元数据信息包括文件的信息，文件对应的block信息（版本信息，类型信息，和checksum），以及每一个block所在的DataNode的信息。</li>
<li>edits：元数据的操作日志</li>
</ol>
<h5 id="DataNode">DataNode</h5><p>DataNode是Slave，负责真正存储所有的block内容，以及数据块的读写操作</p>
<p>NameNode，DataNode，rack只是一些逻辑上的概念。NameNode和DataNode可能是一台机器也可能是，相邻的一台机器，很多DataNode可能处于同一台机器。rack是逻辑上比DataNode更大的概念，可能是一台机器，一台机柜，也可能是一个机房。通过使文件的备份更广泛地分布到不同的rack，DataNode上可以保证数据的可靠性。</p>
<h5 id="HDFS写入数据">HDFS写入数据</h5><ol>
<li>Client拆分文件为64M一块。</li>
<li>Client向NameNode发送写数据请求。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode。</li>
<li>Client向DataNode发送block1,2,3….；发送过程是以流式写入。流式写入，数据流向为DataNode1-&gt;DataNode2-&gt;DataNode3(1,2,3为通过规则选出来的可用的DataNode)</li>
<li>发送完毕后告知NameNode</li>
<li>NameNode告知Client发送完成</li>
</ol>
<p>在写数据的时候：</p>
<ul>
<li>写1T文件，我们需要3T的存储，3T的网络流量贷款。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ul>
<h5 id="HDFS读取数据">HDFS读取数据</h5><ol>
<li>Client向NameNode发送读请求</li>
<li>NameNode查看MetaData信息，返回文件的block位置</li>
<li>根据一定规则（优先选择附近的数据），按顺序读取block</li>
</ol>
<p><a href="http://www.weixuehao.com/archives/596" target="_blank" rel="external">更多内容</a></p>
<h4 id="MapReduce">MapReduce</h4><p>Map是把一组数据一对一的<strong>映射</strong>为另外的一组数据，其映射的规则由一个<strong>map函数</strong>来指定。Reduce是对一组数据进行<strong>归约</strong>，这个归约的规则由一个<strong>reduce函数</strong>指定。</p>
<p>整个的MapReduce执行过程可以表示为：</p>
<p><code>(input)&lt;k1, v1&gt; =&gt; map =&gt; &lt;k2, v2&gt; =&gt; combine =&gt; &lt;k2, v2’&gt; =&gt; reduce =&gt; &lt;k3, v3&gt;(output)</code></p>
<p>也可以表示为流程图：</p>
<p><img src="http://i.imgur.com/yRsLgoK.png" alt=""></p>
<ol>
<li><strong>分割</strong>：把输入数据分割成不相关的若干键/值对（key1/value1）集合，作为input</li>
<li><strong>映射</strong>：这些键/值对会由多个map任务来<strong>并行地处理</strong>。输出一些中间键/值对key2/value2集合</li>
<li><strong>排序</strong>：MapReduce会对map的输出（key2/value2）按照key2进行排序（便于归并）</li>
<li><strong>conbine</strong>：属于同一个key2的所有value2组合在一起作为reduce任务的输入（相当于提前reduce，减小key2的数量，减小reduce的负担）</li>
<li><strong>Partition</strong>：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li><strong>规约</strong>：由reduce任务计算出最终结果并输出key3/value3。</li>
</ol>
<h4 id="程序员需要做的">程序员需要做的</h4><ul>
<li>单机程序需要处理数据读取和写入、数据处理</li>
<li>Hadoop程序需要实现map和reduce函数</li>
<li>map和reduce之间的数据传输、排序，容错处理等由Hadoop MapReduce和HDFS自动完成。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（二）]]></title>
    <link href="http://rudy-zhang.me/2015/04/22/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B62/"/>
    <id>http://rudy-zhang.me/2015/04/22/一步一步写一个PHP框架2/</id>
    <published>2015-04-22T07:31:44.000Z</published>
    <updated>2015-05-24T08:58:56.000Z</updated>
    <content type="html"><![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%B8%80/">这位大哥</a>,的内容和Codeigniter框架的源码。</p>
<h2 id="程序框架的搭建">程序框架的搭建</h2><p>前提：已经搭建好了一个apache+PHP的开发环境，我使用的是Apache+mod_php5的方式。</p>
<p>在根目录<code>simplemvc</code>下新建以下文件夹</p>
<ul>
<li><code>config</code> 用来存放配置文件</li>
<li><code>controller</code>用来存放控制器</li>
<li><code>lib</code>用来存放引入的库文件</li>
<li><code>model</code>用来存放模型</li>
<li><code>system</code>用来存放系统文件<ul>
<li><code>core</code>核心文件，包括核心controller控制器等，所有的controller都要继承于他</li>
<li><code>lib</code>存放核心的库文件，包括route等</li>
<li><code>app.php</code>应用程序驱动类</li>
</ul>
</li>
<li><code>view</code>用来存放视图</li>
<li><code>index.php</code>项目的入口文件，程序是从这里开始执行的。</li>
</ul>
<h2 id="定义系统路径">定义系统路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#39044;&#23450;&#20041;&#10;define(&#39;SYSTEM_PATH&#39;, dirname(__FILE__).&#39;/system&#39;);&#10;define(&#39;ROOT_PATH&#39;,  substr(SYSTEM_PATH, 0,-7));&#10;define(&#39;SYS_LIB_PATH&#39;, SYSTEM_PATH.&#39;/lib&#39;);&#10;define(&#39;APP_LIB_PATH&#39;, ROOT_PATH.&#39;/lib&#39;);&#10;define(&#39;SYS_CORE_PATH&#39;, SYSTEM_PATH.&#39;/core&#39;);&#10;define(&#39;CONTROLLER_PATH&#39;, ROOT_PATH.&#39;/controller&#39;);&#10;define(&#39;MODEL_PATH&#39;, ROOT_PATH.&#39;/model&#39;);&#10;define(&#39;VIEW_PATH&#39;, ROOT_PATH.&#39;/view&#39;);</span><br></pre></td></tr></table></figure>
<p>预定义一些常量，在之后的程序中我们会使用这些路径。</p>
<h2 id="加载配置文件，和应用程序驱动类">加载配置文件，和应用程序驱动类</h2><h3 id="配置文件">配置文件</h3><p>在config文件夹下的<code>config.php</code><br>··<br>$CONFIG[‘system’][‘db’]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（一）]]></title>
    <link href="http://rudy-zhang.me/2015/04/20/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B61/"/>
    <id>http://rudy-zhang.me/2015/04/20/一步一步写一个PHP框架1/</id>
    <published>2015-04-20T07:31:44.000Z</published>
    <updated>2015-05-24T08:59:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
<p>为了更好地理解PHP里面框架的设计，目标是自己写一个简单的PHP MVC框架，一方面可以更深入地学习PHP，一方面也能够更深入地理解框架设计里面的思想。</p>
<h2 id="Apache的工作流程">Apache的工作流程</h2><p>Apache是一个Web服务器，也可以叫做http服务器，因为Apache只能处理http请求。常见的web服务器还有Nginx</p>
<p>Apache的工作流程如下：</p>
<ol>
<li>浏览器向服务器发出HTTP请求(Request)。</li>
<li>服务器收到浏览器的请求数据，经过分析处理，向浏览器输出响应数据（Response）。</li>
<li>浏览器收到服务器的响应数据，经过分析处理，将最终结果显示在浏览器中。</li>
</ol>
<p>Apache和Nginx都属于Web服务器，两者都实现了HTTP 1.1协议。</p>
<p>所以如果有人问FTP协议可以在Apache上工作吗？答案是用Apache FTP Server可以，Apache web服务器不可以。</p>
<p>Apache是用C语言写的，服务器当然要追求高效率。</p>
<h2 id="PHP原理">PHP原理</h2><p>PHP的核心解释器是用C语言写的，相当于我们写了PHP代码，会有一个C语言写好的解释工具一边解释，一边执行。实际上在写PHP的时候就是在使用一个C语言写好的工具，我们的PHP代码就是指挥这个工具的命令。</p>
<p>PHP包括四层体系：</p>
<ol>
<li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分。负责翻译PHP代码，是一切的核心。</li>
<li>Extensions：围绕Zend引擎，通过组件方式提供基础服务。常见内置函数如array是由extension实现的。</li>
<li>Sapi通过一系列的<strong>钩子函数</strong>，使得PHP可以和外围交互数据。如Apache</li>
<li>上层应用：平时写的PHP程序</li>
</ol>
<blockquote>
<p>如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路， 车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。</p>
</blockquote>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p><strong>hashtable</strong>是PHP的核心数据结构，数组就是典型的应用。Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表（解决冲突），提供了正向、反向遍历数组的功能。</p>
<p>更详细的内容参考<a href="!http://www.cnblogs.com/zcy_soft/archive/2013/03/14/2959396.html">这里</a></p>
<h2 id="PHP在Apache上运行">PHP在Apache上运行</h2><h3 id="以模块加载的方式运行">以模块加载的方式运行</h3><p>这种方式使用了Apache的Hook机制。所谓Hook机制，就是在自己的程序运行的时候允许别的模块插上一腿。当我们配置Apache服务器的<code>http.config</code>文件时，写入<code>mod_php5.so/php5apache2.dll</code>就是将自定义的函数注入到Apache的请求处理循环当中。在模块化的运行方式中，PHP与Web服务器一起启动并且运行，通过Apache自身的进程线程管理来处理并发的请求。</p>
<h3 id="以CGI，FastCGI方式运行">以CGI，FastCGI方式运行</h3><p>CGI英文叫做公共网关接口，CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。Apache在Http请求的时候会将请求提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。</p>
<p>CGI VS FastCGI</p>
<p>FastCGI是CGI的加强版本，CGI是单进程，多线程的运行方式，程序执行完成之后就会销毁。FastCGI是常驻(long-live)型的CGI.有自身的进程管理器，不必每一次都fork一个进程（CGI解释器）去执行。常见的PHP-FPM是一个PHP FastCGI管理器。</p>
<p>关于更多的对比可以看<a href="http://fifiole.blog.163.com/blog/static/169459225201222962651804/" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>目前在HTTPServer这块基本可以看到有三种stack比较流行：</p>
<p>（1）Apache+mod_php5</p>
<p>（2）lighttp+spawn-fcgi</p>
<p>（3）nginx+PHP-FPM</p>
<p>三者后两者性能可能稍优，但是Apache由于有丰富的模块和功能，目前来说仍旧是老大。有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何完成一个在线考试的功能]]></title>
    <link href="http://rudy-zhang.me/2015/04/07/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://rudy-zhang.me/2015/04/07/如何完成一个在线考试的功能/</id>
    <published>2015-04-07T00:58:06.000Z</published>
    <updated>2015-05-24T02:27:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2><h3 id="考卷生成">考卷生成</h3><p>卷子总是由试题组成的，试题包括内容，选项之类的<strong>文本</strong>，以及相关的<strong>图片</strong>。每个试题在数据库中当然只能存一份，否则就浪费了存储空间。很多的OJ题目是随机生成的，一句特定的内容随机生成考题，并且答题结果也是每人一份的，这时候很容易就想到需要中间表来存储这个内容了。</p>
<h3 id="保存现场">保存现场</h3><p>如果使用一个大form，在用户提交考试结果的时候把所有数据提交到server，那中间如果用户不小心退出了，所有的答题内容就<strong>丢失</strong>了。所以需要在用户答题的过程中不断<strong>异步存储</strong>用户答题的结果，使得用户在任何一个时候退出，我们都能够统计出他已经答过的题并且给出分数（或者结果）的。</p>
<h3 id="断线处理">断线处理</h3><p>当用户断线的时候，或者不小心退出了浏览器，系统需要允许用户重新登录，<strong>继续考试</strong>。</p>
<h3 id="倒计时">倒计时</h3><p>倒计时运行在client上，你永远也无法控制client端的人会对代码做什么。在js中添加断点可以停止倒计时空间的运行，所以关于时间必须在server端进行校验，才能规避在时间上作弊的行为。</p>
<h3 id="结算分数">结算分数</h3><p>你永远也无法控制client端的人会对代码做什么，同时开多个窗口可以多次提交结果，甚至可以操纵client端的数据以各种方式提交数据。在server端要考虑到这种行为并且做出相应的对策，对策就是分数永远只结算一次。</p>
<h2 id="实现">实现</h2><h3 id="数据库">数据库</h3><p>根据我做的项目的系统需求，有如下几个关键概念：</p>
<ul>
<li>模块（module）<br>课程分为若干个模块（module），每个模块对应一次考试。每次有限定的时间。</li>
<li>考点（test_point）<br>每个模块包括若干个考点，每次考试从考点中随机抽取题目。</li>
<li>题目(question)<br>题目都是选择题，最多四个，单选题，题干和每个选项都可能对应图片。基于题目题型是固定的，我把这些内容都放到了一个表里，如果考题类型丰富需要更灵活的设计。</li>
<li>考卷（report）<br>每次考试的考卷，上面会有分数。考卷和题目有着多对多的关系，需要一个中间表来存储。</li>
</ul>
<p>出去其他需求，考试部分的数据表简单设计如下：<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqw7h465uvj20pz0ibgmo.jpg" alt="enter image description here"></p>
<h3 id="考卷生成-1">考卷生成</h3><p>每个考试（模块）都对应三种状态：</p>
<ol>
<li>没有考过试的模块 ——— 对应 ——— 生成考题，去考试</li>
<li>已经开始考试还没结束的模块 ——— 对应 ——— 使用已经生成的考题，继续考试</li>
<li>已经结束的模块 ——— 对应 ——— 查看考试成绩</li>
</ol>
<p>当系统没有这个模块的report信息的时候，根据考点随机抽取题目，生成考题和report，<br>report状态变成<strong>进行中</strong>，分数还没有结算。</p>
<p>关键函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#32452;&#21367;&#65292;&#23558;&#32452;&#21367;&#30340;&#20869;&#23481;&#25918;&#20837;report&#34920;&#65292;question_in_report&#34920;&#65292;&#32452;&#21367;&#23545;&#21516;&#19968;&#20010;&#32771;&#35797;&#19981;&#20250;&#32452;&#20004;&#27425;&#10;     * @param  [type] $student_id     [description]&#10;     * @param  [type] $module_id      [description]&#10;     * @param  [type] $logic_class_id [description]&#10;     * @return [type]                 [description]&#10;     */&#10;    function get_questions($student_id,$module_id,$logic_class_id)&#10;    &#123;&#10;        /*&#38656;&#35201;&#25552;&#21069;&#20570;&#30340;&#26816;&#26597;:&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#24050;&#32463;&#22312;&#36825;&#20010;&#36923;&#36753;&#29677;&#19979;&#32771;&#36807;&#36825;&#20010;&#27169;&#22359;&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#26159;&#29992;&#25143;&#33258;&#24049;&#10;        &#36825;&#20010;&#23398;&#29983;&#26159;&#21542;&#23646;&#20110;&#36825;&#20010;&#36923;&#36753;&#29677;&#10;        &#36825;&#20010;&#36923;&#36753;&#29677;&#20013;&#26159;&#21542;&#26377;&#36825;&#38376;&#35838;*/&#10;        &#10;        //&#36941;&#21382;&#25152;&#26377;&#32771;&#28857;&#65292;&#20174;&#27599;&#20010;&#32771;&#28857;&#20013;&#38543;&#26426;&#25277;&#20986;&#19968;&#36947;&#39064;&#23384;&#20837;$test_questions&#10;&#10;        //&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;&#10;        $datetime=date(&#34;Y-m-d H:i:s&#34;);&#10;        &#10;        //&#23558;&#32467;&#26524;&#23384;&#20837;report&#34920;&#10;        $this-&#62;report_model-&#62;add($report_item);&#10;        &#10;        //&#23558;&#32452;&#39064;&#20449;&#24687;&#20889;&#20837;question_in_report &#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="保存现场-1">保存现场</h3><p>使用一个简单的jquery ajax，异步提交用户每次点击的选项，都在后台存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function save_choose(question_id,choose)&#10;&#123;&#10;    myUrl=&#34;&#60;?php echo site_url(&#39;student_test/ajax_save_user_choose&#39;)?&#62;/&#34;+&#60;?php echo $report_id ?&#62;+&#34;/&#34;+question_id+&#34;/&#34;+choose;&#10;    $.ajax(&#123;&#10;        type:&#34;post&#34;,&#10;        url:myUrl,&#10;        success:function(resp)&#123;&#125;&#10;    &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>后台接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#24322;&#27493;ajax&#23384;&#20648;&#29992;&#25143;&#30340;&#36873;&#25321;&#10; * @param  [type] $report_id   [description]&#10; * @param  [type] $question_id [description]&#10; * @return [type]              [description]&#10; */&#10;function ajax_save_user_choose($report_id,$question_id,$choose)&#10;&#123;&#10;    //&#20808;&#21028;&#26029;&#26102;&#38388;&#26159;&#21542;&#27491;&#30830;     &#10;    $now=date(&#34;Y-m-d H:i:s&#34;);&#10;    $this-&#62;load-&#62;helper(&#39;compare_time&#39;);&#10;    $time_past=compare_time_of_minute($report[&#39;datetime&#39;],$now);&#10;    &#10;    if($time_past&#60;=($module[&#39;time_limit&#39;]))&#123;&#10;        //&#26356;&#26032;&#20449;&#24687;&#10;        );  &#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="断线处理-1">断线处理</h3><p>当用户掉线重新进入，需要通过比对<strong>report状态</strong>+<strong>时间</strong>，确定用户是否可以继续考试。</p>
<ul>
<li>如果report状态为结束，则不能继续考试</li>
<li>如果report状态为进行中，时间超过截止时间，不能继续考试</li>
<li>如果report状态为进行中，时间还有，继续考试</li>
</ul>
<p>继续考试通过reportid得到已经<strong>组好的试题信息</strong>，和<strong>用户的答题情况</strong>，返回数据<br>关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#26597;&#25214;&#25968;&#25454;&#24211;&#20013;&#30340;&#24050;&#32463;&#32452;&#22909;&#21367;&#30340;&#20449;&#24687;&#10;     * @param  [type] $report_id [description]&#10;     * @return [type]            [description]&#10;     */&#10;    function get_exist_questions($report_id)&#10;    &#123;       &#10;        //&#23384;&#20648;&#25152;&#26377;&#32771;&#21367;&#39064;&#30446;&#30340;&#25968;&#32452;&#10;        $test_questions = array();&#10;        &#10;        //&#20174;question_in_report&#20013;&#26597;&#25214;&#25152;&#26377;&#28385;&#36275;&#26465;&#20214;&#30340;&#38382;&#39064;&#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="倒计时-1">倒计时</h3><p>客户端的倒计时使用js，最简单的可以使用<code>window.setInterval()</code>函数，每隔1s时间修改html的内容。结果在stackoverflow上询问倒计时解决方法的时候被“鄙视”了一下：</p>
<blockquote>
<p>You’re design is bad, you should base your time measurement using the date object. Each time a loop will get triggered, check the current date with new Date() and keep track of the last date.</p>
<p>Keep in mind that even if you set an interval of 1000ms, it doesn’t mean that on the function will get called every seconds. It only means that it will never get called before 1000ms. As Javascript runs in one thread, any blocking process may delay calling methods that will remain in the event queue (setInterval in this case).</p>
</blockquote>
<p>大体意思是<code>setInterval</code>能保证运行的时间一定比传入的参数多，但是js是单线程的，别的操作有可能会阻塞这个方法，所以最好使用<code>Date()</code>方法来比对客户端的时间。</p>
<p>所以我的实现是使用了<a href="https://github.com/tomgrohl/jCountdown" target="_blank" rel="external">jcountdown插件</a>，通过计算出截止日期，进行倒计时。方法很简单，只需要在<code>id</code>为<code>time</code>的div上使用插件里的函数就可以了。通过template可以指定显示时间的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#34;#time&#34;).countdown(&#123;&#10;            minSingularText: &#39;&#20998;&#39;,&#10;            secSingularText: &#39;&#31186;&#39;,&#10;            &#34;date&#34; : d,&#10;            template: &#34;&#60;div class=&#39;time-item&#39;&#62;&#60;strong&#62;%i %s&#60;/strong&#62;&#60;/div&#62;&#34;,&#10;            onComplete : function()&#123;$(&#34;#test&#34;).submit();&#125;&#10;        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>不管倒计时做的多么炫酷，client is client，我永远无法控制它最终怎么运行，有没有被篡改。所以，每一次用户答题提交ajax请求，以及最终提交考卷的时候，都要<strong>比对时间</strong>，只保存合理的请求。这样就保证了整个考试系统在时间上的正确性。</p>
<h3 id="结算分数-1">结算分数</h3><p>结算分数有以下几个时间点</p>
<ol>
<li>用户答题完成，提交所有数据</li>
<li>用户在时间结束时由浏览器自动提交数据</li>
<li>用户没有通过浏览器提交数据（半路关闭浏览器），下次登录时系统自动算分</li>
</ol>
<p>1,2类似，正常提交表单就可以，需要注意的是：</p>
<ol>
<li>在所有这些过程中，<strong>网络可能有延时</strong>，所以在比对用户提交的时间的时候，可以宽限一定时间。</li>
<li>提交后修改report的状态，这个操作只有一次，拒绝之后的所有修改（form的数据，ajax请求）。</li>
</ol>
<p>3对应着意外退出，时间过了才重新登录的情况。这个时候的考试状态是，<code>report</code>的状态还是进行中，但是时间已经超过。这时候通过保存现场的数据计算分数即可。</p>
<h2 id="结束语">结束语</h2><p>我通过这样的设计，完成了一个体验相对良好，逻辑上没有问题，避免了用户在时间和数据上做手脚的在线考试功能。但因为是第一次做，也许有的地方还是考虑不周全，或者有更好的设计，希望大家多多指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2>]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站应对大数据量高并发的挑战]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/%E7%BD%91%E7%AB%99%E5%BA%94%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://rudy-zhang.me/2015/04/06/网站应对大数据量高并发的挑战/</id>
    <published>2015-04-06T13:12:52.000Z</published>
    <updated>2015-05-24T13:51:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使用不同的架构和解决方案。架构的改变和升级，往往意味着成本，所有没有最好的架构，只有最适合的架构。</p>
<p>应对数据量和负载的压力，可以从以下几个方面入手:</p>
<ul>
<li>硬件性能挖掘</li>
<li>数据库和存储</li>
<li>应用程序架构<br>每一个方面里都有非常多的技术</li>
</ul>
<h2 id="硬件性能挖掘">硬件性能挖掘</h2><p>硬件性能是有上限的，超过了就必须升级硬件，所以硬件是基础。</p>
<p>但是并不是一味的堆积硬件就可以了，要理解硬件的细节，如mysql的多线程写入机制，cpu寻址方式，顺序写和随机写的存储分布。不仅仅是购买硬件而已，但是核心是，理解硬件，理解系统级的处理机制，来做优化。</p>
<p>这样才能最大限度地挖掘硬件本省的性能，提供更好的服务。</p>
<h2 id="数据库和存储">数据库和存储</h2><p>大文件，或者大量的静态文件，使用静态存储，云存储</p>
<h3 id="建立恰当的索引">建立恰当的索引</h3><h3 id="数据库连接线程池缓存">数据库连接线程池缓存</h3><h3 id="分库/分表/分区">分库/分表/分区</h3><p>MySQL数据库表一般承受数据量在百万级别，再往上增长，各项性能将会出现大幅度下降，因此，当我们预见数据量会超过这个量级的时候，建议进行分库/分表/分区等操作。<br>一个主库一个从库、到一个主库多个从库、 然后到多个主库多个从库。从库做备份，或者作为读写分离的库。<br>多个库之间使用日志同步。</p>
<h3 id="拆分方式：水平拆分VS垂直拆分">拆分方式：水平拆分VS垂直拆分</h3><ul>
<li>垂直拆分 ：是指按功能模块拆分，比如可以将群组相关表和照片相关表存放在不同的数据库中，这种方式多个数据库之 间的表结构不同 。（豆瓣 的 各核心业务/模块（书籍、电影、音乐）相对独立，数据的增加速度也比较平稳。适合垂直拆分）</li>
<li>水平拆分 ：而水平拆分是将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构 完全相同 。</li>
</ul>
<h3 id="按索引_/_映射表对应">按索引 / 映射表对应</h3><p>建立一个索引表，保存每个用户的ID和数据库ID的对应关系，每次读写用户数据时先从这个表获取对应数据库。新用户注册后，在所有可用 的数据库中随机挑选一个为其建立索引。</p>
<h3 id="读写分离">读写分离</h3><p>读写分离，主库写，从库读。</p>
<h3 id="减少数据库写">减少数据库写</h3><p>先将修改请求生效在cache中，让外界查询显示正常，然后将这些sql修改放入到一个队列中存储起来，队列满或者每隔一段时间，合并为一个请求到数据库中更新数据库</p>
<h2 id="应用程序架构">应用程序架构</h2><h3 id="负载均衡">负载均衡</h3><p>Web负载均衡（Load Balancing），作用在Web系统的外部网络环境，简单地说就是给我们的服务器集群分配“工作任务”，而采用恰当的分配方式。对于保护处于后端的Web服务器来说，非常重要。策略有很多</p>
<h4 id="HTTP重定向">HTTP重定向</h4><p>Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。<br>应用：重定向到距离近的镜像去下载。</p>
<h4 id="反向代理负载均衡">反向代理负载均衡</h4><p>反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。把HTTP请求分配道不同的服务器上</p>
<h4 id="IP负载均衡">IP负载均衡</h4><p>IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。这种方式，也被称为“四层负载均衡”。</p>
<h4 id="DNS负载均衡">DNS负载均衡</h4><p>DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。</p>
<h4 id="DNS/GSLB负载均衡">DNS/GSLB负载均衡</h4><p>我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在<strong>同一个域名映射为多IP</strong>的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。<strong>一般情况下都是按照地理位置，将离用户近的IP返回给用户</strong>，减少网络传输中的路由节点之间的跳跃消耗。<br><strong>应用</strong>：CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。</p>
<h3 id="在Web服务器和数据库之间建立缓存">在Web服务器和数据库之间建立缓存</h3><p>80%的请求只关注在20%的热点数据上。因此，我们应该建立Web服务器和数据库之间的缓存机制。用磁盘作为缓存，也可以用内存缓存的方式。通过它们，<strong>将大部分的热点数据查询，阻挡在数据库之前</strong>。 </p>
<h4 id="页面静态化">页面静态化</h4><p>页面上的大部分内容在很长一段时间内，可能都是没有变化的。生成的静态html页面缓存到Web服务器的磁盘本地。直接将本地磁盘文件返回给用户。</p>
<h4 id="单台/集群内存缓存">单台/集群内存缓存</h4><p>一旦Web系统规模变大，例如当我有100台的Web服务器的时候。那样这些磁盘文件，将会有100份，这个是资源浪费，也不好维护。这个时候有人会想，可以集中一台服务器存起来<br>内存缓存的选择，主要有<strong>redis/memcache</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows上搭建Git服务器]]></title>
    <link href="http://rudy-zhang.me/2015/03/28/Windows%E4%B8%8A%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://rudy-zhang.me/2015/03/28/Windows上搭建Git服务器/</id>
    <published>2015-03-28T08:25:35.000Z</published>
    <updated>2015-05-24T14:09:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="需要的软件">需要的软件</h2><ul>
<li><a href="http://msysgit.github.io/" target="_blank" rel="external"><strong>msysgit</strong></a> (服务器和客户端)</li>
</ul>
<p>首先你要有一个git环境。git 是分布式版本管理软件，大家都是服务器，大家都是客户端，所以客户端和服务器的安装文件是一样的。</p>
<ul>
<li><a href="https://www.itefix.net/copssh" target="_blank" rel="external"><strong>CopSSH</strong></a>  (服务器) </li>
</ul>
<p>Git支持ssh和http，所以我们要想在git服务器和客户端之间通信通过ssh，就需要再windows server下面安装一个ssh服务器，能够处理ssh请求。COPSSH是一个windows下的SSH服务器,可以远程管理电脑系统。</p>
<ul>
<li><a href="http://download.tortoisegit.org/" target="_blank" rel="external"><strong>TortoiseGit </strong></a>(客户端) </li>
</ul>
<p>TortoiseGit 是git的图形化管理工具。如果对git命令行比较熟悉，可以不用安装。<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqlipxsfhij20lc07waaj.jpg" alt="enter image description here"></p>
<h2 id="在Server上安装msygit">在Server上安装msygit</h2><p>下一步，下一步，下一步</p>
<h2 id="在Server上安装ssh服务器">在Server上安装ssh服务器</h2><h3 id="安装CopSSH软件">安装CopSSH软件</h3><p>下一步，下一步，下一步</p>
<h3 id="配置用户">配置用户</h3><p>添加系统的administrator用户到SSH服务器当中，之后git需要通过这个用户才能访问。<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1eqlipy48axj20fn0cadgk.jpg" alt="enter image description here"></p>
<p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqlipydgvfj20jm0dg75j.jpg" alt="enter image description here"></p>
<p>设置了密码验证，公钥验证</p>
<p><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqlipympf3j20ji0ddt9z.jpg" alt="enter image description here"></p>
<p>在使用github连接远程仓库的时候我们需要用到命令：<br><code>git remote add origin git@github.com:michaelliao/learngit.git</code><br><code>git@github.com</code>是远程地址，我们连接自建的server要改成<code>administrator@ipaddress</code>这样就能够识别远程仓库地址和我们要使用的用户，后面<code>:path</code>要改成我们git仓库的地址，稍后有例子。</p>
<h3 id="配置COPSSH的安装目录">配置COPSSH的安装目录</h3><p>COPSSH获得了ssh请求，如何才能调用git命令呢，需要：</p>
<ol>
<li>将Git安装目录<code>yourpath\Git\libexec\git-core</code>文件夹下的<code>git-upload-pack.exe</code>、<code>git.exe</code>、<code>git-receive-pack.exe</code>和<code>git-upload-archive.exe</code>这4个文件复制到SSH的安装路径1yourpath\ICW\bin1下。</li>
<li><p>将Git安装目录<code>yourapth\Git\bin\libiconv-2.dll</code>复制到<code>yourpath\ICW\bin</code>下。<br>这样COPSSH就可以帮我们调用git命令了<br><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1eqlipzeknej20s20a4abj.jpg" alt="enter image description here"></p>
<p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqlipznquwj20ir0713z8.jpg" alt="enter image description here"></p>
<h3 id="测试连接">测试连接</h3><p>本地打开gitbash，ssh连接服务器:<code>ssh administrator@192.168.199.171</code><br>输入administrator的密码后就通过ssh远程连接到了服务器上，在这上面可以通过git命令做操作。</p>
</li>
</ol>
<h2 id="建库操作">建库操作</h2><p>使用通过ssh远程登录的账户调用git命令建库</p>
<p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqlipzviylj20hw05p3z2.jpg" alt="enter image description here"></p>
<h3 id="关于裸库">关于裸库</h3><p>用<code>git init</code>初始化的版本库用户也可以在该目录下执行所有git方面的操作。但别的用户在将更新push上来的时候容易出现冲突。<br>使用<code>git init –bare</code>方法创建一个所谓的裸仓库，之所以叫裸仓库是因为这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作，如果你硬要操作的话，只会得到下面的错误（”This operation must be run in a work tree”）<br>这个就是最好把远端仓库初始化成bare仓库的原因。<br>在裸仓库中只能切换分支，不能合并分支</p>
<h2 id="远程clone，push，pull">远程clone，push，pull</h2><h3 id="clone">clone</h3><p>在本地打开gitbash，输入<br><code>git clone administrator@192.168.199.171:yourpath/testrepo</code></p>
<h3 id="认证身份">认证身份</h3><p>服务器怎么知道clone，push的人的身份呢，COPSSH使用了系统用户的密码，在我们clone的时候，需要输入administrator的密码，这样就完成了身份验证，并不需要把我们本地的公钥加入的COPSSH用户的公钥当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone administrator@192.168.199.171:yourpath/testrepo&#10;Cloning into &#39;testrepo&#39;...&#10;administrator@192.168.199.171&#39;s password:&#10;warning: You appear to have cloned an empty repository.&#10;Checking connectivity... done.</span><br></pre></td></tr></table></figure>
<p>克隆的过程是，克隆过来整个版本库，包括远程的各个分支，在本地创建master分支，把远程的master分支内容克隆到本地的master分支上。<br>所以我们克隆过来的是master分支，如果我们想获远程取别的分支上的内容，如dev：<br><code>git branch -a</code>获取所有分支内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a&#10;* (detached from origin/dev)&#10;  master&#10;  remotes/origin/HEAD -&#62; origin/master&#10;  remotes/origin/dev&#10;  remotes/origin/master</span><br></pre></td></tr></table></figure></p>
<p><code>git checkout -b dev remotes/origin/dev</code>新建dev分支，内容来自<code>remotes/origin/dev</code></p>
<h3 id="push">push</h3><p><code>git push origin dev</code><br>推送当前的分支到远程的dev分支</p>
<h3 id="pull">pull</h3><p><code>git pull origin dev</code><br>含义是获取远程dev分支上的内容到本地工作的分支。<br>所以也可以通过</p>
<ol>
<li>在本地创建dev分支<br><code>git checkout -b dev</code></li>
<li>拉取远程dev分支的内容<br><code>git pull origin dev</code><br>来获取远程dev分支的内容到本地dev分支<h2 id="TortoiseGit">TortoiseGit</h2>客户端软件，图形化界面，下一步即可。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="需要的软件">需要的软件</h2><ul>
<li><a href="http://msysgit.github.io/" target="_blank" rel="external"><strong>msysgit</strong></a> (服务器和客户端)<]]>
    </summary>
    
      <category term="Git" scheme="http://rudy-zhang.me/tags/Git/"/>
    
      <category term="开发工具" scheme="http://rudy-zhang.me/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用bootstrap进行布局]]></title>
    <link href="http://rudy-zhang.me/2015/03/21/%E4%BD%BF%E7%94%A8bootstrap%E8%BF%9B%E8%A1%8C%E5%B8%83%E5%B1%80/"/>
    <id>http://rudy-zhang.me/2015/03/21/使用bootstrap进行布局/</id>
    <published>2015-03-21T02:49:20.000Z</published>
    <updated>2015-05-24T07:27:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>bootstrap来自twitter，是最受欢迎的前端框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。</p>
<blockquote>
<p>LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。</p>
</blockquote>
<p><a href="http://v3.bootcss.com/components/" target="_blank" rel="external">使用boostrap的组件</a><br><a href="https://bootswatch.com/" target="_blank" rel="external">寻找漂亮的的bootstrap主题</a><br>本文主要讨论bootstrap的布局</p>
<h2 id="栅格化布局">栅格化布局</h2><blockquote>
<p>Bootstrap 提供了一套<strong>响应式</strong>、<strong>移动设备优先</strong>的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p>
</blockquote>
<h2 id="内边距，外边距">内边距，外边距</h2><p>首先需要理解，html内边距（padding），外边距（margin）</p>
<p>CSS中的边距指的是当前元素border与周围其它元素border的距离（或者称为空间）。</p>
<p><strong>Box Model</strong>: 任意一个块级元素均由</p>
<ul>
<li>content(内容),</li>
<li>padding</li>
<li>background(包括背景颜色和图片),</li>
<li>border(边框)</li>
<li>margin<br>五个部分组成<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqd4plmz36j20dk0crmyn.jpg" alt="enter image description here"></li>
</ul>
<h2 id="栅格系统之布局容器-container">栅格系统之布局容器.container</h2><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。</p>
<ul>
<li>.container 类用于固定宽度并支持响应式布局的容器。</li>
<li>.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。</li>
</ul>
<p>作用：</p>
<ul>
<li>在响应式宽度上提供<strong>宽度约束</strong>。响应式尺寸的改变其实改变的是 container ，行 (rows) 和列 (columns) 都是基于1 、在响应式宽度上提供宽度约束。响应式尺寸的改变其实改变的是 container ，行 (rows) 和列 (columns) 都是基于百分比的所以它们不需要做任何改变；</li>
<li>提供 padding 以至于不内容不直为紧贴于浏览器边缘，两边都是 15px ，下图中粉色的就是了，稍后解释更多；<br><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1eqd4plxjvkj20go08kaad.jpg" alt="enter image description here"><br><strong>在一个container中永远不需要再嵌一个container，记住永远不要。</strong></li>
</ul>
<h2 id="栅格系统之row">栅格系统之row</h2><p>row 为 col 提供了空间，理想上一行上分了 12 col<br>Rows  的两侧都拥有独特的负 15px margin 值<br><strong>永远不要在 container 外用 row, row 在 container 外面使用是无效的</strong><br><img src="http://ww4.sinaimg.cn/mw690/4c2edcb7jw1eqd4pm6ym6j20go08jmxm.jpg" alt="enter image description here"></p>
<h2 id="栅格系统之column">栅格系统之column</h2><p>列(col)现在有15px的padding了，如下图中黄颜色部分。Container的正padding值造成了15px的留空，row用负margin值反的延伸回去，<br><strong>所以现在col的padding值与container的padding重叠了</strong><br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqd4pmjifqj20go08kjrz.jpg" alt="enter image description here"><br><strong>永远不要在row外使用col,在row外使用col是无效的</strong><br>然后col就是一个.container了，你可以在里面继续使用row了<br><strong>container/row/column整这么些事儿最终要达到的结果就体现在这里了，就是为了col的补白</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>bootstrap来自twitter，是最受欢迎的前端框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。</p>
<blockquote>
<p>LESS 包含一套自定义的语法及一个解析器，用]]>
    </summary>
    
      <category term="bootstrap" scheme="http://rudy-zhang.me/tags/bootstrap/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <link href="http://rudy-zhang.me/2015/03/21/Git%E7%AC%94%E8%AE%B0/"/>
    <id>http://rudy-zhang.me/2015/03/21/Git笔记/</id>
    <published>2015-03-21T00:21:32.000Z</published>
    <updated>2015-09-28T08:51:10.079Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>实验室的项目需要用到一个版本管理系统进行管理，鉴于Git如此风靡，所以正好拿来用，顺便学习一下。一下是Git学习的笔记，大部分内容来自<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a>。</p>
<p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。所以一切操作几乎都是在一瞬间完成的。</p>
<h2 id="集中式VS分布式">集中式VS分布式</h2><p>集中式版本控制系统，版本库是集中存放在中央服务器的。所有的修改都要经过中央服务器。<br>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。<br><strong>Git的特点就是，没有中央服务器，大家都是中央服务器</strong></p>
<h2 id="创建版本库">创建版本库</h2><p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li><p>第一步，使用命令<code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</p>
</li>
<li><p>第二步，使用命令<code>git commit</code>，完成。</p>
</li>
</ol>
<h2 id="查看状态">查看状态</h2><p>要随时掌握工作区的状态，使用<code>git status</code>命令。<br> 如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
<h2 id="版本回退">版本回退</h2><p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqd05t0do1j206j04imx4.jpg" alt=""><br>HEAD指向的版本就是当前版本(HEAD指向当前的分支)</p>
<p> 因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
<p>返回过去，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<h2 id="工作区VS版本库VS暂存区">工作区VS版本库VS暂存区</h2><ul>
<li>工作区（Working Directory）：就是你在电脑里能看到的目录</li>
<li>版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li>
<li>暂存区(stage) : 版本库里存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eqd05ta69vj20cq06imxh.jpg" alt="enter image description here"></li>
</ul>
<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage）<br>执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。<br><strong>Git跟踪的是修改，每次修改，如果不add到暂存区，那就不会加入到commit中。</strong></p>
<h2 id="撤销修改">撤销修改</h2><ul>
<li>还没有<code>git add</code>到暂存区的代码<br><code>git checkout</code> 从暂存区或者版本库签出（取消工作区代码）,例：<code>git checkout -- readme.txt</code></li>
</ul>
<ol>
<li>暂存区有代码，签出暂存区代码</li>
<li>暂存区没代码，签出版本库代码</li>
</ol>
<ul>
<li><p>已经添加到暂存区的代码,<code>git reset HEAD readme.txt</code><br>再用<code>checkout</code>命令</p>
</li>
<li><p>已经commit的代码<br>在推送到远程版本库之前切换版本,<code>git reset --hard</code> 版本号</p>
</li>
<li><p>删除文件(删除也是一个修改操作)<br><code>git rm</code>用于删除一个文件（类似于git add将更改放到暂存区）<br><code>git commit</code> 提交</p>
</li>
</ul>
<h2 id="github远程仓库">github远程仓库</h2><p>提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库</p>
<h3 id="生成ssh密钥">生成ssh密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#34;youremail@example.com&#34;</span><br></pre></td></tr></table></figure>
<p>生成ssh 公钥和私钥</p>
<h3 id="关联远程库">关联远程库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure>
<h3 id="推送">推送</h3><p>使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<h3 id="克隆">克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>
<h2 id="分支管理">分支管理</h2><p>Git用master（主分支）指向最新的提交，再用HEAD指向当前分支<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突">解决冲突</h3><p><code>Rudy@RUDY ~/learngit (master|MERGING)</code><br>相当于另外创建了一个分支，保存冲突，提交时以这个分支为准</p>
<h3 id="分支策略">分支策略</h3><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqd05tptzoj20du03h3yy.jpg" alt="enter image description here"></p>
<h3 id="修复bug，保存现场状态">修复bug，保存现场状态</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<blockquote>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</p>
<h3 id="新的feature分支">新的feature分支</h3><p>开发一个新feature，最好新建一个分支；</p>
</blockquote>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h2 id="多人协作工作">多人协作工作</h2><p>实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>试图推送：可以试图用<code>git push origin branch-name</code>推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</p>
<p>如果git pull提示<code>no tracking information</code><br>     说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<h2 id="标签管理">标签管理</h2><p><strong>发布一个版本时</strong>，我们通常先在版本库中打一个标签。标签也是<strong>版本库的一个快照</strong>。</p>
<p>Git的标签虽然是版本库的快照，但其实<strong>它就是指向某个commit的指针</strong>（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>查看所有标签<code>git tag</code></p>
<p>新建标签<code>git tag &lt;name&gt;</code>，默认为HEAD，也可以指定一个commit id；</p>
<p>指定标签信息,<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code></p>
<p>用PGP签名标签,<code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</p>
<p>推送一个本地标签<code>git push origin &lt;tagname&gt;</code></p>
<p>推送全部未推送过的本地标签<code>git push origin --tags</code></p>
<p>删除一个本地标签<code>git tag -d &lt;tagname&gt;</code></p>
<p>删除一个远程标签<code>git push origin :refs/tags/&lt;tagname&gt;</code></p>
<h2 id="忽略特殊文件">忽略特殊文件</h2><h3 id="问题">问题</h3><p>有些时候，必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件,每次git status都会显示“Untracked files …”</p>
<h3 id="解决办法">解决办法</h3><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>忽略文件的原则是：</p>
<blockquote>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
</blockquote>
<h2 id="配置别名">配置别名</h2><p><code>git config --global alias.st status</code>设置st为status的别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &#34;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&#60;%an&#62;%Creset&#39; --abbrev-commit&#34;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqd05u3pp8j20ca08agnx.jpg" alt="enter image description here"></p>
<h2 id="在windows下复制版本库">在windows下复制版本库</h2><p>注意路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone administrator@192.168.1.13:c:/GitProject/testrepo</span><br></pre></td></tr></table></figure></p>
<h2 id="git_init_VS_git_init_–bare">git init VS git init –bare</h2><p>用<code>git init</code>初始化的版本库用户也可以在该目录下执行所有git方面的操作。但别的用户在将更新push上来的时候容易出现冲突。<br>使用<code>git init –bare</code>方法创建一个所谓的裸仓库，之所以叫裸仓库是因为这个仓库只保存git历史提交的版本信息，而<strong>不允许用户在上面进行各种git操作</strong>，如果你硬要操作的话，只会得到下面的错误（”This operation must be run in a work tree”）<br>这个就是<strong>最好把远端仓库初始化成bare仓库的原因</strong>。</p>
<p>在裸仓库中只能切换分支，不能合并分支</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>实验室的项目需要用到一个版本管理系统进行管理，鉴于Git如此风靡，所以正好拿来用，顺便学习一下。一下是Git学习的笔记，大部分内容来自<a href="http://www.liaoxuefeng.com/wiki/0013739516]]>
    </summary>
    
      <category term="Git" scheme="http://rudy-zhang.me/tags/Git/"/>
    
      <category term="开发工具" scheme="http://rudy-zhang.me/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASP.NET MVC之本地化多语言]]></title>
    <link href="http://rudy-zhang.me/2015/03/20/ASP.NET%20MVC%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://rudy-zhang.me/2015/03/20/ASP.NET MVC之本地化多语言/</id>
    <published>2015-03-20T11:56:58.000Z</published>
    <updated>2015-05-24T14:05:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>使用ASP MVC的本地化多语言解决方案可以方便地让我们把程序中的字符串映射到一个资源文件中，这样便于统一修改，同时只要指定使用不同的语言，就可以瞬间切换资源文件，从而达到灵活修改网站的目的。</p>
<h2 id="新建资源文件">新建资源文件</h2><p>如图在项目中新建了三个资源文件，一个默认Global.resx,一个是英文Global.en.resx，一个是备份的Global.ar.resx<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1eqcfrko5gaj209u07rdg5.jpg" alt="enter image description here"></p>
<h2 id="修改key-value">修改key-value</h2><p><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqcfrkznssj20k70cidhq.jpg" alt="enter image description here"></p>
<h2 id="什么时候使用">什么时候使用</h2><p>ASP.NET MVC 还提供将强类型数据或对象传递到视图模板的能力。便于检查类型错误。<br>使用方法：</p>
<ul>
<li>简单独立的数据使用ViewBag</li>
<li>向前端传递一个大的对象，使用试图模板，便于检查错误</li>
</ul>
<h2 id="如何把Key放入到程序当中">如何把Key放入到程序当中</h2><h3 id="在Model中">在Model中</h3><p>对应Display属性使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Display(Name = &#34;UserName&#34;,ResourceType=typeof(Resources.Global))]</span><br></pre></td></tr></table></figure>
<p>对于ErrorMessage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Required(ErrorMessageResourceName = &#34;PasswordRequiredMessage&#34;, ErrorMessageResourceType = typeof(Resources.Global))]</span><br></pre></td></tr></table></figure>
<h3 id="在Controller中">在Controller中</h3><p>一般来说在Controller不出现汉字的字符串，如果使用，可以通过如下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string myString=HospitalProject.Resources.Global.DoctorName;</span><br></pre></td></tr></table></figure>
<h3 id="在前端">在前端</h3><p>使用razor表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Html.ActionLink(@HospitalProject.Resources.Global.NetworkDiagnosisHome, &#34;Index&#34;, &#34;Home&#34;, routeValues: null, htmlAttributes: new &#123; @class = &#34;navbar-brand&#34; &#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="如何指定资源文件">如何指定资源文件</h2><p>在<code>ViewStart.cshtml</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXXProject.Extensions.CultureHelper.SetCulture(&#34;ar&#34;);</span><br></pre></td></tr></table></figure>
<h2 id="后记">后记</h2><p>通过本方法可以方便进行网站资源文件的切换，如果需要实现网站同时支持多种语言，使用cookie或者URL route需要进行其他配置。参考：<br><a href="http://jingyan.baidu.com/article/3052f5a1d4410797f31f86f8.html" target="_blank" rel="external">参考1</a><br><a href="http://www.cnblogs.com/xyfy/articles/1970424.html" target="_blank" rel="external">参考2</a><br><a href="http://afana.me/post/aspnet-mvc-internationalization.aspx" target="_blank" rel="external">参考3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>使用ASP MVC的本地化多语言解决方案可以方便地让我们把程序中的字符串映射到一个资源文件中，这样便于统一修改，同时只要指定使用不同的语言，就可以瞬间切换资源文件，从而达到灵活修改网站的目的。</p>
<h2 id="新建资源文件">新]]>
    </summary>
    
      <category term="ASP MVC" scheme="http://rudy-zhang.me/tags/ASP-MVC/"/>
    
      <category term=".NET" scheme="http://rudy-zhang.me/categories/NET/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASP.NET MVC之Entity Framewrok]]></title>
    <link href="http://rudy-zhang.me/2015/03/20/ASP.NET%20MVC%E4%B9%8BEntity%20Framewrok/"/>
    <id>http://rudy-zhang.me/2015/03/20/ASP.NET MVC之Entity Framewrok/</id>
    <published>2015-03-20T08:55:10.000Z</published>
    <updated>2015-05-24T02:27:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="解释">解释</h2><p>Entity Framework 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。</p>
<blockquote>
<p>对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。</p>
</blockquote>
<h2 id="三种方式">三种方式</h2><ul>
<li>Database-first（数据库先行）：从一个数据库开始，然后实体框架生成相应代码。</li>
<li>Model-first（模型先行）：先从一个可视化模型开始，然后实体框架生成数据库和代码。</li>
<li>Code-first（代码先行）：先从代码开始，然后实体框架生成数据库</li>
</ul>
<p>CodeFirst 用中文说是代码优先，此技术可以让我们先写代码，然后由Entity Framework根据我们的代码建立数据库。</p>
<p>CodeFirst和ModelFirst的数据库连接方式不一样，但都可以现在VS中测试连接</p>
<h2 id="why_codefirst？">why codefirst？</h2><p>代码优先的开发支持更加优美的开发流程，它允许你：</p>
<blockquote>
<ul>
<li>在不使用设计器或者定义一个 XML 映射文件的情况下进行开发。</li>
<li>允许编写简单的模型对象POCO (plain old classes)，而不需要基类。</li>
<li>通过”约定优于配置”，使得数据库持久层不需要任何的配置</li>
<li>也可以覆盖”约定优于配置”，通过流畅的 API 来完全定制持层的映射。</li>
</ul>
</blockquote>
<p>Code First是基于Entity Framework的新的开发模式，原先只有Database First和Model First两种。Code First顾名思义，就是先用C#/VB.NET的类定义好你的领域模型，然后用这些类映射到现有的数据库或者产生新的数据库结构。<strong>写好代码就行，数据库几乎不需要操作</strong>。</p>
<h2 id="使用codefirst建立数据库">使用codefirst建立数据库</h2><h3 id="建立实体类">建立实体类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#10;&#123;&#10;    public int StudentID &#123; get; set; &#125;&#10;    public string LastName &#123; get; set; &#125;&#10;    public string FirstNidName &#123; get; set; &#125;&#10;    public DateTime EnrollmentDate &#123; get; set; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DAL数据库连接层，创建实体集">DAL数据库连接层，创建实体集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class SchoolContext : DbContext&#10;&#123;&#10;    public DbSet &#60;Student&#62; Students &#123; get; set ; &#125;&#10;    public DbSet &#60;Enrollment&#62; Enrollments &#123; get; set ; &#125;&#10;    public DbSet &#60;Course&#62; Courses &#123; get; set ; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继承自System.Data.Entity下的DbContext，它将我们的数据模型映射到数据库中，将代码中的数据持久化。<br><strong>这里相当于做了代码和数据库的表映射。</strong></p>
<h3 id="向web-config中添加数据库连接">向web.config中添加数据库连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;add name=&#34; SchoolContext&#34; connectionString=&#34; Data Source=(LocalDb)\v11.0;Initial Catalog=ContosoUniversity;Integrated Security=SSPI;AttachDBFilename=|DataDirectory|\ContosoUniversity.mdf&#34; providerName=&#34; System.Data.SqlClient&#34; /&#62;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>当系统开始运行，会自动检查SchoolContext 对应的数据库是否建立，如果没有建立就通过已经做好的实体类和表映射关系在数据库中映射出需要的数据库表。</p>
<h2 id="基于标注的前后端验证">基于标注的前后端验证</h2><p>在建立网站的时候，都需要进行数据验证。前后端都要验证，前端js，后台使用后台的代码。实际的项目中一般前后端程序员约定好，然后分别写代码进行验证，很麻烦。ASP MVC为我们建立了一套非常简单的方法，只需要为属性添加标注，即可在前后端使用同一套验证逻辑。</p>
<h3 id="添加标注">添加标注</h3><p>在已经建好的实体类中，可以为属性添加Data Annotations（标注）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Movie &#123;&#10;    public int ID &#123; get; set; &#125;&#10;&#10;    [Required]&#10;    public string Title &#123; get; set; &#125;&#10;&#10;    [DataType(DataType.Date)]&#10;    public DateTime ReleaseDate &#123; get; set; &#125;&#10;&#10;    [Required]&#10;    public string Genre &#123; get; set; &#125;&#10;&#10;    [Range(1, 100)]&#10;    [DataType(DataType.Currency)]&#10;    public decimal Price &#123; get; set; &#125;&#10;&#10;    [StringLength(5)]&#10;    public string Rating &#123; get; set; &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后端验证">后端验证</h3><p>使用<code>ModelState.IsValid</code> 即可实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]&#10;public ActionResult Index(Party party)&#10;&#123;&#10;    if(ModelState.IsValid)&#10;    &#123;&#10;        // TO DO: save the party to database&#10;        return View(&#34;Thanks&#34;);&#10;    &#125;&#10;    return View();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前端验证">前端验证</h3><p>打开配置文件<code>web.config</code>，配置前端验证开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;appSettings&#62;&#10;    &#60;add key=&#34;ClientValidationEnabled&#34; value=&#34;true&#34; /&#62;&#10;    &#60;add key=&#34;UnobtrusiveJavaScriptEnabled&#34; value=&#34;true&#34;/&#62;&#10;&#60;/appSettings&#62;</span><br></pre></td></tr></table></figure>
<p>包含JQuery验证库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;script src=&#34;@Url.Content(&#34;~/Scripts/jquery-1.5.1.min.js&#34;)&#34; type=&#34;text/javascript&#34;&#62;&#60;/script&#62;&#10;&#60;script src=&#34;@Url.Content(&#34;~/Scripts/jquery.validate.min.js&#34;)&#34; type=&#34;text/javascript&#34;&#62;&#60;/script&#62;&#10;&#60;script src=&#34;@Url.Content(&#34;~/Scripts/jquery.validate.unobtrusive.min.js&#34;)&#34; type=&#34;text/javascript&#34;&#62;&#60;/script&#62;</span><br></pre></td></tr></table></figure>
<p>在前端输出验证信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Html.ValidationMessageFor()</span><br></pre></td></tr></table></figure>
<p>ASP MVC为我们提供了可以满足大部分需求的验证逻辑。但是如果想定制验证逻辑，也是可以的。参考<a href="http://prideparrot.com/blog/archive/2012/4/model_validation_in_asp_net_mvc" target="_blank" rel="external">自定义验证</a></p>
<h2 id="codefirst更新数据库">codefirst更新数据库</h2><h3 id="启用迁移">启用迁移</h3><p>打开VS，工具&gt;库程序包管理器&gt;程序包管理器控制台。使用命令<br><code>Enable-Migrations</code></p>
<h3 id="生成和运行迁移">生成和运行迁移</h3><ul>
<li><code>Add-Migration</code>      对比当前数据库和模型的差异，生成相应的代码，使数据库和模型匹配的。</li>
<li><code>Update-Database</code>  将任何挂起的迁移到数据库。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="解释">解释</h2><p>Entity Framework 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。</p>
<blockquote>
<p>对象关系映射（Object Relational Mapping]]>
    </summary>
    
      <category term="ASP MVC" scheme="http://rudy-zhang.me/tags/ASP-MVC/"/>
    
      <category term=".NET" scheme="http://rudy-zhang.me/categories/NET/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[电脑鼠的回忆]]></title>
    <link href="http://rudy-zhang.me/2015/03/17/%E7%94%B5%E8%84%91%E9%BC%A0%E7%9A%84%E5%9B%9E%E5%BF%86/"/>
    <id>http://rudy-zhang.me/2015/03/17/电脑鼠的回忆/</id>
    <published>2015-03-17T02:57:40.000Z</published>
    <updated>2015-05-24T07:31:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>电脑鼠项目是本科的时候参加的项目了，如今拿出来回一下，复习一下原来学习的C和相关的算法，看到当年青涩的我们，也是别有一番滋味。</p>
<h2 id="IEEE电脑鼠介绍">IEEE电脑鼠介绍</h2><p>IEEE国际电脑鼠走迷宫邀请赛，比赛要求电脑鼠自动走索迷宫并完成冲刺。首先电脑鼠在16x16的未知迷宫中探索前进的路线，到达终点之后返回起点，这一过程称为 <strong>试跑</strong>。然后以最快速度最好路线冲刺到终点，这一过程称为 <strong>冲刺</strong> 。最终成绩=试跑时间*（1/30）+冲刺时间。当然过程中碰到迷宫墙壁是有罚时的。迷宫长的就是这个样子的，这是我们参加比赛的时候现场的赛道：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eq8zwm7fvsj20t20ky400.jpg" alt="enter image description here"></p>
<p>具体关于电脑鼠的规则可以参考这里：<a href="http://www.csuchico.edu/ieee/micromouse.html" target="_blank" rel="external">IEEE电脑鼠介绍</a></p>
<h2 id="设计">设计</h2><h3 id="硬件部分">硬件部分</h3><p>硬件我不是很精通，好在我们有硬件大牛，邈哥，纯geek，只要是带电的，没有不懂的，他在硬件上的知识储备真是让人咋舌，为每一个硬件，每一个指标都进行追求极限的设计。</p>
<p>硬件指标：</p>
<blockquote>
<ul>
<li>中心控制器使用32位处理器STM32F103；</li>
<li>传感器共有六对红外发射管、接收管，用于探测墙壁距离并提供迷宫墙壁信息。</li>
<li>陀螺仪采用量程±2000°/s的数字式陀螺仪L3G4200，用来校正电脑鼠转弯时的角度误差。</li>
<li>电机驱动电路使用两组H型全桥电路配合PWM信号控制，可以使电机正转与反转。</li>
<li>电机选用微型直流空心杯减速电机，并配合512线编码器可获得电机转速。</li>
<li>预留无线串口可外接蓝牙模块与PC机实现数据传输，配合按键与可编程LED实现人机交互。</li>
</ul>
</blockquote>
<p>硬件架构图：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eq8zwmgi89j20h20czdgj.jpg" alt="Alt text"></p>
<p>最后做成了这样一辆小跑车。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eq8zwmt483j20wb0jigo5.jpg" alt="Alt text"></p>
<h3 id="软件部分">软件部分</h3><p>这个时候就要靠我们学软件的人了，由于采用的是嵌入式设备，必须把写好的C程序烧到中心控制器。中心控制器相当于整个设备的大脑，所有行走的策略，控制硬件启动，接收硬件数据，发出指令都存储在STM32控制芯片当中。</p>
<p>下面是整个软件部分的架构图：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1eq8zwn1gcsj20gy0l4jtj.jpg" alt="Alt text"></p>
<p>想要达到一个良好的表现，硬件是至关重要的，就像是经济基础决定上层建筑。同时有了经济基础也需要更好的策略来指挥硬件行动。电脑鼠的策略分成两部分：</p>
<blockquote>
<ul>
<li>探索时候的策略</li>
<li>冲刺时候的策略</li>
</ul>
</blockquote>
<h4 id="探索的策略">探索的策略</h4><p>由于迷宫是未知的，需要电脑鼠不断探索迷宫中的格子，每次碰到岔路的时候都要决定下一次要往哪里探索，所以这一部分是最tricky的，好的算法不一定有好的结果，但是不好的算法很可能有不好的结果。<br>常见的策略</p>
<blockquote>
<ul>
<li>右手法则： 以右边为优先的前进方向，然后是直线方向、左边方向。 </li>
<li>左手法则： 以左边为优先的前进方向，然后是直线方向、右边方向。 </li>
<li>中左法则： 以直线为优先的前进方向，然后是左边方向、右边方向。 </li>
<li>乱数法则： 取随机值作为前进方向。 </li>
<li>向心法则： 由于终点设在迷宫的中心，遇有交叉时，以指向迷宫中心的方向为优先的前进方向。 </li>
</ul>
</blockquote>
<p>还有一种相对这些算法更加优秀的算法，也是我们采用的算法，叫做<strong>洪水填充算法</strong>：</p>
<blockquote>
<p>洪水填充法，也称为贝尔曼的算法(Bellman’s algorithm)，与上述的种演算法相比是更适合的方法。该演算法使用距离和墙壁的知识去寻找到达迷宫中心的较短路径。在这个该演算法中，每一个格子存在一个代表距离的物理量，此物理量代表该格子与迷宫中心可能的最短的曼哈顿距离(为方便本文就直接称此物理量为距离)。</p>
<p>洪水填充法被称为“广度优先”演算法，因为如果迷宫被表示成一个生成树，演算法会先搜查同一层的格子，接着才搜寻下一层的格子。洪水填充算法的主要优点是，它总能找到到达迷宫中心的最短路径。但值得注意的是，此方法实际走的路径被非最短路径。</p>
</blockquote>
<p>使用到的关键函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDistance</span><span class="params">()</span></span>;<span class="comment">//当朝向迷宫中心时，曼哈顿距离的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDistance2</span><span class="params">()</span></span>;<span class="comment">//当朝向起点时，曼哈顿距离的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initTempMap</span><span class="params">()</span></span>;<span class="comment">//初始化临时地图</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">atGoal</span><span class="params">(<span class="keyword">struct</span> Point robot)</span></span>;<span class="comment">//返回是否到达中心</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">atStart</span><span class="params">(<span class="keyword">struct</span> Point p)</span></span>;<span class="comment">//返回是否到达终点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_Maze_Set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Maze * m)</span></span>;<span class="comment">//设置迷宫句柄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeMaze</span><span class="params">()</span></span>;<span class="comment">//初始化迷宫数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">l_HandleRequest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Robot robot, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> NW,</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> EW, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SW, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> WW)</span></span>;</span><br><span class="line"><span class="comment">// 根据当前的位置和墙壁信息，返回应该走的方向</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">canGetByDir</span><span class="params">(<span class="keyword">struct</span> Point p,<span class="keyword">char</span> dir)</span></span>;<span class="comment">//返回是否从某点走向某个方向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshDistance</span><span class="params">(<span class="keyword">struct</span> Point p)</span></span>;<span class="comment">//更新某点的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freshTempMap</span><span class="params">(<span class="keyword">struct</span> Robot robot)</span></span>;<span class="comment">//更新临时地图的信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDisByDir</span><span class="params">(<span class="keyword">struct</span> Point p,<span class="keyword">int</span> dir)</span></span>;<span class="comment">//返回某点某个方向上的距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">roundMinDistance</span><span class="params">(<span class="keyword">struct</span> Point p)</span></span>;<span class="comment">//计算某点周围可以到达的点的最小距离</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">roundMinDir</span><span class="params">(<span class="keyword">struct</span> Robot r)</span></span>;<span class="comment">//返回周围最小距离点相对于当前点的方向</span></span><br></pre></td></tr></table></figure>
<p>l_HandleRequest函数的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">l_HandleRequest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Robot robot, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> NW,</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> EW, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SW, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> WW)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//!根据传入的信息更新tempMap中的墙壁</span></span><br><span class="line">    maze-&gt;walkHistory[robot.position.y][robot.position.x]=<span class="number">1</span>;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=NW;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=EW;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=SW;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=WW;</span><br><span class="line">    </span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=NORTH_WALL_COVERED;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=EAST_WALL_COVERED;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=SOUTH_WALL_COVERED;</span><br><span class="line">    maze-&gt;tempMap[robot.position.y][robot.position.x]|=WEST_WALL_COVERED;</span><br><span class="line">    freshTempMap(robot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!更新距离信息</span></span><br><span class="line">    refreshDistance(robot.position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!返回应该走的方向</span></span><br><span class="line">    <span class="keyword">return</span> roundMinDir(robot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冲刺的策略">冲刺的策略</h4><p>冲刺的时候，中心控制器中已经存储了探索过程的数据。需要做的是根据车子的各方面的性能，如启动速度，减速的速度，转弯的速度，等所有的因素整合起来作为变量，再加上已知的迷宫数据，计算出最好的路径，然后出发就可以了。由于迷宫已知，所以算法也是确定的，关键在于考虑到足够多的因素，输入的变量越多，越真实，计算出的结果越可靠，同时计算量也就越大，在实际操作的时候要达到一个良好的平衡。</p>
<p>我们使用图论的思想，在搜索最短路径的过程中加入直线和拐弯的权重，使用广度优先的搜索算法找出最短路径，从而接近真实的模拟老鼠的冲刺时间。使用堆进行优化，经测试，算法的复杂度为NlogN。</p>
<p>冲刺用到的关键函数；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Maze_Set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Maze * m)</span></span>;<span class="comment">//设置迷宫句柄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Main</span><span class="params">()</span></span>;<span class="comment">//冲刺主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Initialize</span><span class="params">()</span></span>;<span class="comment">//初始化冲刺过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Attack_Map_Print</span><span class="params">()</span></span>;<span class="comment">//调试，输出冲刺地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Heap_Print</span><span class="params">()</span></span>;<span class="comment">//调试,输出堆的内容</span></span><br></pre></td></tr></table></figure>
<p>冲刺算法的主函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack_Main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Attack_Map[SIZE-<span class="number">1</span>][<span class="number">0</span>].pre=NULL;</span><br><span class="line">    Attack_Map[SIZE-<span class="number">1</span>][<span class="number">0</span>].cost=<span class="number">0</span>;</span><br><span class="line">    Attack_Map[SIZE-<span class="number">1</span>][<span class="number">0</span>].Have_In_Queue=TRUE;</span><br><span class="line">    InsertToHeap(&amp;Attack_Map[SIZE-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> AttackNode *node;</span><br><span class="line">        node=heap[<span class="number">1</span>];</span><br><span class="line">        attackhistory[node-&gt;p.y][node-&gt;p.x]=<span class="number">1</span>;</span><br><span class="line">        DeleteMin();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(atGoal(node-&gt;p))</span><br><span class="line">        &#123;</span><br><span class="line">            getch();</span><br><span class="line">            <span class="comment">//!@note需要写的函数，向策略队列里填充结点</span></span><br><span class="line">            findAttackQueue(node);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node-&gt;cost);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(canGetByDir(node-&gt;p,NORTH)&amp;&amp;(Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x].Have_In_Queue==FALSE)</span><br><span class="line">        &amp;&amp;(attack_maze-&gt;walkHistory[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x]==<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//!如果北方节点是前驱结点，则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span>((node-&gt;pre!=NULL)&amp;&amp;(node-&gt;pre-&gt;p.y==(node-&gt;p.y-<span class="number">1</span>))&amp;&amp;node-&gt;pre-&gt;p.x==node-&gt;p.x)&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x].pre=node;</span><br><span class="line">                Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x].bend=getBend(&amp;Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">                Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x].cost=getCost(&amp;Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">                </span><br><span class="line">                Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x].Have_In_Queue=TRUE;</span><br><span class="line">                </span><br><span class="line">                InsertToHeap(&amp;Attack_Map[node-&gt;p.y-<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canGetByDir(node-&gt;p,EAST)&amp;&amp;(Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>].Have_In_Queue==FALSE)</span><br><span class="line">        &amp;&amp;(attack_maze-&gt;walkHistory[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>]==<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//!如果东方节点是前驱结点，则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span>((node-&gt;pre!=NULL)&amp;&amp;(node-&gt;pre-&gt;p.y==node-&gt;p.y)&amp;&amp;node-&gt;pre-&gt;p.x==(node-&gt;p.x+<span class="number">1</span>))&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>].pre=node;</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>].bend=getBend(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>]);</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>].cost=getCost(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>].Have_In_Queue=TRUE;</span><br><span class="line">                InsertToHeap(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canGetByDir(node-&gt;p,SOUTH)&amp;&amp;(Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x].Have_In_Queue==FALSE)</span><br><span class="line">        &amp;&amp;(attack_maze-&gt;walkHistory[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x]==<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//!如果南方节点是前驱结点，则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span>((node-&gt;pre!=NULL)&amp;&amp;(node-&gt;pre-&gt;p.y==(node-&gt;p.y+<span class="number">1</span>))&amp;&amp;node-&gt;pre-&gt;p.x==(node-&gt;p.x))&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x].pre=node;</span><br><span class="line">                Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x].bend=getBend(&amp;Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">                Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x].cost=getCost(&amp;Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">                </span><br><span class="line">                Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x].Have_In_Queue=TRUE;</span><br><span class="line">                InsertToHeap(&amp;Attack_Map[node-&gt;p.y+<span class="number">1</span>][node-&gt;p.x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(canGetByDir(node-&gt;p,WEST)&amp;&amp;(Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>].Have_In_Queue==FALSE)</span><br><span class="line">        &amp;&amp;(attack_maze-&gt;walkHistory[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>]==<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//!如果西方节点是前驱结点，则什么都不做</span></span><br><span class="line">            <span class="keyword">if</span>((node-&gt;pre!=NULL)&amp;&amp;(node-&gt;pre-&gt;p.y==(node-&gt;p.y))&amp;&amp;node-&gt;pre-&gt;p.x==(node-&gt;p.x-<span class="number">1</span>))&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>].pre=node;</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>].bend=getBend(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>]);</span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>].cost=getCost(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">                Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>].Have_In_Queue=TRUE;</span><br><span class="line">                InsertToHeap(&amp;Attack_Map[node-&gt;p.y][node-&gt;p.x-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试迷宫的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">16</span>][<span class="number">16</span>] =&#123;</span><br><span class="line">                &#123;<span class="number">11</span>,<span class="number">11</span>,<span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,<span class="number">10</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">2</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">13</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">9</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>,<span class="number">14</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">14</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">11</span>,<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,<span class="number">12</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">3</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                &#123; <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,<span class="number">10</span>, <span class="number">8</span>, <span class="number">2</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">14</span>,<span class="number">14</span>,<span class="number">14</span>,<span class="number">12</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure>
<p>策略层主函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main()&#10;&#123;&#10;    unsigned char NW, EW, SW, WW;&#10;&#10;    //!&#20256;&#20837;&#36855;&#23467;&#21477;&#26564;&#65292;&#21021;&#22987;&#21270;&#22320;&#22270;&#21644;&#36317;&#31163;&#10;    l_Maze_Set(&#38;myMaze);&#10;    initTempMap();&#10;    initDistance();&#10;    &#10;    //!&#21021;&#22987;&#21270;&#30005;&#33041;&#40736;&#20301;&#32622;&#26041;&#21521;&#10;    robot.position.x=0;&#10;    robot.position.y=SIZE-1;&#10;    robot.direction=NORTH;&#10;&#10;    while(!atGoal(robot.position))&#123;&#10;        //!&#36825;&#37324;&#20026;&#35835;&#21462;&#22681;&#22721;&#20449;&#24687;&#30340;&#20195;&#30721;&#65292;&#29992;&#24050;&#30693;&#36855;&#23467;&#20195;&#26367;&#10;        NW = map[robot.position.y][robot.position.x] &#38; NORTH;&#10;        EW = map[robot.position.y][robot.position.x] &#38; EAST;&#10;        SW = map[robot.position.y][robot.position.x] &#38; SOUTH;&#10;        WW = map[robot.position.y][robot.position.x] &#38; WEST;&#10;&#10;        //!&#33719;&#21462;&#19979;&#19968;&#20010;&#26041;&#21521;&#10;        nextDirection = l_HandleRequest(robot, NW, EW, SW, WW);&#10;        walk();  &#10;    &#125;&#10;&#10;    toCenter=FALSE;&#10;    initDistance2();&#10;    while(!atStart(robot.position))&#123;&#10;        //!&#36825;&#37324;&#20026;&#35835;&#21462;&#22681;&#22721;&#20449;&#24687;&#30340;&#20195;&#30721;&#65292;&#29992;&#24050;&#30693;&#36855;&#23467;&#20195;&#26367;&#10;        NW = map[robot.position.y][robot.position.x] &#38; NORTH;&#10;        EW = map[robot.position.y][robot.position.x] &#38; EAST;&#10;        SW = map[robot.position.y][robot.position.x] &#38; SOUTH;&#10;        WW = map[robot.position.y][robot.position.x] &#38; WEST;&#10;        &#10;        nextDirection = l_HandleRequest(robot, NW, EW, SW, WW);&#10;        walk();&#10;    &#125;&#10;    &#10;    Attack_Maze_Set(&#38;myMaze);&#10;    Attack_Initialize();&#10;    Attack_Main();&#10;&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上完成了策略层的所有内容。</p>
<h2 id="后记">后记</h2><p>调试时间短，太专注于原创，没有经验。种种原因导致最终没有取得理想的成绩。但是整个过程让我学到了很多东西。压力下的工作，找到在团队里的角色，还有那些调了好多遍的算法，思想很简单，真的写出来一遍也能学到很多东西。</p>
<p>这是我们的一点视频记录，很幼稚，哈哈。</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XOTEzNjg2NTE2" frameborder="0" allowfullscreen></iframe>


<p>最后，当然还是一起工作过的这帮朋友，我们来自五湖四海，各个专业，各个年级，如今也各奔东西。只是在那时相遇过，一起努力过，也是一种缘分吧。</p>
<p>我们的合影,拍摄于天津工业大学，2012.4.22<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1eq8zwnp9wij20x20m8ae9.jpg" alt="Alt text"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>电脑鼠项目是本科的时候参加的项目了，如今拿出来回一下，复习一下原来学习的C和相关的算法，看到当年青涩的我们，也是别有一番滋味。</p>
<h2 id="IEEE电脑鼠介绍">IEEE电脑鼠介绍</h2><p>IEEE国际电脑鼠走迷宫邀请]]>
    </summary>
    
      <category term="杂七杂八" scheme="http://rudy-zhang.me/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CodeIgniter笔记]]></title>
    <link href="http://rudy-zhang.me/2014/10/28/CodeIgniter%E7%AC%94%E8%AE%B0/"/>
    <id>http://rudy-zhang.me/2014/10/28/CodeIgniter笔记/</id>
    <published>2014-10-27T16:00:00.000Z</published>
    <updated>2015-05-24T07:34:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="CodeIgniter">CodeIgniter</h3><blockquote>
<p>CodeIgniter 是一个简单快速的PHP MVC框架。<br>CodeIgniter 是一套给 PHP 网站开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 CodeIgniter可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。</p>
</blockquote>
<p>简单快速，这也是选择CI的原因。</p>
<p>以下内容细节可以从CI<a href="http://codeigniter.org.cn/user_guide/index.html" target="_blank" rel="external">官方文档</a>寻找</p>
<h3 id="超级对象this">超级对象this</h3><p>当前的控制器对象，this，提供了很多属性<br>加载方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;load-&#62;</span><br></pre></td></tr></table></figure>
<p>装载器类的实例system/core/Loader.php<br>提供的方法：</p>
<ul>
<li>view()     装载视图</li>
<li>vars()     分配变量到视图 </li>
<li>database() 装载数据库操作</li>
<li>model()   装载模型对象</li>
<li>helper() <h3 id="var_dump">var_dump</h3></li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void var_dump ( mixed <span class="variable">$expression</span> [, mixed $... ] )</span><br></pre></td></tr></table></figure>
<p>此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p>
<h3 id="$this-&gt;input_输入类">$this-&gt;input 输入类</h3><p>作用：默认帮助进行安全处理<br>CI_Input类 system/cor/Input.php<br><code>$this-&gt;input-&gt;server(&#39;DOCUMENT_ROOT&#39;)</code>相当于<code>$_POST[&#39;DOCUMENT_ROOT&#39;]</code><br><code>$this-&gt;input-&gt;post(&#39;表单提交的name&#39;)</code></p>
<h3 id="URL相关函数">URL相关函数</h3><ul>
<li>site_url<br>在form表单中提交action不能把路径写死,使用<code>site_url (controller/action)</code></li>
<li>base_url 根目录<br>请求图片时，<code>&lt;img src=&quot;&lt;?php echo base_url()?&gt;uploads/jh.jpg&quot;&gt;</code></li>
<li>自动加载URL函数，autoload.php<br>$autoload[‘helper’] = array(‘url’);</li>
</ul>
<h3 id="路由">路由</h3><p><code>config/routes.php</code><br>默认的控制器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route[&#39;default_controller&#39;]=</span><br></pre></td></tr></table></figure>
<p>伪静态页面,不再显示<code>xxx.php</code>,在路由中写一个正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route[&#39;show/([\d]+)\.html&#39;]=&#39;article/show/&#39;</span><br></pre></td></tr></table></figure>
<h3 id="分页">分页</h3><p>使用分页类<code>pagination</code></p>
<h4 id="加载类文件">加载类文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;load-&#62;library(&#39;pagnination&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="配置">配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$config[&#39;per_page&#39;]=10;//&#27599;&#39029;&#26174;&#31034;10&#26465;&#25968;&#25454;</span><br></pre></td></tr></table></figure>
<p>其他配置见<a href="http://codeigniter.org.cn/user_guide/libraries/pagination.html" target="_blank" rel="external">文档</a></p>
<h4 id="初始化">初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;pagination-&#62;initialize($config)</span><br></pre></td></tr></table></figure>
<h4 id="创建链接">创建链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;pagination-&#62;create_links($config)</span><br></pre></td></tr></table></figure>
<h4 id="跳过多少条">跳过多少条</h4><p> sql语句 <code>select from limit+跳过的条数</code></p>
<h4 id="定制分页器">定制分页器</h4><p>$config[‘first_link’]=”首页”<br> 其他配置见<a href="http://codeigniter.org.cn/user_guide/libraries/pagination.html" target="_blank" rel="external">文档</a></p>
<h3 id="文件上传">文件上传</h3><p>表单<br><code>&lt;form enctype=&quot;multipart/form-data&quot;&gt;&lt;/form&gt;</code></p>
<h4 id="使用文件上传类">使用文件上传类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;load-&#62;library(&#39;&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="配置-1">配置</h4><p>见<a href="http://codeigniter.org.cn/user_guide/libraries/pagination.html" target="_blank" rel="external">文档</a></p>
<h4 id="上传">上传</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;upload-&#62;do_upload(&#39;pic&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="返回信息">返回信息</h4><p>文件上传的一些数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$his-&#62;upload-&#62;data()</span><br></pre></td></tr></table></figure>
<h3 id="session">session</h3><p>CI中的session 默认不使用php的原生session，<strong>放在cookie中</strong>（限制大小4k），不太好使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;session-&#62;set_userdata(&#39;user&#39;,$user) ; //&#20351;&#29992;&#38190;&#20540;&#23545;&#26469;&#23384;&#20648;&#25968;&#25454;</span><br></pre></td></tr></table></figure>
<p><strong>因为是存储在cookie中的，所以不能在当前的函数中获取到session中的数据，需要跳转的别的页面后才可以获取的到</strong></p>
<h4 id="加密">加密</h4><p>生成随机不重复的字符串作为加密用的key，保存到config.php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$[&#39;encryption_key&#39;]=&#34;key&#30340;&#20540;&#34;</span><br></pre></td></tr></table></figure>
<p>或者不使用CI的session，囧。。。</p>
<h3 id="表单验证">表单验证</h3><h4 id="使用表单验证类">使用表单验证类</h4><p>$this-&gt;load-&gt;library(‘form_validation’);</p>
<h4 id="验证">验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&#62;form_validation-&#62;set_rules(&#39;&#39;,&#39;&#39;,&#39;&#39;);&#10;$bool=$this-&#62;form_validation-&#62;run();</span><br></pre></td></tr></table></figure>
<p>前台验证使用js，后台验证使用表单验证类</p>
<h4 id="输出错误">输出错误</h4><p><code>form_error(&#39;name&#39;,&#39;&lt;span&gt;&#39;,&#39;&lt;/span&gt;&#39;)</code><br><code>echo validation_error()</code>直接输出所有结果（推荐使用）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="CodeIgniter">CodeIgniter</h3><blockquote>
<p>CodeIgniter 是一个简单快速的PHP MVC框架。<br>CodeIgniter 是一套给 PHP 网站开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库]]>
    </summary>
    
      <category term="CodeIgniter" scheme="http://rudy-zhang.me/tags/CodeIgniter/"/>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>