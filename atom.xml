<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Rudy's Blog]]></title>
  <subtitle><![CDATA[seize the day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://rudy-zhang.me/"/>
  <updated>2015-10-10T10:50:18.341Z</updated>
  <id>http://rudy-zhang.me/</id>
  
  <author>
    <name><![CDATA[Rudy Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[二叉树专题-一般题目]]></title>
    <link href="http://rudy-zhang.me/2015/10/10/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98-%E4%B8%80%E8%88%AC%E9%A2%98%E7%9B%AE/"/>
    <id>http://rudy-zhang.me/2015/10/10/找工作总结-二叉树专题-一般题目/</id>
    <published>2015-10-10T08:15:28.000Z</published>
    <updated>2015-10-10T10:50:18.341Z</updated>
    <content type="html"><![CDATA[<h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span class="keyword">if</span>(root == <span class="type">NULL</span>)
        <span class="keyword">return</span> root;
    <span class="type">TreeNode</span> *<span class="keyword">left</span> = getMirror(root-&gt;<span class="keyword">left</span>);
    <span class="type">TreeNode</span> *<span class="keyword">right</span> = getMirror(root-&gt;<span class="keyword">right</span>);
    root-&gt;<span class="keyword">left</span> = <span class="keyword">right</span>;
    root-&gt;<span class="keyword">right</span> = <span class="keyword">left</span>;
    <span class="keyword">return</span> root;
}
</code></pre><h3 id="判断一棵二叉树是不是另一棵二叉树的子结构">判断一棵二叉树是不是另一棵二叉树的子结构</h3><pre><code>bool judge(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val)
        <span class="keyword">return</span> judge(node1<span class="subst">-&gt;</span>left, node2<span class="subst">-&gt;</span>left) <span class="subst">&amp;&amp;</span>
            judge(node2<span class="subst">-&gt;</span>right, node2<span class="subst">-&gt;</span>right);
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="literal">false</span>;
}
bool hasSubTree(TreeNode <span class="subst">*</span>node1, TreeNode <span class="subst">*</span>node2)
{
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span>(node1 <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node2 <span class="subst">!=</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">==</span> node2<span class="subst">-&gt;</span>val <span class="subst">&amp;&amp;</span> judge(node1, node2))
            <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> hasSubTree(node1<span class="subst">-&gt;</span>left, node2) <span class="subst">||</span>
            hasSubTree(node1<span class="subst">-&gt;</span>right, node2);
}
</code></pre><h3 id="求二叉树中两个节点的最低公共祖先节点">求二叉树中两个节点的最低公共祖先节点</h3><h4 id="如果是二叉查找树">如果是二叉查找树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><ul>
<li>考虑是否需要判断这棵树是不是二叉查找树</li>
<li>考虑这两个节点是否在树中</li>
</ul>
<h4 id="如果是一棵普通的树">如果是一棵普通的树</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    <span class="type">TreeNode</span>* lowestCommonAncestor(<span class="type">TreeNode</span>* root, <span class="type">TreeNode</span>* p, <span class="type">TreeNode</span>* q) {
        <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &lt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &lt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;right, p, q);
        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;<span class="keyword">val</span> &gt; p-&gt;<span class="keyword">val</span> &amp;&amp; root-&gt;<span class="keyword">val</span> &gt; q-&gt;<span class="keyword">val</span>)
            return lowestCommonAncestor(root-&gt;left, p, q);
        <span class="keyword">else</span>
            return root;
    }
};
</code></pre><h3 id="求二叉树中节点最大距离">求二叉树中节点最大距离</h3><p><a href="http://blog.csdn.net/lalor/article/details/7626678" target="_blank" rel="external">问题描述</a></p>
<h4 id="解法">解法</h4><ul>
<li>二叉树为空，最大距离是0</li>
<li>二叉树不为空，最大距离=max:<ul>
<li>左子树中最大距离</li>
<li>右子树中最大距离</li>
<li>左子树到跟的最大距离+1+右子树到根的最大距离</li>
</ul>
</li>
</ul>
<h4 id="代码">代码</h4><pre><code>int GetMaxDistance(BinaryTreeNode * pRoot, int &amp; <span class="keyword">max</span>Left, int &amp; <span class="keyword">max</span>Right)
{
    // <span class="keyword">max</span>Left, 左子树中的节点距离根节点的最远距离
    // <span class="keyword">max</span>Right, 右子树中的节点距离根节点的最远距离
    if(pRoot == NULL)
    {
        <span class="keyword">max</span>Left = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
        return <span class="number">0</span>;
    }
    int <span class="keyword">max</span>LL, <span class="keyword">max</span>LR, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR; //<span class="keyword">max</span>LL 代表左子树中节点距离左子树根节点最大距离
    int <span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight; //左右子树中的最大距离
    if(pRoot-&gt;m_pLeft != NULL)
    {
        <span class="keyword">max</span>DistLeft = GetMaxDistance(pRoot-&gt;m_pLeft, <span class="keyword">max</span>LL, <span class="keyword">max</span>LR);
        <span class="keyword">max</span>Left = <span class="keyword">max</span>(<span class="keyword">max</span>LL, <span class="keyword">max</span>LR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistLeft = <span class="number">0</span>;
        <span class="keyword">max</span>Left = <span class="number">0</span>;
    }
    if(pRoot-&gt;m_pRight != NULL)
    {
        <span class="keyword">max</span>DistRight = GetMaxDistance(pRoot-&gt;m_pRight, <span class="keyword">max</span>RL, <span class="keyword">max</span>RR);
        <span class="keyword">max</span>Right = <span class="keyword">max</span>(<span class="keyword">max</span>RL, <span class="keyword">max</span>RR) + <span class="number">1</span>;
    }
    else
    {
        <span class="keyword">max</span>DistRight = <span class="number">0</span>;
        <span class="keyword">max</span>Right = <span class="number">0</span>;
    }
    return <span class="keyword">max</span>(<span class="keyword">max</span>(<span class="keyword">max</span>DistLeft, <span class="keyword">max</span>DistRight), <span class="keyword">max</span>Left+<span class="keyword">max</span>Right);
}
</code></pre><h3 id="剑指offer25_二叉树中某一路径和为target">剑指offer25 二叉树中某一路径和为target</h3><h4 id="问题描述">问题描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法-1">解法</h4><p>先序递归遍历，使用vector存储路径</p>
<h3 id="#">#</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="built_in">vector</span>&lt;TreeNode *&gt; path;
        Find(root, expectNumber, <span class="number">0</span>, path, <span class="built_in">list</span>);
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode *node, <span class="keyword">int</span> expectNumber, <span class="keyword">int</span> currentSum, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">list</span>)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        currentSum += node-&gt;val;
        path.push_back(node);
        <span class="keyword">if</span>(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL &amp;&amp; currentSum == expectNumber)
        {
            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)
            {
                vec.push_back(path[i]-&gt;val);
            }
            <span class="built_in">list</span>.push_back(vec);
        }
        Find(node-&gt;left,expectNumber,currentSum,path,<span class="built_in">list</span>);
        Find(node-&gt;right,expectNumber,currentSum,path,<span class="built_in">list</span>);
        path.pop_back();
    }
};
</code></pre><h3 id="剑指offer_58_二叉树的下一个节点">剑指offer 58 二叉树的下一个节点</h3><h4 id="问题描述-1">问题描述</h4><p> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解法-2">解法</h4><p>中序遍历的顺序使左中右，假设当前节点为node，讨论下面两种情况：</p>
<ul>
<li>node存在右子树，下一个节点是右节点一直向左遍历的最后一个节点</li>
<li>不存在右子树，node == node-&gt;father-&gt;right,想左回溯，直到node == node-&gt;father-&gt;left </li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        <span class="keyword">if</span>(pNode == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">if</span>(pNode-&gt;right != <span class="keyword">NULL</span>)
        {
            TreeLinkNode* right = pNode-&gt;right;
            TreeLinkNode* node = right;
            <span class="keyword">while</span>(node-&gt;left)
                node = node-&gt;left;
            <span class="keyword">return</span> node;
        }
        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">else</span>
        {
            TreeLinkNode* node = pNode;
            <span class="keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node)
                node = node-&gt;next;
            <span class="keyword">if</span>(node-&gt;next == <span class="keyword">NULL</span>)
                <span class="keyword">return</span> <span class="keyword">NULL</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> node-&gt;next;
        }
    }
};
</code></pre><h3 id="剑指offer_62_序列化二叉树">剑指offer 62 序列化二叉树</h3><h4 id="问题描述-2">问题描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解法-3">解法</h4><p>可以使用任意一种遍历方法</p>
<h4 id="注意点">注意点</h4><ul>
<li>对NULL的处理</li>
<li>使用sprintf函数，把node-&gt;val把整数赋值到字符串上</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">char</span>* Serialize(TreeNode *root) {   
        <span class="keyword">if</span>(root == NULL)
            <span class="keyword">return</span> NULL;
        string <span class="keyword">str</span>;
        serializeR(root, <span class="keyword">str</span>);
        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">str</span>.size()+<span class="number">1</span>];
        strcpy(p, <span class="keyword">str</span>.data());
        <span class="keyword">return</span> p;
    }

    <span class="keyword">void</span> serializeR(TreeNode* node, string&amp; <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(node == NULL)
        {   
            <span class="keyword">str</span> += <span class="string">"#,"</span>;
            <span class="keyword">return</span> ;
        }  
        <span class="keyword">char</span> numStr[<span class="number">15</span>];
        sprintf(numStr, <span class="string">"%d"</span>, node-&gt;val);
        <span class="keyword">str</span> += numStr;
        <span class="keyword">str</span> += <span class="string">','</span>;
        serializeR(node-&gt;left, <span class="keyword">str</span>);
        serializeR(node-&gt;right, <span class="keyword">str</span>);
    }

    TreeNode* Deserialize(<span class="keyword">char</span> *<span class="keyword">str</span>) {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL || *<span class="keyword">str</span> == <span class="string">'\0'</span> || *<span class="keyword">str</span> == <span class="string">'#'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">int</span> num = <span class="number">0</span>;
        <span class="keyword">return</span> deserialR(<span class="keyword">str</span>, num);
    }

    TreeNode* deserialR(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span>&amp; num)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'\0'</span>)
            <span class="keyword">return</span> NULL;
        <span class="keyword">if</span>(<span class="keyword">str</span>[num] == <span class="string">'#'</span>)
        {
            num += <span class="number">2</span>;
            <span class="keyword">return</span> NULL;
        }
        <span class="keyword">int</span> val = <span class="number">0</span>;
        <span class="keyword">while</span>(<span class="keyword">str</span>[num] != <span class="string">','</span> &amp;&amp; <span class="keyword">str</span>[num] != <span class="string">'\0'</span>)
        {
            val = val*<span class="number">10</span> + (<span class="keyword">str</span>[num] - <span class="string">'0'</span>);
            num++;
        }
        num++;
        TreeNode* node = <span class="keyword">new</span> TreeNode(val);
        node-&gt;left = deserialR(<span class="keyword">str</span>, num);
        node-&gt;right = deserialR(<span class="keyword">str</span>, num);
        <span class="keyword">return</span> node;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="求二叉树镜像">求二叉树镜像</h3><pre><code><span class="type">TreeNode</span> *getMirror(<span class="type">TreeNode</span> *root)
{
    <span cl]]>
    </summary>
    
      <category term="二叉树" scheme="http://rudy-zhang.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树专题-二叉查找树]]></title>
    <link href="http://rudy-zhang.me/2015/10/10/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://rudy-zhang.me/2015/10/10/找工作总结-二叉树专题-二叉查找树/</id>
    <published>2015-10-10T07:36:37.000Z</published>
    <updated>2015-10-10T10:50:06.497Z</updated>
    <content type="html"><![CDATA[<h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</p>
</blockquote>
<p>常用思路：二叉查找树的中序遍历是一个有序序列</p>
<h2 id="题目">题目</h2><h3 id="验证一个二叉查找树是否合法">验证一个二叉查找树是否合法</h3><p>中序遍历是有序的<br>使用额外存储：</p>
<pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>{
        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        inorder(root, vec);
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()-<span class="number">1</span>;i++)
        {
            <span class="keyword">if</span>(vec[i]&gt;=vec[i+<span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span>
    </span>{
        <span class="keyword">if</span>(node == NULL)
            <span class="keyword">return</span>;
        inorder(node-&gt;left, vec);
        vec.push_back(node-&gt;val);
        inorder(node-&gt;right, vec);
    }
};
</code></pre><p>直接在中序遍历的过程中判断：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode *prev=<span class="keyword">NULL</span>;
    bool isValidBST(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(!isValidBST(root-&gt;left))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        prev = root;
        <span class="keyword">return</span> isValidBST(root-&gt;right);
    }
};
</code></pre><h3 id="判断一个序列是不是二叉查找树的后序遍历">判断一个序列是不是二叉查找树的后序遍历</h3><pre><code>bool isValidR(vector&lt;<span class="keyword">int</span>&gt; &amp;seq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)
{
    <span class="keyword">if</span>(start &gt;= end)
        <span class="keyword">return</span> true;
    <span class="keyword">int</span> ls,le,rs,re,i;
    ls = start;
    <span class="keyword">for</span>(i=start;i&lt;end &amp;&amp; se<span class="string">q[i]</span>&lt;se<span class="string">q[end]</span>;i++){}
    le = i-<span class="number">1</span>;
    rs = i;
    <span class="keyword">for</span>(;i&lt;end;i++)
    {
        <span class="keyword">if</span>(se<span class="string">q[i]</span>&lt;=se<span class="string">q[end]</span>)
            <span class="keyword">return</span> false;
    }
    re=end-<span class="number">1</span>;
    <span class="keyword">return</span> isValidR(seq, ls, le) &amp;&amp; isValidR(seq, rs, re);
}
bool isValidPostOrderSequence(vector&lt;<span class="keyword">int</span>&gt; seq)
{
    <span class="keyword">if</span>(seq.size() == <span class="number">0</span>)
        <span class="keyword">return</span> false;
    <span class="keyword">if</span>(seq.size() == <span class="number">1</span>)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> isValidR(seq, <span class="number">0</span>, seq.size()-<span class="number">1</span>);
}
</code></pre><h3 id="剑指offer_63_二叉查找树的第K个节点">剑指offer 63 二叉查找树的第K个节点</h3><h4 id="问题描述">问题描述</h4><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h4 id="解法">解法</h4><p>找到中序遍历的第k个元素即可，使用k的引用传递当做全局变量使用</p>
<h4 id="代码">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        <span class="keyword">return</span> KthNodeR(pRoot, k);
    }

    TreeNode* KthNodeR(TreeNode* node, unsigned int&amp; k)
    {
        <span class="keyword">if</span>(node == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* temp = KthNodeR(node-&gt;left, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
        k--;
        <span class="keyword">if</span>(k == <span class="number">0</span>)
            <span class="keyword">return</span> node;
        temp = KthNodeR(node-&gt;right, k);
        <span class="keyword">if</span>(temp)
            <span class="keyword">return</span> temp;
    }
};
</code></pre><h3 id="剑指offer_27_二叉搜索树与双向链表">剑指offer 27 二叉搜索树与双向链表</h3><h4 id="问题描述-1">问题描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解法-1">解法</h4><p>中序遍历，使用lastInList的引用传递，提供已经中序遍历链表的最后一个节点。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;
        TreeNode* lastInList=<span class="keyword">NULL</span>;
        convertCore(pRootOfTree, lastInList);
        TreeNode *head = pRootOfTree;
        <span class="keyword">while</span>(head-&gt;left)
            head=head-&gt;left;
        <span class="keyword">return</span> head;
    }

    void convertCore(TreeNode *root, TreeNode *(&amp;lastInList))
    {
        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
        <span class="keyword">if</span>(root-&gt;left)
            convertCore(root-&gt;left, lastInList);
        root-&gt;left = lastInList;
        <span class="keyword">if</span>(lastInList)
            lastInList-&gt;right=root;
        lastInList = root;
        <span class="keyword">if</span>(root-&gt;right)
            convertCore(root-&gt;right, lastInList);
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="主要思路">主要思路</h2><blockquote>
<p>二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。<br>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树]]>
    </summary>
    
      <category term="二叉树" scheme="http://rudy-zhang.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树专题-基础]]></title>
    <link href="http://rudy-zhang.me/2015/10/10/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80/"/>
    <id>http://rudy-zhang.me/2015/10/10/找工作总结-二叉树专题-基础/</id>
    <published>2015-10-10T01:59:47.000Z</published>
    <updated>2015-10-10T10:50:12.487Z</updated>
    <content type="html"><![CDATA[<h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</span>;
    TreeNode* <span class="built_in">right</span>;
    TreeNode(<span class="built_in">int</span> x):val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>){}
};
</code></pre><h2 id="遍历">遍历</h2><h3 id="递归遍历">递归遍历</h3><pre><code><span class="literal">void</span> preTranverse(TreeNode<span class="subst">*</span> node)
{
    <span class="keyword">if</span>(node <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span>;
    visit(node);
    preTranverse(node<span class="subst">-&gt;</span>left);
    preTranverse(node<span class="subst">-&gt;</span>right);
}
</code></pre><p>以上为先序递归遍历，中序后序只需要修改<code>visit(node)</code>函数的位置即可。</p>
<h3 id="非递归遍历">非递归遍历</h3><p>核心思想是使用栈模拟递归，二叉树可以看成是对多有两个分支的有向图，递归遍历实际上是一种深度优先遍历。实际上是使用栈模拟深度优先遍历。</p>
<h4 id="先序">先序</h4><pre><code>void preOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="中序">中序</h4><pre><code>void inOrder(<span class="constant">Tree</span>Node *<span class="literal">root</span>)
<span class="keyword">{</span>
    <span class="keyword">if</span>(<span class="literal">root</span> == <span class="constant">N</span>ULL)
        return ;
    stack&lt;<span class="constant">Tree</span>Node*&gt; s;
    <span class="constant">Tree</span>Node* <span class="keyword">node</span> = <span class="literal">root</span>;
    while(<span class="keyword">node</span> || !s.empty())
    <span class="keyword">{</span>
        while(<span class="keyword">node</span>)
        <span class="keyword">{</span>
            s.push(<span class="keyword">node</span>);
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;left;
        <span class="keyword">}</span>
        <span class="keyword">if</span>(!s.empty())
        <span class="keyword">{</span>
            <span class="keyword">node</span> = s.top();
            //visit <span class="keyword">node</span>
            cout&lt;&lt;<span class="keyword">node</span>-&gt;val&lt;&lt;<span class="string">" "</span>;
            s.pop();
            <span class="keyword">node</span> = <span class="keyword">node</span>-&gt;right;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
</code></pre><h4 id="后序">后序</h4><pre><code>struct MyNode
{
    TreeNode <span class="subst">*</span>n;
    bool isFirst;
};
<span class="literal">void</span> postOrder(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="built_in">stack</span><span class="subst">&lt;</span>MyNode<span class="subst">*&gt;</span> s;
    TreeNode<span class="subst">*</span> node <span class="subst">=</span> root;
    <span class="keyword">while</span>(node <span class="subst">||</span> <span class="subst">!</span>s<span class="built_in">.</span>empty())
    {
        <span class="keyword">while</span>(node)
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> <span class="literal">new</span> MyNode();
            myNode<span class="subst">-&gt;</span>n <span class="subst">=</span> node;
            myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">true</span>;
            s<span class="built_in">.</span>push(myNode);
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>left;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>s<span class="built_in">.</span>empty())
        {
            MyNode <span class="subst">*</span>myNode <span class="subst">=</span> s<span class="built_in">.</span>top();
            s<span class="built_in">.</span>pop();
            <span class="keyword">if</span>(myNode<span class="subst">-&gt;</span>isFirst)
            {
                myNode<span class="subst">-&gt;</span>isFirst <span class="subst">=</span> <span class="literal">false</span>;
                s<span class="built_in">.</span>push(myNode);
                node <span class="subst">=</span> myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>right;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">//visit node</span>
                cout<span class="subst">&lt;&lt;</span>myNode<span class="subst">-&gt;</span>n<span class="subst">-&gt;</span>val<span class="subst">&lt;&lt;</span><span class="string">" "</span>;
            }
        }
    }
}
</code></pre><h3 id="层序遍历">层序遍历</h3><p>使用队列模拟广度优先遍历。</p>
<pre><code>void levelOrder<span class="params">(TreeNode *root)</span>
{
    <span class="keyword">if</span><span class="params">(root == NULL)</span>
        return;
    queue&lt;TreeNode <span class="built_in">*</span>&gt; q;
    TreeNode <span class="built_in">*</span>node = root;
    q.push<span class="params">(node)</span>;
    while<span class="params">(!q.empty<span class="params">()</span>)</span>
    {
        node = q.front<span class="params">()</span>;
        q.pop<span class="params">()</span>;
        cout&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" "</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;left)</span>
            q.push<span class="params">(node-&gt;left)</span>;
        <span class="keyword">if</span><span class="params">(node-&gt;right)</span>
            q.push<span class="params">(node-&gt;right)</span>;
    }
}
</code></pre><h3 id="层序遍历引申题目">层序遍历引申题目</h3><h4 id="剑指offer_60_把二叉树打印成多行">剑指offer 60 把二叉树打印成多行</h4><p><strong>问题描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p><strong>解法</strong><br>遍历每一层的时候记录本行和下一行的节点个数，当本行个数变为0，开始下一行。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;
            <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
                <span class="keyword">return</span> <span class="literal">result</span>;
            vector&lt;<span class="type">int</span>&gt; line;
            queue&lt;<span class="type">TreeNode</span>*&gt; q;
            q.push(pRoot);
            <span class="type">int</span> thisLine = <span class="number">1</span>;
            <span class="type">int</span> nextLine = <span class="number">0</span>;
            <span class="keyword">while</span>(!q.empty())
            {
                <span class="type">TreeNode</span>* node = q.front();
                line.push_back(node-&gt;val);
                q.pop();
                thisLine--;
                <span class="keyword">if</span>(node-&gt;left)
                {
                    q.push(node-&gt;left);
                    nextLine++;
                }
                <span class="keyword">if</span>(node-&gt;right)
                {
                    q.push(node-&gt;right);
                    nextLine++;
                }
                <span class="keyword">if</span>(thisLine == <span class="number">0</span>)
                {
                    <span class="literal">result</span>.push_back(line);
                    line.clear();
                    thisLine = nextLine;
                    nextLine = <span class="number">0</span>;
                }
            }
            <span class="keyword">return</span> <span class="literal">result</span>;
        }
};
</code></pre><h4 id="剑指offer_61_按之字形打印二叉树">剑指offer 61 按之字形打印二叉树</h4><p><strong>问题描述</strong><br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解法</strong><br>使用两个栈stack[2]，从0行开始，对于偶数行，从左向右打印，对于奇数行，从右向左打印。</p>
<p><strong>代码</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="type">Print</span>(<span class="type">TreeNode</span>* pRoot) {
        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(pRoot == <span class="type">NULL</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> line = <span class="number">0</span>;
        vector&lt;<span class="type">int</span>&gt; vec;
        stack&lt;<span class="type">TreeNode</span>* &gt; stacks[<span class="number">2</span>];
        stacks[<span class="number">0</span>].push(pRoot);
        <span class="keyword">while</span>(!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())
        {
            <span class="type">TreeNode</span>* node = stacks[line%<span class="number">2</span>].top();
            stacks[line%<span class="number">2</span>].pop();
            vec.push_back(node-&gt;val);
            <span class="keyword">if</span>(line%<span class="number">2</span> == <span class="number">0</span>){
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);          
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(node-&gt;right)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;right);          
                <span class="keyword">if</span>(node-&gt;left)
                    stacks[(line+<span class="number">1</span>)%<span class="number">2</span>].push(node-&gt;left);
            }
            <span class="keyword">if</span>(stacks[line%<span class="number">2</span>].empty())
            {
                <span class="literal">result</span>.push_back(vec);
                vec.clear();
                line++;
            }
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h2 id="二叉树节点个数">二叉树节点个数</h2><h3 id="二叉树中节点个数">二叉树中节点个数</h3><pre><code><span class="built_in">int</span> getNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="number">1</span>+<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树中叶子节点个数">二叉树中叶子节点个数</h3><pre><code><span class="built_in">int</span> getLeafNodeNum(TreeNode *root)
{
    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>==<span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span>==<span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span>=getLeafNodeNum(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span>=getLeafNodeNum(root-&gt;<span class="built_in">right</span>);
    return (<span class="built_in">left</span>+<span class="built_in">right</span>);
}
</code></pre><h3 id="二叉树第k层节点个数">二叉树第k层节点个数</h3><pre><code><span class="built_in">int</span> getNumOfKLevel(TreeNode *root, <span class="built_in">int</span> k)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(k==<span class="number">1</span>)
        return <span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = getNumOfKLevel(root-&gt;<span class="built_in">left</span>,k-<span class="number">1</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = getNumOfKLevel(root-&gt;<span class="built_in">right</span>,k-<span class="number">1</span>);
    return (<span class="built_in">left</span> + <span class="built_in">right</span>);
}
</code></pre><h2 id="二叉树深度">二叉树深度</h2><h3 id="最大深度">最大深度</h3><pre><code><span class="built_in">int</span> getDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &gt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h3 id="多次使用深度，使用map记录二叉树深度，防止重复递归遍历">多次使用深度，使用map记录二叉树深度，防止重复递归遍历</h3><pre><code>int getDepth(<span class="type">TreeNode</span>* node, <span class="built_in">map</span>&lt;<span class="type">TreeNode</span>*, int&gt; &amp;dict)
{
    <span class="keyword">if</span>(node == <span class="type">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(node) != <span class="number">0</span>)
        <span class="keyword">return</span> dict[node];
    int <span class="keyword">left</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">left</span>, dict);
    int <span class="keyword">right</span> = <span class="number">1</span> + getDepth(node-&gt;<span class="keyword">right</span>, dict);
    dict[node] = (<span class="keyword">left</span> &gt;= <span class="keyword">right</span> ? <span class="keyword">left</span> : <span class="keyword">right</span>);
    <span class="keyword">return</span> dict[node];
}
</code></pre><h3 id="最小深度">最小深度</h3><pre><code><span class="built_in">int</span> getMinDepth(TreeNode* root)
{
    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
        return <span class="number">0</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span>;
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> != <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; root-&gt;<span class="built_in">right</span> == <span class="literal">NULL</span>)
        return <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">left</span>);
    <span class="built_in">int</span> <span class="built_in">right</span> = <span class="number">1</span> + getMinDepth(root-&gt;<span class="built_in">right</span>);
    return <span class="built_in">left</span> &lt;= <span class="built_in">right</span> ? <span class="built_in">left</span> : <span class="built_in">right</span>;
}
</code></pre><h2 id="判断">判断</h2><h3 id="判断一棵二叉树是不是平衡二叉树">判断一棵二叉树是不是平衡二叉树</h3><p>平衡二叉树：左右子树的高度差不超过1并且左右子树都是平衡二叉树</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(TreeNode* node, <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp; dict)</span>
</span>{
    <span class="keyword">if</span>(node == NULL)
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="keyword">int</span> left = getDepth(node-&gt;left, dict);
    <span class="keyword">int</span> right = getDepth(node-&gt;right, dict);
    <span class="keyword">return</span> (<span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; 
        isBalancedCore(node-&gt;left, dict) &amp;&amp; 
        isBalancedCore(node-&gt;right, dict));
}

<span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span>
</span>{
    <span class="built_in">map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; dict;
    <span class="keyword">return</span> isBalancedCore(root, dict);
}
</code></pre><h3 id="判断一棵二叉树是不是完全二叉树">判断一棵二叉树是不是完全二叉树</h3><p>层次遍历，使用队列，若遇到一个节点子树为空，则后面的都为空。</p>
<pre><code>bool isCompleteTree(TreeNode <span class="subst">*</span>root)
{
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> <span class="literal">true</span>;
    TreeNode <span class="subst">*</span>node <span class="subst">=</span> root;
    <span class="built_in">queue</span><span class="subst">&lt;</span>TreeNode <span class="subst">*&gt;</span> q;
    q<span class="built_in">.</span>push(node);
    bool isNULL <span class="subst">=</span> <span class="literal">false</span>;
    <span class="keyword">while</span>(<span class="subst">!</span>q<span class="built_in">.</span>empty())
    {
        node <span class="subst">=</span> q<span class="built_in">.</span>front();
        q<span class="built_in">.</span>pop();
        <span class="keyword">if</span>(isNULL <span class="subst">==</span> <span class="literal">false</span>){
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right)
            {
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>right);
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>right <span class="subst">==</span> <span class="built_in">NULL</span>)
            {
                isNULL <span class="subst">=</span> <span class="literal">true</span>;
                q<span class="built_in">.</span>push(node<span class="subst">-&gt;</span>left);
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">if</span>(node<span class="subst">-&gt;</span>left <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">||</span> node<span class="subst">-&gt;</span>right <span class="subst">!=</span> <span class="built_in">NULL</span>)
                <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h3 id="判断两颗二叉树是不是同一棵树">判断两颗二叉树是不是同一棵树</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        <span class="keyword">if</span>( p == <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p != <span class="keyword">NULL</span> &amp;&amp; q == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">NULL</span> &amp;&amp; q != <span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">return</span> (p-&gt;val == q-&gt;val) &amp;&amp;
                isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;
                isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre><h3 id="判断一棵二叉树是不是对称的">判断一棵二叉树是不是对称的</h3><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool isSymmetric(TreeNode* root) {
        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return sym(root-&gt;<span class="built_in">left</span>, root-&gt;<span class="built_in">right</span>);
    }

    bool sym(TreeNode *<span class="built_in">left</span>, TreeNode *<span class="built_in">right</span>)
    {
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">true</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> == <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        <span class="keyword">if</span>(<span class="built_in">left</span> == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)
            return <span class="literal">false</span>;
        return <span class="built_in">left</span>-&gt;val == <span class="built_in">right</span>-&gt;val &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">left</span>, <span class="built_in">right</span>-&gt;<span class="built_in">right</span>) &amp;&amp;
            sym(<span class="built_in">left</span>-&gt;<span class="built_in">right</span>, <span class="built_in">right</span>-&gt;<span class="built_in">left</span>);
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="节点声明">节点声明</h2><pre><code>struct TreeNode
{
    <span class="built_in">int</span> val;
    TreeNode* <span class="built_in">left</sp]]>
    </summary>
    
      <category term="二叉树" scheme="http://rudy-zhang.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表专题]]></title>
    <link href="http://rudy-zhang.me/2015/10/04/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <id>http://rudy-zhang.me/2015/10/04/找工作总结-链表专题/</id>
    <published>2015-10-04T13:56:00.000Z</published>
    <updated>2015-10-10T11:00:42.162Z</updated>
    <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="keyword">next</span>;
    ListNode(<span class="keyword">int</span> x):val(x),<span class="keyword">next</span>(<span class="keyword">NULL</span>){}
};
</code></pre><h3 id="求链表中节点个数">求链表中节点个数</h3><pre><code><span class="keyword">int</span> getLength(ListNode* head)
{
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">while</span>(head)
    {
        head = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">count</span>++;
    }
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><h3 id="单链表翻转">单链表翻转</h3><pre><code><span class="constant">ListNode*</span> reverseList(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> newHead = <span class="constant">NULL;</span>
    <span class="constant">ListNode*</span> node = head;
    <span class="keyword">while</span>(node)
    {
        <span class="constant">ListNode*</span> temp = node-&gt;<span class="keyword">next</span>;
        node-&gt;<span class="keyword">next</span> = newHead;
        newHead = node;
        node = temp-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中倒数第k个节点">查找链表中倒数第k个节点</h3><pre><code>ListNode* getLastK(ListNode* head, <span class="built_in">int</span> k)
{
    ListNode* fisrt = head;
    ListNode* <span class="built_in">second</span> = head;
    <span class="keyword">while</span>(k--)
    {
        <span class="keyword">if</span>(first)
            first = first-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            return <span class="literal">NULL</span>;
    }
    <span class="keyword">while</span>(first)
    {
        fisrt = first-&gt;<span class="keyword">next</span>;
        <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>;
    }
    return <span class="built_in">second</span>;
}
</code></pre><h3 id="删除链表中第k个节点">删除链表中第k个节点</h3><pre><code>ListNode* deleteK(ListNode* head, <span class="keyword">int</span> k)
{
    <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)
        <span class="keyword">return</span> head;
    ListNode* toBeDelete;
    ListNode* newHead;
    <span class="keyword">if</span>(k == <span class="number">1</span>)
    {
        toBeDelete = head;
        newHead = head-&gt;<span class="keyword">next</span>;
        <span class="keyword">delete</span> toBeDelete;
        <span class="keyword">return</span> newHead;
    }
    newHead = head;
    ListNode* node = head;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">2</span>; i++)
    {
        <span class="keyword">if</span>(node)
            node = node-&gt;<span class="keyword">next</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> newHead;
    }
    <span class="keyword">if</span>(node == <span class="keyword">NULL</span> || node-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)
        <span class="keyword">return</span> newHead;
    toBeDelete = node-&gt;<span class="keyword">next</span>;
    node-&gt;<span class="keyword">next</span> = node-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    <span class="keyword">delete</span> toBeDelete;
    <span class="keyword">return</span> newHead;
}
</code></pre><h3 id="查找链表中间节点">查找链表中间节点</h3><pre><code><span class="constant">ListNode*</span> findMiddle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode*</span> first = head;
    <span class="constant">ListNode*</span> second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = fisrt-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        if(first)
            second = second-&gt;<span class="keyword">next</span>;
    }
    <span class="keyword">return</span> second;
}
</code></pre><h3 id="从尾到头打印链表">从尾到头打印链表</h3><pre><code>void reversePrint(<span class="type">ListNode</span>* head)
{
    <span class="type">ListNode</span>* node = head;
    stack&lt;<span class="type">ListNode</span>*&gt; s;
    <span class="keyword">while</span>(node)
    {
        s.push(node);
        node = node-&gt;next;
    }
    <span class="keyword">while</span>(!s.empty<span class="literal">()</span>)
    {
        cout&lt;&lt;s.top<span class="literal">()</span>-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">" "</span>;
        s.pop<span class="literal">()</span>;
    }
}
</code></pre><h3 id="单链表排序，选择排序">单链表排序，选择排序</h3><pre><code>void sortList(<span class="type">ListNode</span>* head)
{
    <span class="keyword">for</span>(<span class="type">ListNode</span>* p = head; p != <span class="type">NULL</span>; p = p-&gt;next)
    {
        <span class="type">ListNode</span>* min = p;
        <span class="keyword">for</span>(<span class="type">ListNode</span>* q = p-&gt;next; q != <span class="type">NULL</span>; q = q-&gt;next)
        {
            <span class="keyword">if</span>(q-&gt;<span class="keyword">val</span> &lt; min-&gt;<span class="keyword">val</span>)
                min = q;
        }
        <span class="built_in">int</span> temp = p-&gt;<span class="keyword">val</span>;
        p-&gt;<span class="keyword">val</span> = min-&gt;<span class="keyword">val</span>;
        min-&gt;<span class="keyword">val</span> = temp;
    }
}
</code></pre><h3 id="合并两个有序链表">合并两个有序链表</h3><pre><code>ListNode<span class="subst">*</span> mergeList(ListNode<span class="subst">*</span> list1, ListNode<span class="subst">*</span> list2)
{
    <span class="keyword">if</span>(list1 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list2;
    <span class="keyword">if</span>(list2 <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> list1;
    ListNode<span class="subst">*</span> head <span class="subst">=</span> <span class="built_in">NULL</span>;
    ListNode <span class="subst">*</span>node1 <span class="subst">=</span> list1, <span class="subst">*</span>node2 <span class="subst">=</span> list2;
    ListNode <span class="subst">*</span>tnode <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
    {
        head <span class="subst">=</span> node1;
        node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
    }
    <span class="keyword">else</span>
    {
        head <span class="subst">=</span> node2;
        node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
    }
    tnode <span class="subst">=</span> head;
    tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
    <span class="keyword">while</span>(node1 <span class="subst">&amp;&amp;</span> node2)
    {
        <span class="keyword">if</span>(node1<span class="subst">-&gt;</span>val <span class="subst">&lt;=</span> node2<span class="subst">-&gt;</span>val)
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
            node1 <span class="subst">=</span> node1<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
        <span class="keyword">else</span>
        {
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
            node2 <span class="subst">=</span> node2<span class="subst">-&gt;</span>next;
            tnode <span class="subst">=</span> tnode<span class="subst">-&gt;</span>next;
            tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        }
    }
    <span class="keyword">if</span>(node1)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node1;
    <span class="keyword">if</span>(node2)
        tnode<span class="subst">-&gt;</span>next <span class="subst">=</span> node2;
    <span class="keyword">return</span> head;
}
</code></pre><h3 id="判断一个链表是否有环">判断一个链表是否有环</h3><pre><code>bool hasCircle(<span class="constant">ListNode*</span> head)
{
    <span class="constant">ListNode </span>*first = head, *second = head;
    <span class="keyword">while</span>(first &amp;&amp; first-&gt;<span class="keyword">next</span>)
    {
        first = first-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
        second = second-&gt;<span class="keyword">next</span>;
        if(first == second)
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="判断两个链表是否相交">判断两个链表是否相交</h3><pre><code>bool isJoin(<span class="constant">ListNode </span>*list1, <span class="constant">ListNode </span>*list2)
{
    if(list1 == <span class="constant">NULL </span>|| list2 == <span class="constant">NULL)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="constant">ListNode </span>*n1 = list1, *n2 = list2;
    <span class="keyword">while</span>(n1-&gt;<span class="keyword">next</span>)
        n1 = n1-&gt;<span class="keyword">next</span>;
    <span class="keyword">while</span>(n2-&gt;<span class="keyword">next</span>)
        n2 = n2-&gt;<span class="keyword">next</span>;
    <span class="keyword">return</span> (n1 == n2);
}
</code></pre><h3 id="判断两个链表相交的第一个节点">判断两个链表相交的第一个节点</h3><ol>
<li>判断两个链表是否相交，得到两个链表长度len1,len2</li>
<li>假设len1 &gt; len2，n1先走(len1-len2)步</li>
<li>n1,n2一起走，直到n1 == n2</li>
</ol>
<h3 id="如果一个链表有环，求进入环中的第一个节点">如果一个链表有环，求进入环中的第一个节点</h3><ol>
<li>使用上面的方法判断是否有环</li>
<li>在环中走一圈得到环的长度len</li>
<li>前后两个节点一个先走len步（走一个环的长度），两个一起走相遇在环的入口</li>
</ol>
<h3 id="在O(1)的时间内删除节点">在O(1)的时间内删除节点</h3><pre><code><span class="literal">void</span> deleteInO1(ListNode<span class="subst">*</span> <span class="built_in">list</span>, ListNode<span class="subst">*</span> toBeDelete)
{
    <span class="keyword">if</span>(<span class="built_in">list</span> <span class="subst">==</span> <span class="built_in">NULL</span> <span class="subst">||</span> toBeDelete <span class="subst">==</span> <span class="built_in">NULL</span>)
        <span class="keyword">return</span> ;
    <span class="keyword">if</span>(toBeDelete <span class="subst">==</span> <span class="built_in">list</span>)
    {
        <span class="built_in">list</span> <span class="subst">=</span> <span class="built_in">list</span><span class="subst">-&gt;</span>next;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    <span class="keyword">if</span>(toBeDelete<span class="subst">-&gt;</span>next <span class="subst">==</span> <span class="built_in">NULL</span>)
    {
        ListNode<span class="subst">*</span> node <span class="subst">=</span> <span class="built_in">list</span>;
        <span class="keyword">while</span>(node <span class="subst">&amp;&amp;</span> node<span class="subst">-&gt;</span>next <span class="subst">!=</span> toBeDelete)
            node <span class="subst">=</span> node<span class="subst">-&gt;</span>next;
        node<span class="subst">-&gt;</span>next <span class="subst">=</span> <span class="built_in">NULL</span>;
        delete toBeDelete;
        <span class="keyword">return</span> ;
    }
    ListNode<span class="subst">*</span> temp <span class="subst">=</span> toBeDelete<span class="subst">-&gt;</span>next;
    toBeDelete<span class="subst">-&gt;</span>val <span class="subst">=</span> temp<span class="subst">-&gt;</span>val;
    toBeDelete<span class="subst">-&gt;</span>next <span class="subst">=</span> temp<span class="subst">-&gt;</span>next;
    delete temp;
    <span class="keyword">return</span> ;
}
</code></pre><h2 id="特殊题目">特殊题目</h2><h3 id="剑指offer57_删除链表中的重复节点">剑指offer57 删除链表中的重复节点</h3><h4 id="问题描述">问题描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法">解法</h4><p>使用preNode和node指向最后一个未删除的节点和第一个可能删除的节点</p>
<ul>
<li>如果保留重复元素的第一个<br>只需要使用node扫描一次，判断和preNode-&gt;val是否相等，分两种情况处理即可</li>
<li>如果不保留重复元素<br>需要确定新的头元素newHead,需要判断是否重复，因为需要全部删除。</li>
</ul>
<h4 id="类型1的代码">类型1的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode *deleteDuplicates(ListNode *head) {
        <span class="keyword">if</span>(<span class="keyword">NULL</span> == head || <span class="keyword">NULL</span>==head-&gt;next)
            <span class="keyword">return</span> head;
        ListNode *preNode = head;
        ListNode *node = preNode-&gt;next;
        <span class="keyword">while</span>(node)
        {
            <span class="keyword">if</span>(node-&gt;val == preNode-&gt;val)
            {
                ListNode* temp = node;
                node = node-&gt;next;
                preNode-&gt;next = node;
                delete temp;
            }
            <span class="keyword">else</span>
            {
                node = node-&gt;next;
                preNode = preNode-&gt;next;
            }
        }
        <span class="keyword">return</span> head;
    }
};
</code></pre><h4 id="类型2的代码">类型2的代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;next == <span class="keyword">NULL</span>)
            <span class="keyword">return</span> head;
        ListNode *node = head;
        ListNode *newHead = <span class="keyword">NULL</span>;
        ListNode *preNode = <span class="keyword">NULL</span>;
        <span class="keyword">while</span>(node)
        {
            bool isDuplicated = <span class="keyword">false</span>;
            <span class="keyword">if</span>(node-&gt;next &amp;&amp; node-&gt;val == node-&gt;next-&gt;val)
                isDuplicated = <span class="keyword">true</span>;
            <span class="keyword">if</span>(isDuplicated)
            {
                int val = node-&gt;val;
                <span class="keyword">while</span>(node!= <span class="keyword">NULL</span> &amp;&amp; node-&gt;val == val)
                {
                    ListNode *temp = node;
                    node = node-&gt;next;
                    delete temp;
                }
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(!newHead)
                {
                    newHead = node;
                    preNode = node;
                }
                <span class="keyword">else</span>
                {
                    preNode-&gt;next = node;
                    preNode = preNode-&gt;next;
                }
                node = node-&gt;next;
            }
        }
        <span class="keyword">if</span>(preNode)
            preNode-&gt;next = <span class="keyword">NULL</span>;
        <span class="keyword">return</span> newHead;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基础">基础</h2><h3 id="链表声明">链表声明</h3><pre><code>struct ListNode
{
    <span class="keyword">int</span> val;
    ListNode* <span class="]]>
    </summary>
    
      <category term="链表" scheme="http://rudy-zhang.me/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[栈和队列专题]]></title>
    <link href="http://rudy-zhang.me/2015/10/03/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>http://rudy-zhang.me/2015/10/03/找工作总结-栈和队列专题/</id>
    <published>2015-10-03T13:56:00.000Z</published>
    <updated>2015-10-10T11:00:18.752Z</updated>
    <content type="html"><![CDATA[<h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法">解法</h4><p>两个栈stack1,stack2。完成push和pop函数即可。</p>
<ul>
<li>push的时候向stack1压栈。</li>
<li>pop的时候<br>(1)stack2不为空，弹出stack2.top<br>(2)stack1不为空，把stack1中的元素全部弹出到stack2，然后弹出stack2.top<br>(3)如果stack1和stack2都是空，那么抛出异常<h4 id="注意点">注意点</h4></li>
<li>模板的写法</li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">template</span>&lt;typename T&gt;
class <span class="type">MyQueue</span>
{
public:
    <span class="type">void</span> push(<span class="keyword">const</span> T&amp; item);
    T pop();
private:
    stack&lt;T&gt; stack1;
    stack&lt;T&gt; stack2;
};

<span class="keyword">template</span>&lt;typename T&gt;
<span class="type">void</span> <span class="type">MyQueue</span>::push(<span class="keyword">const</span> T&amp; item)
{
    stack1.push(item);
}

<span class="keyword">template</span>&lt;typename T&gt;
T <span class="type">MyQueue</span>::pop()
{
    <span class="keyword">if</span>(!stack2.empty())
    {
        T temp = stack2.top();//?是否需要引用
        stack2.pop();
        <span class="keyword">return</span> temp;
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(!stack1.empty())
    {
        <span class="keyword">while</span>(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }
    <span class="keyword">else</span>
        throw exception(<span class="string">"MyQueue is empty!"</span>);
}
</code></pre><h4 id="扩展问题，使用两个队列实现栈">扩展问题，使用两个队列实现栈</h4><p>有queue1，queue2两个队列，完成push,pop。</p>
<ul>
<li>push<br>如果queue1.empty &amp;&amp; queue.empty 向queue1中push<br>如果有一个不为空，向不为空的队列里push</li>
<li>pop<br>如果queue1.empty &amp;&amp; queue.empty 抛出异常<br>把不为空的队列出队到空队列，直到剩下一个元素，弹出这个元素</li>
</ul>
<h3 id="剑指offer21_包含min函数的栈">剑指offer21 包含min函数的栈</h3><h4 id="问题描述-1">问题描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解法-1">解法</h4><p>使用stack1,stack2两个栈，stack1压入原本的元素，stack2只压最小元素</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">int</span> tempMin;
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            tempMin = <span class="keyword">value</span>;
        <span class="keyword">else</span>
        {
            tempMin = s2.top();
            <span class="keyword">if</span>(<span class="keyword">value</span> &lt; tempMin)
                tempMin = <span class="keyword">value</span>;
        }
        s1.push(<span class="keyword">value</span>);
        s2.push(tempMin);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">pop</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span>;
        s1.pop();
        s2.pop();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">top</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s1.top();
    }
    <span class="function"><span class="keyword">int</span> <span class="title">min</span>(<span class="params"></span>) </span>{
        <span class="keyword">if</span>(s1.size() == <span class="number">0</span>)
            <span class="keyword">return</span> INT_MIN;
        <span class="keyword">return</span> s2.top();
    }
<span class="keyword">private</span>:
    stack&lt;<span class="keyword">int</span>&gt; s1;
    stack&lt;<span class="keyword">int</span>&gt; s2;
};
</code></pre><h3 id="剑指offer22_栈的压入弹出序列">剑指offer22 栈的压入弹出序列</h3><h4 id="问题描述-2">问题描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h4 id="解法-2">解法</h4><p>使用一个栈stack进行模拟，遍历数组元素：</p>
<ul>
<li>如果<code>vec[i] != stack.top</code>，压入</li>
<li>如果<code>vec[i] == stack.top</code>，弹出</li>
<li><code>i == vec.size</code>时，判断栈是否为空</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code>class Solution {
public:
    bool IsPopOrder<span class="params">(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)</span> {
        <span class="keyword">if</span><span class="params">(pushV.size<span class="params">()</span> != popV.size<span class="params">()</span>)</span>
            return <span class="literal">false</span>;
        stack&lt;int&gt; s;
        int i=<span class="number">0</span>,j=<span class="number">0</span>;
        <span class="keyword">for</span><span class="params">(;j &lt; popV.size<span class="params">()</span>; j++)</span>
        {
            while<span class="params">(s.empty<span class="params">()</span> || <span class="params">(i &lt; pushV.size<span class="params">()</span> &amp;&amp; s.top<span class="params">()</span> != popV[j])</span>)</span>
                s.push<span class="params">(pushV[i++])</span>;
            <span class="keyword">if</span><span class="params">(s.top<span class="params">()</span> == popV[j])</span>
                s.pop<span class="params">()</span>;
            <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span>)</span>
                break;
        }
        <span class="keyword">if</span><span class="params">(i == pushV.size<span class="params">()</span> &amp;&amp; j == popV.size<span class="params">()</span> &amp;&amp; s.empty<span class="params">()</span>)</span>
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="剑指offer65_滑动窗口最大值">剑指offer65 滑动窗口最大值</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解法-3">解法</h4><p>使用双端队列(dequeue)记录当前窗口最大值<strong>下标</strong>序列，每插入一个元素就向前删除。通过比较dequeue的第一个元素是当前窗口的最大元素<strong>下标</strong>，比较首元素下标和i-size判断删除队列头部元素。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>从后向前删除</li>
<li>最后一个窗口</li>
</ul>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; maxInWindows(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, unsigned <span class="type">int</span> size)
    {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;
        <span class="keyword">if</span>(num.size() &lt; size || size &lt; <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        deque&lt;<span class="type">int</span>&gt; indexes;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)
        {
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            indexes.push_back(i);
        }

        <span class="keyword">for</span>(<span class="type">int</span> i = size;i &lt; num.size(); i++)
        {
            <span class="literal">result</span>.push_back(num[indexes.front()]);
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; num[i] &gt;= num[indexes.back()])
                indexes.pop_back();
            <span class="keyword">while</span>(!indexes.empty() &amp;&amp; indexes.front() &lt;= (i-size))
                indexes.pop_front();
            indexes.push_back(i);
        }
        <span class="literal">result</span>.push_back(num[indexes.front()]);
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="剑指offer_7_两个栈实现队列_VS_两个队列实现栈">剑指offer 7 两个栈实现队列 VS 两个队列实现栈</h3><h4 id="问题描述">问题描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<]]>
    </summary>
    
      <category term="栈和队列" scheme="http://rudy-zhang.me/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组专题-数组中出现的次数]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://rudy-zhang.me/2015/09/27/找工作总结-数组专题-出现次数/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-10-03T02:00:01.358Z</updated>
    <content type="html"><![CDATA[<h2 id="通用的几种解题思路">通用的几种解题思路</h2><ul>
<li>使用map记录出现的次数，要求额外增加空间复杂度</li>
<li>所有数字异或可以消灭掉数组中出现偶数次的数字</li>
</ul>
<h3 id="剑指offer51_数组中重复的数字">剑指offer51 数组中重复的数字</h3><h4 id="问题描述">问题描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h4 id="解法">解法</h4><ul>
<li>排序后扫描，时间复杂度nlogn，空间复杂度O(1)</li>
<li>使用map记录，时间复杂度O(n)，空间复杂度O(n)</li>
</ul>
<h4 id="注意点">注意点</h4><ul>
<li>map的遍历<br><code>map&lt;int, int&gt;::iterator iter;</code><br><code>iter-&gt;first</code> <code>iter-&gt;second</code></li>
</ul>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{
        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;
        <span class="keyword">bool</span> ans = <span class="keyword">false</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)
        {
            <span class="keyword">if</span>(dict.count(numbers[i]) == <span class="number">0</span>)
                dict[numbers[i]] = <span class="number">1</span>;
            <span class="keyword">else</span>{
                dict[numbers[i]] += <span class="number">1</span>;
                ans = <span class="keyword">true</span>;
            }
        }
        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;
        <span class="keyword">for</span>(iter = dict.begin();iter != dict.end();iter++)
        {
            <span class="keyword">if</span>(iter-&gt;second &gt; <span class="number">1</span>)
            {
                *duplication = iter-&gt;first;
                duplication++;
            }
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer29_数组中出现次数超过一半的数字">剑指offer29 数组中出现次数超过一半的数字</h3><h4 id="问题描述-1">问题描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p>
<h4 id="解法-1">解法</h4><ul>
<li>使用快排partition函数，扫描一遍数组中间元素就是出现超过一半的数字</li>
<li>使用time记录数字出现的次数，cur记录当前数字</li>
</ul>
<h4 id="注意点-1">注意点</h4><ul>
<li>使用解法2需要判断最后的次数是否真的大于一半，如果不是，返回特定值</li>
</ul>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="keyword">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="keyword">int</span>&gt; numbers) {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>) 
            <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> time = <span class="number">1</span>;
        <span class="keyword">int</span> cur = numbers[<span class="number">0</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(time == <span class="number">0</span>)
            {
                cur = numbers[i];
                time = <span class="number">1</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == cur)
                time++;
            <span class="keyword">else</span>
                time--;
        }
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == cur)
                <span class="keyword">count</span>++;
        }
        <span class="keyword">if</span>(<span class="keyword">count</span> * <span class="number">2</span> &gt; numbers.<span class="keyword">size</span>())
            <span class="keyword">return</span> cur;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre><h3 id="剑指offer40_数组中只出现一次的数字">剑指offer40 数组中只出现一次的数字</h3><h4 id="问题描述-2">问题描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解法-2">解法</h4><ul>
<li>对于只有一个数字出现一次，对所有数字做异或操作</li>
<li>有两个数字a,b出现了一次，其它出现偶数次。所有数字异或得temp = a^b，使用result做spliter，每一个数字和temp做与操作，把数组分成两组</li>
</ul>
<h4 id="注意点-2">注意点</h4><ul>
<li>与或非的操作符优先级</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void FindNumsAppearOnce(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>,<span class="built_in">int</span>* num1,<span class="built_in">int</span> *num2) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)
        {
            *num1 = <span class="number">0</span>;
            *num2 = <span class="number">0</span>;
            <span class="keyword">return</span> ;
        }
        <span class="built_in">int</span> temp = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;<span class="type">data</span>.<span class="built_in">size</span>(); i++)
            temp ^= <span class="type">data</span>[i];

        <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;
        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="type">data</span>.<span class="built_in">size</span>(); i++)
        {
            <span class="keyword">if</span>((<span class="type">data</span>[i] &amp; temp) == <span class="number">0</span>)
                a ^= <span class="type">data</span>[i];
            <span class="keyword">else</span>
                b ^= <span class="type">data</span>[i];

        }
        *num1 = a;
        *num2 = b;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="通用的几种解题思路">通用的几种解题思路</h2><ul>
<li>使用map记录出现的次数，要求额外增加空间复杂度</li>
<li>所有数字异或可以消灭掉数组中出现偶数次的数字</li>
</ul>
<h3 id="剑指offer51_数组中重复的数字">剑指]]>
    </summary>
    
      <category term="数组" scheme="http://rudy-zhang.me/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组专题-两个指针]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98-%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88/"/>
    <id>http://rudy-zhang.me/2015/09/27/找工作总结-数组专题-两个指针/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-10-10T10:59:36.013Z</updated>
    <content type="html"><![CDATA[<h1 id="通用解题思路">通用解题思路</h1><ul>
<li>使用快排中的partition函数</li>
<li>贪心,left++,right-直到相遇</li>
<li>二分查找，mid = (left + right) / 2</li>
</ul>
<h2 id="k-sum问题">k-sum问题</h2><p>k-sum问题解题思路:<br>先对数组进行排序(nlogn)。退化成2-sum问题，使用left,right指针向中间查找。最终把复杂度优化到O(n^(k-1))</p>
<h3 id="剑指offer41_和为S的两个数字_VS_和为S的连续正数序列">剑指offer41 和为S的两个数字 VS 和为S的连续正数序列</h3><h4 id="问题描述">问题描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<h4 id="解法">解法</h4><p>2-sum问题，乘积最小的两个数字就是left和right第一次满足条件的两个数字。</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    vector&lt;<span class="built_in">int</span> &gt; FindNumbersWithSum(vector&lt;<span class="built_in">int</span>&gt; <span class="built_in">array</span>,<span class="built_in">int</span> sum) {
        vector&lt;<span class="built_in">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) return vec;
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &lt; sum)
                <span class="built_in">left</span>++;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[<span class="built_in">left</span>] + <span class="built_in">array</span>[<span class="built_in">right</span>] &gt; sum)
                <span class="built_in">right</span>--;
            <span class="keyword">else</span>
            {
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">left</span>]);
                vec.push_back(<span class="built_in">array</span>[<span class="built_in">right</span>]);
                return vec;
            }
        }
        return vec;
    }
};
</code></pre><h4 id="问题描述-1">问题描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<h4 id="解法-1">解法</h4><p>同上，不过比较条件变成。(left+right)(right-left+1)/2</p>
<h4 id="代码-1">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) {
        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">list</span>;
        <span class="keyword">if</span>(sum &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">list</span>;
        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;
        <span class="keyword">while</span>(right &lt;= (sum + <span class="number">1</span>) / <span class="number">2</span>)
        {
            <span class="keyword">int</span> temp = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(temp &lt; sum)
                right++;
            <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; sum)
                left++;
            <span class="keyword">else</span>
            {
                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)
                    vec.push_back(i);
                <span class="built_in">list</span>.push_back(vec);
                right++;
            }
        }
        <span class="keyword">return</span> <span class="built_in">list</span>;
    }
};
</code></pre><h3 id="leetcode18_4Sum">leetcode18 4Sum</h3><h4 id="问题描述-2">问题描述</h4><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<ul>
<li>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)</li>
<li><p>The solution set must not contain duplicate quadruplets.</p>
<pre><code>For example, given<span class="instruction"> array </span>S = {1 0 -1 0 -2 2},<span class="instruction"> and </span>target = 0.

A solution set is:
(-1,  0, 0, 1<span class="function">)</span>
(-2, -1, 1, 2<span class="function">)</span>
(-2,  0, 0, 2<span class="function">)</span>
</code></pre></li>
</ul>
<h4 id="解法-2">解法</h4><p>先排序，退化到2-sum问题。</p>
<h4 id="注意点">注意点</h4><p>题目要求找出所有满足条件的数组，需要避免重复。</p>
<h4 id="代码-2">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
<span class="comment">//思路：K-Sum问题，复杂度降到O(n^(k-1))</span>
<span class="comment">//注意，不能重复，num个数不够4</span>
<span class="comment">//去重，left，right去重，i层循环去重，j层循环去重</span>
    vector&lt;vector&lt;<span class="built_in">int</span>&gt; &gt; fourSum(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">num</span>, <span class="built_in">int</span> target) {
        sort(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());
        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; list;
        <span class="keyword">if</span>(<span class="built_in">num</span>.size() &lt; <span class="number">4</span>) 
            <span class="keyword">return</span> list;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.size()-<span class="number">3</span>; i++)
        {
            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">num</span>.size()- <span class="number">2</span>; j++)
            {
                <span class="built_in">int</span> left = j + <span class="number">1</span>, right = <span class="built_in">num</span>.size() - <span class="number">1</span>;
                <span class="keyword">while</span>(left &lt; right)
                {
                    <span class="built_in">int</span> sum = <span class="built_in">num</span>[i]+<span class="built_in">num</span>[j]+<span class="built_in">num</span>[left]+<span class="built_in">num</span>[right];
                    <span class="keyword">if</span>(sum &lt; target)
                        left++;
                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)
                        right--;
                    <span class="keyword">else</span>
                    {
                        vector&lt;<span class="built_in">int</span>&gt; vec;
                        vec.push_back(<span class="built_in">num</span>[i]);
                        vec.push_back(<span class="built_in">num</span>[j]);
                        vec.push_back(<span class="built_in">num</span>[left]);
                        vec.push_back(<span class="built_in">num</span>[right]);
                        list.push_back(vec);
                        left++;
                        right--; 
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[left] == <span class="built_in">num</span>[left - <span class="number">1</span>]) 
                            left++;
                        <span class="keyword">while</span>(left &lt; right &amp;&amp; <span class="built_in">num</span>[right] == <span class="built_in">num</span>[right + <span class="number">1</span>]) 
                            right--;
                    }
                }
                <span class="keyword">while</span>(j + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">2</span> &amp;&amp; <span class="built_in">num</span>[j] == <span class="built_in">num</span>[j + <span class="number">1</span>]) 
                    j++;
            }
            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; <span class="built_in">num</span>.size() - <span class="number">3</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i+<span class="number">1</span>]) 
                i++;
        }
        <span class="keyword">return</span> list;
    }
};
</code></pre><h2 id="二分查找问题">二分查找问题</h2><p>二分查找通用解题思路，left=头指针，right=尾指针，mid=(left+right)/2，通过条件判断，移动left和right最终使得left和right相遇得到最终结果。</p>
<h3 id="普通二分查找">普通二分查找</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个<strong>有序数组，可能含有重复元素</strong>。给定target，寻找target出现的下标，不存在返回-1.</p>
<h4 id="代码-3">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] == target)
            return <span class="built_in">mid</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
    }
    return -<span class="number">1</span>;
}
</code></pre><h3 id="等于target的第一个元素">等于target的第一个元素</h3><h4 id="问题描述-4">问题描述</h4><p>给定有序数组a,含有重复元素，求最小(或者求最大)的使得a[i]等于target的下标。不存在返回-1.<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnyv9bn30j20fg057q2z.jpg" alt=""></p>
<h4 id="代码-4">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt; target)
            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] == target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="小于target的第一个元素">小于target的第一个元素</h3><h4 id="问题描述-5">问题描述</h4><p>给定有序数组a,含有重复元素，求最大的i使得a[i]小于target。不存在返回-1<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewnyykveyaj20bt04edfv.jpg" alt=""></p>
<h4 id="代码-5">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &gt;= target)
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;
        <span class="keyword">else</span>
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
    }
    <span class="keyword">if</span>(a[<span class="built_in">left</span>] &lt; target)
        return <span class="built_in">left</span>
    <span class="keyword">else</span>
        return -<span class="number">1</span>;
}
</code></pre><h3 id="求target在数组中的出现次数">求target在数组中的出现次数</h3><h4 id="解法-3">解法</h4><p>出现次数 = 最后一次出现位置 - 第一次出现位置 + 1<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewnz2xlz25j20ep05ewek.jpg" alt=""></p>
<h4 id="代码-6">代码</h4><pre><code><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N, <span class="keyword">int</span> <span class="keyword">target</span>)</span>
</span>{
    <span class="keyword">int</span> first = searchFisrt(a, N, <span class="keyword">target</span>);
    <span class="keyword">if</span>(first == -<span class="number">1</span>)
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> last = searchLast(a, N, <span class="keyword">target</span>);
    <span class="keyword">return</span> (last - first + <span class="number">1</span>);
}
</code></pre><h3 id="插入的位置（小于等于target的第一个元素）">插入的位置（小于等于target的第一个元素）</h3><h4 id="问题描述-6">问题描述</h4><p>给定有序数组a,含有重复元素，若target在数组中出现，返回位置，如果不存在，返回应该插入的位置。</p>
<h4 id="解法-4">解法</h4><p>&lt;=target是可能的位置<br><img src="http://ww3.sinaimg.cn/mw690/4c2edcb7jw1ewo0ah8apsj20cf03lgln.jpg" alt=""></p>
<h4 id="代码-7">代码</h4><pre><code><span class="built_in">int</span> search(<span class="built_in">int</span> a[], <span class="built_in">int</span> N, <span class="built_in">int</span> target)
{
    <span class="keyword">if</span>(N &lt; <span class="number">1</span>)
        return -<span class="number">1</span>;
    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = N - <span class="number">1</span>;
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
        <span class="keyword">if</span>(a[<span class="built_in">mid</span>] &lt;= target)
            <span class="built_in">left</span> = <span class="built_in">mid</span>;
        <span class="keyword">else</span>
            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>; 
    }
    return <span class="built_in">left</span>;
}
</code></pre><h2 id="旋转数组的二分查找">旋转数组的二分查找</h2><h3 id="leetcode_33_Search_in_Rotated_Sorted_Array">leetcode 33 Search in Rotated Sorted Array</h3><h4 id="问题描述-7">问题描述</h4><p>给定有序数组，在某一个位置发生旋转，求target在数组中出现的位置。<strong>无重复元素</strong>，找到返回下标，找不到返回-1.</p>
<h4 id="解法-5">解法</h4><p>先判断mid落在了旋转数组的哪一部分，然后判断和target的关系<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1ewo177qwiyj20c507cq32.jpg" alt=""></p>
<h4 id="代码-8">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int <span class="keyword">left</span> = <span class="number">0</span>,<span class="keyword">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)
        {
            int mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[mid] == target)
                <span class="keyword">return</span> mid;
            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="keyword">left</span>])<span class="comment">//left-mid升序</span>
            {
                <span class="keyword">if</span>(nums[<span class="keyword">left</span>] &lt;= target &amp;&amp; target &lt; nums[mid])
                    <span class="keyword">right</span> = mid-<span class="number">1</span> ;
                <span class="keyword">else</span>
                    <span class="keyword">left</span> = mid+<span class="number">1</span>;
            }
            <span class="keyword">else</span><span class="comment">//mid-right升序</span>
            {
                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="keyword">right</span>])
                    <span class="keyword">left</span> = mid +<span class="number">1</span>;
                <span class="keyword">else</span>
                {
                    <span class="keyword">right</span> = mid-<span class="number">1</span>;
                }
            }
        }
        <span class="keyword">if</span>(nums[<span class="keyword">left</span>] == target)
            <span class="keyword">return</span> <span class="keyword">left</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> -<span class="number">1</span>;
    }
};
</code></pre><h3 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h3><h4 id="问题描述-8">问题描述</h4><p>其他条件相同，但允许数组中存在重复元素。判断target是否出现在数组中。</p>
<h4 id="解法-6">解法</h4><p>增加判断条件，当a[left] = a[mid] = a[right]，直接遍历去寻找，不能使用二分查找</p>
<h4 id="代码-9">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> target) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>,<span class="built_in">right</span> = nums.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == target)
                return <span class="literal">true</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] == nums[<span class="built_in">left</span>] &amp;&amp; nums[<span class="built_in">mid</span>] == nums[<span class="built_in">right</span>])
            {
                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; i++)
                {
                    <span class="keyword">if</span>(nums[i] == target)
                        return <span class="literal">true</span>;
                }
                return <span class="literal">false</span>;
            }
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt;= nums[<span class="built_in">left</span>])
            {
                <span class="keyword">if</span>(target &gt;= nums[<span class="built_in">left</span>] &amp;&amp; target &lt; nums[<span class="built_in">mid</span>])
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="keyword">if</span>(target &gt; nums[<span class="built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="built_in">right</span>])
                    <span class="built_in">left</span> = <span class="built_in">mid</span> +<span class="number">1</span>;
                <span class="keyword">else</span>
                    <span class="built_in">right</span> = <span class="built_in">mid</span> -<span class="number">1</span>;
            }
        }
        <span class="keyword">if</span>(nums[<span class="built_in">left</span>] == target)
            return <span class="literal">true</span>;
        <span class="keyword">else</span>
            return <span class="literal">false</span>;
    }
};
</code></pre><h3 id="leetcode_153_Find_Minimum_in_Rotated_Sorted_Array">leetcode 153    Find Minimum in Rotated Sorted Array</h3><h4 id="问题描述-9">问题描述</h4><p>给定有序数组，<strong>无重复元素</strong>，在某一位置发生旋转，求数组中的最小元素</p>
<h4 id="解法-7">解法</h4><p>同上<br><img src="http://ww1.sinaimg.cn/mw690/4c2edcb7jw1ewo7wvjpz5j20as05ugln.jpg" alt=""></p>
<h4 id="注意点-1">注意点</h4><ul>
<li>对于数组旋转个数为0的考虑<br>如果使用a[mid] &gt;= a[left]判断，需要考虑数组是否并没有旋转(a[left] &lt; a[right])</li>
<li>也可以使用这样的条件进行判断 a[mid] &gt; a[right]</li>
</ul>
<h4 id="代码-10">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h3 id="leetcode_Find_Minimum_in_Rotated_Sorted_Array_II">leetcode Find Minimum in Rotated Sorted Array II</h3><h4 id="问题描述-10">问题描述</h4><p>同上，不过允许数组中存在重复元素</p>
<h4 id="解法-8">解法</h4><p>对a[mid] = a[right]时，right—。因为a[left] &lt;= a[right] == a[mid],为了使得a[mid]最小，需要对使得left和right逐渐接近，需要遍历才能找到，所以对right进行减一操作。</p>
<h4 id="代码-11">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = nums.size()-<span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>)/<span class="number">2</span>;
            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>])
                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])
                <span class="built_in">right</span> = <span class="built_in">mid</span>;
            <span class="keyword">else</span>
                <span class="built_in">right</span>--;
        }
        return nums[<span class="built_in">left</span>];
    }
};
</code></pre><h2 id="一般题目">一般题目</h2><h3 id="剑指offer14_调整数组顺序使奇数位于偶数之前">剑指offer14 调整数组顺序使奇数位于偶数之前</h3><h4 id="问题描述-11">问题描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="解法-9">解法</h4><ul>
<li>使用插入排序的思想，复杂度O(n^2)</li>
<li>使用额外的O(n)存储，遍历原数组，计数从前往后放，偶数从后往前放。时间复杂度O(n)</li>
<li>补充，如果不需要保证相对位置，可以使用快排的partition函数做一次扫描。</li>
</ul>
<h4 id="方法2的代码">方法2的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">array</span>) {
        vector&lt;<span class="built_in">int</span>&gt; vec(<span class="built_in">array</span>.size());
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="built_in">int</span> leftIndex = <span class="number">0</span>, rightIndex = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">array</span>.size())
                vec[leftIndex++] = <span class="built_in">array</span>[<span class="built_in">left</span>++];
        }
        <span class="keyword">while</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
        {
            <span class="keyword">while</span>((<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">if</span>(<span class="built_in">right</span> &gt;= <span class="number">0</span>)
                vec[rightIndex--] = <span class="built_in">array</span>[<span class="built_in">right</span>--];
        }
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)
            <span class="built_in">array</span>[i] = vec[i];
    }  
};
</code></pre><h4 id="方法3的代码">方法3的代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    void reOrderArray(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="built_in">array</span>) {
        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">array</span>.size() - <span class="number">1</span>;
        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
        {
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">right</span>]&amp;<span class="number">0x01</span>) == <span class="number">0</span>)
                <span class="built_in">right</span>--;
            <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; (<span class="built_in">array</span>[<span class="built_in">left</span>]&amp;<span class="number">0x01</span>) == <span class="number">1</span>)
                <span class="built_in">left</span>++;
            <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
            {
                <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
                <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
                <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            }
        }
    }
};
</code></pre><h3 id="剑指offer36_数组中的逆序对">剑指offer36 数组中的逆序对</h3><h4 id="问题描述-12">问题描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="解法-10">解法</h4><p>使用归并排序的merge过程，统计逆序对的个数。merge过程需要merge,left~mid和mid~right。假如vec[lpos] &gt; vec[rpos],逆序对的个数需要增加<strong>mid-lpos+1</strong>个，因为vec中所有lpos之后的元素和rpos对应的元素都形成了逆序对。</p>
<h4 id="代码-12">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> InversePairs(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span>) {
        <span class="keyword">if</span>(<span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">0</span> || <span class="type">data</span>.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;
        vector&lt;<span class="built_in">int</span>&gt; temp(<span class="type">data</span>.<span class="built_in">size</span>());
        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;
        mergeSort(<span class="type">data</span>, temp, <span class="number">0</span>, <span class="type">data</span>.<span class="built_in">size</span>()-<span class="number">1</span>, <span class="built_in">count</span>);
        <span class="keyword">return</span> <span class="built_in">count</span>;
    }

    void mergeSort(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="keyword">if</span>(left &lt; right)
        {
            <span class="built_in">int</span> mid = (left + right) / <span class="number">2</span>;
            mergeSort(<span class="type">data</span>, temp, left, mid, <span class="built_in">count</span>);
            mergeSort(<span class="type">data</span>, temp, mid + <span class="number">1</span>, right, <span class="built_in">count</span>);
            <span class="built_in">merge</span>(<span class="type">data</span>, temp, left, mid, right, <span class="built_in">count</span>);
        }
    }

    void <span class="built_in">merge</span>(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="type">data</span>, vector&lt;<span class="built_in">int</span>&gt;&amp; temp, <span class="built_in">int</span> left, <span class="built_in">int</span> mid, <span class="built_in">int</span> right, <span class="built_in">int</span>&amp; <span class="built_in">count</span>)
    {
        <span class="built_in">int</span> lend = mid, rend = right;
        <span class="built_in">int</span> lpos = left, rpos = mid + <span class="number">1</span>, tpos = left;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(<span class="type">data</span>[lpos] &lt;= <span class="type">data</span>[rpos])
                temp[tpos++] = <span class="type">data</span>[lpos++];
            <span class="keyword">else</span>
            {
                <span class="built_in">count</span> += mid-lpos+<span class="number">1</span>;
                temp[tpos++] = <span class="type">data</span>[rpos++];
            }
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++]=<span class="type">data</span>[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = <span class="type">data</span>[rpos++];
        for(<span class="built_in">int</span> i = left; i &lt;= right; i++)
            <span class="type">data</span>[i] = temp[i];
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="通用解题思路">通用解题思路</h1><ul>
<li>使用快排中的partition函数</li>
<li>贪心,left++,right-直到相遇</li>
<li>二分查找，mid = (left + right) / 2</li>
</ul>
<h2 id]]>
    </summary>
    
      <category term="两个指针" scheme="http://rudy-zhang.me/tags/%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://rudy-zhang.me/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数组专题-一般题目]]></title>
    <link href="http://rudy-zhang.me/2015/09/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98-%E4%B8%80%E8%88%AC%E9%A2%98%E7%9B%AE/"/>
    <id>http://rudy-zhang.me/2015/09/27/找工作总结-数组专题-一般题目/</id>
    <published>2015-09-27T13:56:00.000Z</published>
    <updated>2015-10-03T06:44:43.267Z</updated>
    <content type="html"><![CDATA[<h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法">解法</h4><p>从右上角（这样使得这一行剩余元素都比他小，这一列剩余元素都比他大）向左下角扫描</p>
<h4 id="代码">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>{
        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">int</span> width = <span class="built_in">array</span>[<span class="number">0</span>].size();
        <span class="keyword">int</span> height = <span class="built_in">array</span>.size();
        <span class="keyword">int</span> i = <span class="number">0</span>, j = width - <span class="number">1</span>;
        <span class="keyword">while</span>(i &lt; height &amp;&amp; j &gt;= <span class="number">0</span>)
        {
            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &lt; target)
                i++;
            <span class="keyword">else</span>
                j--;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer32_整数中1出现的次数（从1到n整数中1出现的次数）">剑指offer32 整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="问题描述-1">问题描述</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h4 id="解法-1">解法</h4><p>这个解法对于1-9的原理是一样的。首先找到规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从 1 至  10^i ，在它们右数第  i  位中，任意的 X 都出现了  10^(i−1)  次。这个可以用来计算高位的值。<br>计算方法：<br>当计算右数第  i  位包含的 X 的个数时：<br>取第  i  位左边（高位）的数字，乘以  10^(i−1) ，得到基础值  a 。<br>取第  i  位数字，计算修正值：<br>如果大于 X，则结果为  a+ 10^(i−1)。<br>如果小于 X，则结果为  a。<br>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  (a+b+1) 。<br>例如对于num=52134, i=3, a=52, b=34, i位数字k=1,k=x故 result=a+b+1<br>解释，a等于0~51，可推出高位的结果，a=52时，讨论低位的结果。</p>
<h4 id="代码-1">代码</h4><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    <span class="keyword">int</span> NumberOf1Between1AndN_Solution(<span class="keyword">int</span> n)
    {
        <span class="keyword">int</span> x = <span class="number">1</span>;
        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>, k;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n / i &gt; <span class="number">0</span>; i *= <span class="number">10</span>)
        {
            k = n / i;
            <span class="comment">//k/10为高位数字</span>
            <span class="keyword">count</span> += (k / <span class="number">10</span>) * i;
            <span class="keyword">int</span> cur = k % <span class="number">10</span>;
            <span class="keyword">if</span>(cur &gt; x)
                <span class="keyword">count</span>+=i;               
            <span class="keyword">else</span> <span class="keyword">if</span>(cur == x)
                <span class="comment">//n%i为低位数字</span>
                <span class="keyword">count</span> += n % i + <span class="number">1</span>;
            <span class="keyword">else</span>{}
        }
        <span class="keyword">return</span> <span class="keyword">count</span>;
    }
};
</code></pre><h3 id="剑指offer44_扑克牌的顺子">剑指offer44 扑克牌的顺子</h3><h4 id="问题描述-2">问题描述</h4><p>抽出一序列牌，王代表任意数字是0，并且A看作1,J为11,Q为12,K为13。判断这个序列是否是顺子</p>
<h4 id="解法-2">解法</h4><p>对序列进行排序，看0是否能将空缺数字填满。</p>
<h4 id="注意点">注意点</h4><ul>
<li>统计0的个数和gap的数量进行比较</li>
</ul>
<h4 id="代码-2">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    bool IsContinuous(vector&lt;<span class="keyword">int</span>&gt; numbers)
    {
        <span class="keyword">if</span>(numbers.<span class="keyword">size</span>() == <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">sort</span>(numbers.begin(), numbers.end());
        <span class="keyword">int</span> numOfZero = <span class="number">0</span>, numOfGap = <span class="number">0</span>;
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>() &amp;&amp; numbers[i] == <span class="number">0</span>; i++)
            numOfZero++;
        <span class="keyword">if</span>(i &lt; numbers.<span class="keyword">size</span>())
            i++;
        <span class="keyword">for</span>(;i &lt; numbers.<span class="keyword">size</span>(); i++)
        {
            <span class="keyword">if</span>(numbers[i] == numbers[i - <span class="number">1</span>])
                <span class="keyword">return</span> <span class="keyword">false</span>; 
            numOfGap += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;
        }
        <span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;
    }
};
</code></pre><h3 id="剑指offer52_构建乘积数组">剑指offer52 构建乘积数组</h3><h4 id="问题描述-3">问题描述</h4><p>给定一个数组<code>A[0,1,...,n-1]</code>,请构建一个数组<code>B[0,1,...,n-1]</code>,其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<h4 id="解法-3">解法</h4><p>从上到下扫描，temp记录中间结果，避免重复的乘法。从上到下遍历一次，从下到上遍历一次。</p>
<h4 id="代码-3">代码</h4><pre><code>class <span class="type">Solution</span> {
public:
    vector&lt;<span class="type">int</span>&gt; multiply(<span class="keyword">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A) {
        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>(A.size(), <span class="number">1</span>);
        <span class="keyword">if</span>(A.size() &lt;= <span class="number">1</span>)
            <span class="keyword">return</span> <span class="literal">result</span>;
        <span class="type">int</span> temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)
        {
            temp *= A[i - <span class="number">1</span>];
            <span class="literal">result</span>[i] = temp;
        }
        temp = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="type">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)
        {
            temp *= A[i + <span class="number">1</span>];
            <span class="literal">result</span>[i] *= temp;
        }
        <span class="keyword">return</span> <span class="literal">result</span>;
    }
};
</code></pre><h3 id="剑指offer20_顺时针打印矩阵">剑指offer20 顺时针打印矩阵</h3><h4 id="问题描述-4">问题描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h4 id="解法-4">解法</h4><p>先写一个打印一圈的函数，再遍历所有的圈。</p>
<h4 id="注意点-1">注意点</h4><ul>
<li>判断遍历是否越界</li>
<li>遍历的时候注意减回去(x—)</li>
</ul>
<h4 id="代码-4">代码</h4><pre><code>class Solution {
public:
    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="keyword">matrix</span>) {
        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>.<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">if</span>(<span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vec;
        <span class="keyword">int</span> start = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> start =  <span class="number">0</span>; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; start * <span class="number">2</span> &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); start++)
            printInCircle(<span class="keyword">matrix</span>, start, vec);
        <span class="keyword">return</span> vec;
    }

    void printInCircle(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;<span class="keyword">matrix</span>, <span class="keyword">int</span> start, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)
    {
        <span class="keyword">int</span> x = start, y = start;
        <span class="comment">//从左向右打印</span>
        <span class="keyword">int</span> endx = <span class="keyword">matrix</span>[y].<span class="keyword">size</span>()- <span class="number">1</span> - start;
        <span class="keyword">for</span>(; x &lt;= endx; x++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        --x;

        <span class="comment">//从上向下打印</span>
        <span class="keyword">int</span> endy = <span class="keyword">matrix</span>.<span class="keyword">size</span>() - <span class="number">1</span> - start;
        <span class="keyword">if</span>(y + <span class="number">1</span> &gt; endy)
            <span class="keyword">return</span>;
        y++;
        <span class="keyword">for</span>(; y &lt;= endy; y++)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y--;

        <span class="comment">//从右向左打印</span>
        <span class="keyword">if</span>(x - <span class="number">1</span> &lt; start)
            <span class="keyword">return</span>;
        x--;
        <span class="keyword">for</span>(; x &gt;= start; x--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        x++;
        <span class="comment">//从下向上打印</span>
        <span class="keyword">if</span>(y - <span class="number">1</span> &lt; start) <span class="keyword">return</span>;
        y--;
        <span class="keyword">for</span>(; y &gt; start; y--)
            vec.push_back(<span class="keyword">matrix</span>[y][x]);
        y++;
    }

 };
</code></pre><h3 id="剑指offer30_最小的k个数">剑指offer30 最小的k个数</h3><h4 id="问题描述-5">问题描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="解法-5">解法</h4><p>使用大顶堆存储k个数，遍历原数据，每次淘汰最大的，最后堆中剩余的元素就是最小的k个数</p>
<h4 id="注意点-2">注意点</h4><ul>
<li>输入数据合法性，k的取值大于input.size()的情况</li>
<li><p>stl中<algorithm>关于堆的操作，make_heap,push_heap,pop_heap,sort_heap.默认建立大顶堆，如果想使用小顶堆需要加入比较函数。</algorithm></p>
<pre><code>make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);
</code></pre></li>
</ul>
<h4 id="代码-5">代码</h4><pre><code><span class="keyword">class</span> <span class="type">Solution</span> {
public:
    vector&lt;<span class="built_in">int</span>&gt; <span class="type">GetLeastNumbers_Solution</span>(vector&lt;<span class="built_in">int</span>&gt; input, <span class="built_in">int</span> k) {
        vector&lt;<span class="built_in">int</span>&gt; res;
        <span class="keyword">if</span>(k&lt;= <span class="number">0</span> || k &gt; input.size<span class="literal">()</span>)
            return res;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++)
            res.push_back(input[i]);
        make_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; input.size<span class="literal">()</span>; i++)
        {
            <span class="keyword">if</span>(input[i] &gt;= res[<span class="number">0</span>])
                continue;
            res.push_back(input[i]);
            push_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            pop_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
            res.pop_back<span class="literal">()</span>;
        }
        sort_heap(res.<span class="keyword">begin</span><span class="literal">()</span>, res.<span class="keyword">end</span><span class="literal">()</span>);
        return res;
    }
};
</code></pre><h3 id="剑指offer33_把数组排成最小的数">剑指offer33 把数组排成最小的数</h3><h4 id="问题描述-6">问题描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="解法-6">解法</h4><p>首先要证明这样一个结论：</p>
<blockquote>
<p>若ca&lt;ac则在最后的字符串中，c应该在a的后面</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>条件：ca&lt;ac，有另一个任意<strong>字符串</strong>b与a,c进行排列组合<br>讨论：</p>
<pre><code>若b&lt;c&lt;<span class="tag">a</span> 可以得到bca是最小的
若c&lt;b&lt;<span class="tag">a</span> 可以得到cba是最小的
若c&lt;a&lt;<span class="tag">b</span> 可以得到cab是最小的
</code></pre><p>结论：c应该在a的前面</p>
<h4 id="注意点-3">注意点</h4><ul>
<li><p>sort函数中比较函数应该如何写</p>
<p>  <code>template &lt;class RandomAccessIterator, class Compare&gt;</code><br>  <code>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></p>
</li>
</ul>
<p>comp函数表示</p>
<blockquote>
<p>The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.<br>比较函数传入两个参数，返回bool，返回值表示在最终的排序结果中，第一个参数是否应该出现在第二个参数的前面。</p>
</blockquote>
<h4 id="代码-6">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;str2)</span>
    </span>{
        <span class="built_in">string</span> temp1 = str1 + str2;
        <span class="built_in">string</span> temp2 = str2 + str1;
        <span class="keyword">if</span>(temp1.compare(temp2)&lt;=<span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;

    }

    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>{
        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;
        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs(numbers.size());
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)
        {
            strs[i] = numToString(numbers[i]);
        }
        <span class="built_in">std</span>::sort(strs.begin(), strs.end(), cmp);
        <span class="built_in">string</span> ans;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)
            ans += strs[i];
        <span class="keyword">return</span> ans;
    }  

    <span class="function"><span class="built_in">string</span> <span class="title">numToString</span><span class="params">(<span class="keyword">int</span> num)</span>
    </span>{
        <span class="built_in">string</span> str;
        <span class="keyword">while</span>(num)
        {
            str = (<span class="keyword">char</span>)(num % <span class="number">10</span> + <span class="string">'0'</span>) + str;
            num = num / <span class="number">10</span>;
        }
        <span class="keyword">return</span> str;
    } 
};
</code></pre><h3 id="剑指offer34_丑数">剑指offer34 丑数</h3><h4 id="问题描述-7">问题描述</h4><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="解法-7">解法</h4><p>使用递推法，<code>*numM2</code>,<code>*numM3</code>,<code>*numM5</code>表示，x2,x3,x5后产生的数</p>
<h4 id="代码-7">代码</h4><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="built_in">int</span> GetUglyNumber_Solution(<span class="built_in">int</span> <span class="built_in">index</span>) {
        <span class="keyword">if</span>(<span class="built_in">index</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="built_in">int</span> *a = new <span class="built_in">int</span>[<span class="built_in">index</span>];
        a[<span class="number">0</span>] = <span class="number">1</span>;
        <span class="built_in">int</span> *numM2 = a, *numM3 = a, *numM5 = a;
        for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">index</span>; i++)
        {
            <span class="built_in">int</span> <span class="built_in">min</span> = getMin((*numM2) * <span class="number">2</span>, (*numM3) * <span class="number">3</span>, (*numM5) * <span class="number">5</span>);
            a[i] = <span class="built_in">min</span>;
            <span class="keyword">while</span>((*numM2) * <span class="number">2</span> &lt;= <span class="built_in">min</span>)
                numM2++;
            <span class="keyword">while</span>((*numM3) * <span class="number">3</span> &lt;= <span class="built_in">min</span>)
                numM3++;
            <span class="keyword">while</span>((*numM5) * <span class="number">5</span> &lt;= <span class="built_in">min</span>)
                numM5++;
        }
        <span class="keyword">return</span> a[<span class="built_in">index</span>-<span class="number">1</span>];
    }

    <span class="built_in">int</span> getMin(<span class="built_in">int</span> num1,<span class="built_in">int</span> num2,<span class="built_in">int</span> num3)
    {
        <span class="keyword">return</span> <span class="built_in">min</span>(num1, <span class="built_in">min</span>(num2, num3));
    }
};
</code></pre><h3 id="剑指offer45_圆圈中最后剩下的数字（约瑟夫环问题）">剑指offer45 圆圈中最后剩下的数字（约瑟夫环问题）</h3><h4 id="问题描述-8">问题描述</h4><p>每年六一儿童节,NowCoder都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为NowCoder的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到NowCoder名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？</p>
<h4 id="解法-8">解法</h4><p>约瑟夫环递推公式：<br>f(n, m)表示n个人玩儿，报到m退出，最后剩下的人的编号。</p>
<pre><code><span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = 0, <span class="keyword">n</span>=1
<span class="literal">f</span>(<span class="keyword">n</span>, <span class="keyword">m</span>) = (<span class="literal">f</span>(<span class="keyword">n</span> - 1) + <span class="keyword">m</span>) % <span class="keyword">n</span>, <span class="keyword">n</span> &gt; 1
</code></pre><h4 id="代码-8">代码</h4><h5 id="递推解法">递推解法</h5><pre><code><span class="keyword">class</span> Solution {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span>
    </span>{
        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="keyword">int</span> last = <span class="number">0</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)
            last=(last + m) % i;
        <span class="keyword">return</span> last;
    }
};
</code></pre><h5 id="递归解法">递归解法</h5><pre><code>int lastRemain(int <span class="keyword">n</span>, int  <span class="keyword">m</span>)
{
    <span class="keyword">if</span>(<span class="keyword">n</span> == 1)
        <span class="keyword">return</span> 0;
    <span class="keyword">return</span> (lastRemain(<span class="keyword">n</span> - 1, <span class="keyword">m</span>) % <span class="keyword">n</span>);
}
</code></pre><h4 id="问题拓展:求第i次出环的人的编号">问题拓展:求第i次出环的人的编号</h4><pre><code>int getNumOfI(int <span class="keyword">n</span>, int <span class="keyword">m</span>, int i)
{
    <span class="keyword">if</span>(i == 1)
        <span class="keyword">return</span> (<span class="keyword">n</span> + <span class="keyword">m</span> - 1) % <span class="keyword">n</span>; <span class="comment">//第一次出环 (n-1+m)%n</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> getNumOfI(<span class="keyword">n</span> - 1, <span class="keyword">m</span>, i - 1) % <span class="keyword">n</span>;
}
</code></pre><p><a href="http://www.cnblogs.com/yangyh/archive/2011/10/30/2229517.html" target="_blank" rel="external">参考</a></p>
<h3 id="剑指offer64_数据流中的中位数">剑指offer64 数据流中的中位数</h3><h4 id="问题描述-9">问题描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>实现一种数据结构，要求插入删除O(logn),取中位数O(1)</p>
<h4 id="解法-9">解法</h4><p>实现一个小顶堆和大顶堆，大数存在小顶堆，小数存在大顶堆，每次按大小压入元素，调整两个堆中的数量，使得<code>0&lt;=Num(大顶堆)-Num(小顶堆)&lt;=1</code>。</p>
<h4 id="注意点-4">注意点</h4><ul>
<li>使用priority_queue<br>初始化：<pre><code>priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;
priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;
</code></pre>压入，弹出：<pre><code><span class="tag">minHeap</span><span class="class">.push</span>(<span class="tag">maxHeap</span><span class="class">.top</span>());
<span class="tag">maxHeap</span><span class="class">.pop</span>();
</code></pre></li>
</ul>
<h4 id="代码-9">代码</h4><pre><code>class Solution {
public:
    void Insert<span class="params">(int num)</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.empty<span class="params">()</span> || num &lt;= maxHeap.top<span class="params">()</span>)</span>
            maxHeap.push<span class="params">(num)</span>;
        <span class="keyword">else</span>
            minHeap.push<span class="params">(num)</span>;
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>+<span class="number">2</span>)</span>
        {
            minHeap.push<span class="params">(maxHeap.top<span class="params">()</span>)</span>;
            maxHeap.pop<span class="params">()</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>-<span class="number">1</span>)</span>
        {
            maxHeap.push<span class="params">(minHeap.top<span class="params">()</span>)</span>;
            minHeap.pop<span class="params">()</span>;
        }
    }

    double GetMedian<span class="params">()</span>
    {
        <span class="keyword">if</span><span class="params">(maxHeap.size<span class="params">()</span> == minHeap.size<span class="params">()</span>)</span>
            return <span class="params">(maxHeap.top<span class="params">()</span> + minHeap.top<span class="params">()</span>)</span>/<span class="number">2.0</span>;
        <span class="keyword">else</span>
            return maxHeap.top<span class="params">()</span>;
    }
private:
    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;

};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="剑指offer3_二维数组查找">剑指offer3 二维数组查找</h3><h4 id="问题描述">问题描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数]]>
    </summary>
    
      <category term="数组" scheme="http://rudy-zhang.me/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串专题]]></title>
    <link href="http://rudy-zhang.me/2015/09/25/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98-%E4%B8%80%E8%88%AC%E9%A2%98%E7%9B%AE/"/>
    <id>http://rudy-zhang.me/2015/09/25/找工作总结-字符串专题-一般题目/</id>
    <published>2015-09-25T13:56:00.000Z</published>
    <updated>2015-10-10T09:50:10.607Z</updated>
    <content type="html"><![CDATA[<h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一遍，记录空格个数。申请newSize，从后向前填充数组。</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string replaceSpace(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>()==<span class="number">0</span>)
            <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="built_in">int</span> numOfSpace=<span class="number">0</span>;
        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">str</span>.<span class="built_in">size</span>();++i)
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
                ++numOfSpace;
        <span class="built_in">int</span> newSize=<span class="built_in">str</span>.<span class="built_in">size</span>()+<span class="number">2</span>*numOfSpace;
        string ans;
        ans.resize(newSize);
        <span class="built_in">int</span> i=<span class="built_in">str</span>.<span class="built_in">size</span>()-<span class="number">1</span>,j=newSize-<span class="number">1</span>;
        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)   
        {
            <span class="keyword">if</span>(<span class="built_in">str</span>[i]==<span class="string">' '</span>)
            {
                ans[j--]=<span class="string">'0'</span>;
                ans[j--]=<span class="string">'2'</span>;
                ans[j--]=<span class="string">'%'</span>;
                --i;
            }
            <span class="keyword">else</span>
                ans[j--]=<span class="built_in">str</span>[i--];
        }
        <span class="keyword">return</span> ans;
    }
};
</code></pre><h3 id="剑指offer54_表示数值的字符串">剑指offer54 表示数值的字符串</h3><p>问题描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>解法：首先可以写出这个字符串的正则表达式</p>
<pre><code>(+|-)？\<span class="keyword">d</span>+(.\<span class="keyword">d</span>+)?(<span class="keyword">e</span>|<span class="literal">E</span>(+|-)?\<span class="keyword">d</span>+)?
</code></pre><p>对于正则表达式中的符号，<code>?</code>表示0或1，使用<code>if</code>判断，+表示1或者更多，直接扫描判断。</p>
<p>注意点：<br>(1) 非法输入，传入str == NULL<br>(2) 结束条件的判断</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{
<span class="keyword">public</span>:
    bool isNumeric(<span class="keyword">char</span>* <span class="keyword">str</span>)
    {
        <span class="keyword">if</span>(<span class="keyword">str</span> == NULL)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'.'</span>)
        {
            <span class="keyword">str</span>++;
            <span class="comment">//根据题目要求是否允许"32."这样的数据</span>
            <span class="comment">//if(*str == '\0')</span>
            <span class="comment">//    return false;</span>
            scanDigits(<span class="keyword">str</span>);
        }
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'e'</span> || *<span class="keyword">str</span> == <span class="string">'E'</span>)
            <span class="keyword">str</span>++;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'+'</span> || *<span class="keyword">str</span> == <span class="string">'-'</span>)
            <span class="keyword">str</span>++;
        scanDigits(<span class="keyword">str</span>);
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">if</span>(*<span class="keyword">str</span> == <span class="string">'\0'</span>)
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">void</span> scanDigits(<span class="keyword">char</span> *(&amp;<span class="keyword">str</span>))
    {
        <span class="keyword">while</span>(*<span class="keyword">str</span> != <span class="string">'\0'</span> &amp;&amp; *<span class="keyword">str</span> &gt;= <span class="string">'0'</span> &amp;&amp; *<span class="keyword">str</span> &lt;= <span class="string">'9'</span>)
            <span class="keyword">str</span>++;
    }
};
</code></pre><h3 id="剑指offer55_字符流中第一个不重复的字符">剑指offer55 字符流中第一个不重复的字符</h3><p>问题描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>解法：字符只有256个，所以可以使用<code>int dict[256]</code>数组来记录所有字符出现的情况。0表示未出现过，-1表示出现过大于1次，&gt;0时dict[i]表示字符i第一次出现的index</p>
<p>注意点：<br>通过遍历dict[26]找到minIndex找到<strong>第一次出现</strong>的字符</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>
</span>{
<span class="keyword">public</span>:
      <span class="comment">//Insert one char from stringstream</span>
    <span class="keyword">void</span> Insert(<span class="keyword">char</span> ch)
    {
        <span class="keyword">if</span>(dict[ch] == <span class="number">0</span>) <span class="comment">//没出现过</span>
            dict[ch] = <span class="keyword">index</span>;
        <span class="keyword">else</span> <span class="comment">//出现过</span>
            dict[ch] = -<span class="number">1</span>;
        <span class="keyword">index</span>++;
    }
      <span class="comment">//return the first appearence once char in current stringstream</span>
    <span class="keyword">char</span> FirstAppearingOnce()
    {
        <span class="keyword">char</span> ans=<span class="string">'#'</span>;
        <span class="keyword">int</span> minIndex = INT_MAX;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
        {
            <span class="keyword">if</span>(dict[i] &gt; <span class="number">0</span> &amp;&amp; dict[i] &lt; minIndex)
            {
                ans = i;
                minIndex = dict[i];
            }
        }
        <span class="keyword">return</span> ans;
    }

    Solution()
    {
        <span class="keyword">index</span> = <span class="number">1</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)
            dict[i] = <span class="number">0</span>;
    }
<span class="keyword">private</span>:
    <span class="keyword">int</span> dict[<span class="number">256</span>];
    <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">1</span>;
};
</code></pre><h3 id="剑指offer42_反转单词顺序_VS_左旋字符串">剑指offer42 反转单词顺序 VS 左旋字符串</h3><p>反转字符串函数：</p>
<pre><code>void reverseString(<span class="built_in">string</span> &amp;str, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        char temp = str[<span class="built_in">left</span>];
        str[<span class="built_in">left</span>] = str[<span class="built_in">right</span>];
        str[<span class="built_in">right</span>] = temp;
        <span class="built_in">left</span>++;
        <span class="built_in">right</span>--;
    }
}
</code></pre><h4 id="反转单词顺序">反转单词顺序</h4><p>问题描述：JOBDU最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>解法：先反转每一个单词，再反转整句</p>
<p>注意点：</p>
<ol>
<li>功能测试：”student. a am I”</li>
<li>特殊测试用例”aaa “,” aaa”</li>
</ol>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string ReverseSentence(string <span class="built_in">str</span>) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;
        <span class="keyword">while</span>(right &lt; <span class="built_in">str</span>.<span class="built_in">size</span>())
        {
            <span class="keyword">while</span>(<span class="built_in">str</span>[left] == <span class="string">' '</span>)
            {
                left++;
                right++;
            }
            <span class="comment">//应对用例"aa "</span>
            <span class="keyword">if</span>(left &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>()) 
                <span class="keyword">break</span>;
            <span class="keyword">while</span>(<span class="built_in">str</span>[right] != <span class="string">' '</span> &amp;&amp; <span class="built_in">str</span>[right] != <span class="string">'\0'</span>)
                right++;
            reverseString(<span class="built_in">str</span>,left,right-<span class="number">1</span>);
            left = right;
        }
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre><h4 id="左旋字符串">左旋字符串</h4><p>问题描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>解法：先反转3分割的两部分，再旋转这个字符串</p>
<pre><code>class Solution {
<span class="keyword">public</span>:
    string LeftRotateString(string <span class="built_in">str</span>, <span class="built_in">int</span> n) {
        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        <span class="keyword">if</span>(n &gt;= <span class="built_in">str</span>.<span class="built_in">size</span>() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">str</span>;
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, n - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, n, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        reverseString(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">str</span>.<span class="built_in">size</span>() - <span class="number">1</span>);
        <span class="keyword">return</span> <span class="built_in">str</span>;
    }

    <span class="keyword">void</span> reverseString(string &amp;<span class="built_in">str</span>,<span class="built_in">int</span> left,<span class="built_in">int</span> right)
    {
        <span class="keyword">while</span>(left &lt; right)
        {
            <span class="built_in">char</span> temp = <span class="built_in">str</span>[left];
            <span class="built_in">str</span>[left] = <span class="built_in">str</span>[right];
            <span class="built_in">str</span>[right] = temp;
            left++;
            right--;
        }
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="剑指offer4_替换空格">剑指offer4 替换空格</h3><p>问题描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>解法：扫描一]]>
    </summary>
    
      <category term="字符串" scheme="http://rudy-zhang.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <link href="http://rudy-zhang.me/2015/09/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://rudy-zhang.me/2015/09/24/排序算法总结/</id>
    <published>2015-09-24T13:56:00.000Z</published>
    <updated>2015-10-10T09:49:44.656Z</updated>
    <content type="html"><![CDATA[<h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>void insertSort(int a[], int N)
<span class="comment">{
    for(int i = 1; i &lt; N; i++)
    {
        int temp = a[i];
        int j;
        for(j = i; j &gt; 0 &amp;&amp; temp &lt; a[j-1]; j--)
            a[j] = a[j-1];
        a[j] = temp;
    }</span>
}
</code></pre><h3 id="希尔排序">希尔排序</h3><p>原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<blockquote>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> incre = N / <span class="number">2</span>; incre &gt; <span class="number">0</span>; incre /= <span class="number">2</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = incre; i &lt; N; i++)
        {
            <span class="keyword">int</span> temp = a[i];
            <span class="keyword">int</span> j;
            <span class="keyword">for</span>(j = i; j &gt;= incre &amp;&amp; temp &lt; a[j - incre]; j -= incre)
                a[j] = a[j - incre];
            a[j] = temp;
        }
    }
}
</code></pre><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。</p>
<pre><code>void bubbleSort(int <span class="literal">a</span>[], int N)
{
    for(int i = <span class="number">0</span><span class="comment">; i &lt; N; i++)</span>
    {
        for(int j = i<span class="comment">; j &lt; N - i - 1; j++)</span>
        {
            <span class="keyword">if</span>(<span class="literal">a</span>[j] &gt; <span class="literal">a</span>[j+<span class="number">1</span>])
            {
                int temp = <span class="literal">a</span>[j]<span class="comment">;</span>
                <span class="literal">a</span>[j] = <span class="literal">a</span>[j+<span class="number">1</span>]<span class="comment">;</span>
                <span class="literal">a</span>[j+<span class="number">1</span>] = temp<span class="comment">;</span>
            }
        }
    }
}
</code></pre><p>补充说明：使用didSwap=true/false可以避免重复的比较，使得最好情况的复杂度变为O(n)</p>
<h3 id="快速排序">快速排序</h3><p>原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>实现：</p>
<pre><code>void quickSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> temp = a[<span class="built_in">left</span>];
        <span class="built_in">int</span> i = <span class="built_in">left</span>, j = <span class="built_in">right</span>;
        <span class="keyword">while</span>(i &lt; j)
        {
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &lt;= a[j])
                j--;
            <span class="keyword">if</span>(i &lt; j)
                a[i++] = a[j];
            <span class="keyword">while</span>(i &lt; j &amp;&amp; temp &gt;= a[i])
                i++;
            <span class="keyword">if</span>(i &lt; j)
                a[j--] = a[i];
        }
        a[i] = temp;
        quickSortCore(a, <span class="built_in">left</span>, i-<span class="number">1</span>);
        quickSortCore(a, i+<span class="number">1</span>, <span class="built_in">right</span>);
    }

}

void quickSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    quickSortCore(a, <span class="number">0</span>, N-<span class="number">1</span>);
}
</code></pre><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p>原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span>
</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)
    {
        <span class="keyword">int</span> k = i;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)
        {
            <span class="keyword">if</span>(a[j] &lt; a[k])
                k = j;
        }
        <span class="keyword">int</span> temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
}
</code></pre><h3 id="堆排序">堆排序</h3><p>堆序性质： 堆分为大顶堆和小顶堆，满足<code>Key[i]&gt;=Key[2i+1]&amp;&amp;key&gt;=key[2i+2]</code>称为大顶堆，满足 <code>Key[i]&lt;=key[2i+1]&amp;&amp;Key[i]&lt;=key[2i+2]</code>称为小顶堆。</p>
<p>原理：利用大顶堆或小顶堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。如从小到大排序，建立大顶堆，堆顶元素与堆尾不断交换，同时缩小堆的范围，最终得到排序结果。</p>
<pre><code>void percDown(int a[], int i, int N)
<span class="comment">{
    int temp = a[i], child;
    for(; 2 * i + 1 &lt; N; i = child)
    {
        child = 2 * i + 1;
        if(child + 1 &lt; N &amp;&amp; a[child] &lt; a[child + 1])
            child++;
        if(temp &lt; a[child])
            a[i] = a[child];
        else
            break;
    }</span>
    a[i] = temp;
}

void heapSort(int a[], int N)
<span class="comment">{
    for(int i = N / 2; i &gt;= 0; i--)
        percDown(a, i, N);
    for(int i = N-1; i &gt; 0; i--)
    {
        int temp = a[i];
        a[i] = a[0];
        a[0] = temp;
        percDown(a, 0, i);
    }</span>
}
</code></pre><h2 id="归并排序">归并排序</h2><p>原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。</p>
<pre><code>void merge(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> lpos = <span class="built_in">left</span>, lend = <span class="built_in">mid</span>;
        <span class="built_in">int</span> rpos = <span class="built_in">mid</span> + <span class="number">1</span>, rend = <span class="built_in">right</span>;
        <span class="built_in">int</span> tpos = <span class="built_in">left</span>;
        <span class="keyword">while</span>(lpos &lt;= lend &amp;&amp; rpos &lt;= rend)
        {
            <span class="keyword">if</span>(a[lpos] &lt;= a[rpos])
                temp[tpos++] = a[lpos++];
            <span class="keyword">else</span>
                temp[tpos++] = a[rpos++];
        }
        <span class="keyword">while</span>(lpos &lt;= lend)
            temp[tpos++] = a[lpos++];
        <span class="keyword">while</span>(rpos &lt;= rend)
            temp[tpos++] = a[rpos++];
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">right</span>; i++)
            a[i] = temp[i];
    }
}
void mergeSortCore(<span class="built_in">int</span> a[], <span class="built_in">int</span> temp[], <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)
{
    <span class="keyword">if</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)
    {
        <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;
        mergeSortCore(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>);
        mergeSortCore(a, temp, <span class="built_in">mid</span>+<span class="number">1</span>, <span class="built_in">right</span>);
        merge(a, temp, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);
    }
}
void mergeSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> N)
{
    <span class="built_in">int</span> *temp = <span class="keyword">new</span> <span class="built_in">int</span>[N];
    mergeSortCore(a, temp, <span class="number">0</span>, N-<span class="number">1</span>);
    delete [] temp;
}
</code></pre><h2 id="各种排序算法的复杂度稳定性分析">各种排序算法的复杂度稳定性分析</h2><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">复杂度分析</th>
<th>稳定性</th>
<th>稳定性原因分析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">简单插入</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">平均接近nlogn,最好O(n),最坏O(n^2)</td>
<td>不稳定</td>
<td>增量分组，有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">交换排序</td>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">平均O(n^2),最好O(n),最坏O(n^2)</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">平均nlogn,最好nlogn,最坏O(n^2)</td>
<td>不稳定</td>
<td>有跨元素交换</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">直接选择</td>
<td style="text-align:left">平均O(n^2),最好O(n^2),最坏O(n^2)</td>
<td>不稳定</td>
<td>5 8 5 2</td>
</tr>
<tr>
<td style="text-align:left">———-</td>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">平均,最好,最坏nlogn</td>
<td>不稳定</td>
<td>3 2 3 2</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">平均,最好,最坏nlogn，有O(n)空间复杂度</td>
<td>稳定</td>
<td>没有跨元素交换</td>
</tr>
</tbody>
</table>
<h2 id="扩展问题">扩展问题</h2><ul>
<li>单链表可以做快速排序吗？为什么？</li>
</ul>
<p>可以。快速排序的核心函数partition，选择某个元素为枢纽元x(通常是第一个)，一遍扫描之后使得比x小的在枢纽元左边，比x大的在枢纽元的右边。使用链表时，x指向链表头(枢纽元)，扫描这个链表，小元素拼在链表头，大元素拼在链表尾部，从而完成一次partition函数的流程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p>原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。</p>
<pre><code>vo]]>
    </summary>
    
      <category term="排序" scheme="http://rudy-zhang.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="找工作总结" scheme="http://rudy-zhang.me/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective C++ 读书笔记]]></title>
    <link href="http://rudy-zhang.me/2015/08/21/effectiveCPP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://rudy-zhang.me/2015/08/21/effectiveCPP读书笔记/</id>
    <published>2015-08-20T23:23:33.000Z</published>
    <updated>2015-08-30T07:56:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C++ 使用模板编程</li>
<li>STL</li>
</ul>
<p>每一个部分都有各自的规约</p>
<h2 id="条款2，_尽量以const，enum，inline替换#define">条款2， 尽量以const，enum，inline替换#define</h2><ul>
<li>#define只有替换功能，在预处理阶段完成，没有<strong>类型检查</strong>，也没有封装性</li>
<li>使用const替代变量定义，inline替代函数定义</li>
<li>预处理器中，#include必不可少，#ifdef，#else可以用来进行控制编译</li>
</ul>
<h2 id="条款3，尽可能使用const">条款3，尽可能使用const</h2><p>只要是事实，就把它说出来。只要是const就要声明为const类型。</p>
<ul>
<li>const修饰变量<br>const char <em>p = greeting等价于char const </em>p = greeting<br>char * const p = greeting 指针不可更改指向对象</li>
<li>const修饰函数，是最有威力的应用</li>
</ul>
<p>(1) const 返回值</p>
<p>(2) const 函数参数，使用最多</p>
<p>(3) const 成员函数，表明这个函数不能修改任何成员变量（static变量可以修改），也不能调用任何非const成员</p>
<p>补充，<br>volidate int a，告诉编译器这个值可能被未知因素修改，每次都要从内存中重新读取<br>mutable int a，可以突破const成员函数限制，在函数中被修改</p>
<h2 id="条款4，确定对象被使用前已先被初始化">条款4，确定对象被使用前已先被初始化</h2><ul>
<li><p>成员初始化应该在构造函数之前，意味着要使用<strong>成员初始化列表</strong>进行成员变量的初始化<br>说明：成员变量总是以声明的次序被初始化</p>
</li>
<li><p>对于static变量，使用Singleton+inline，保证在对象使用前初始化</p>
</li>
</ul>
<h2 id="条款5，了解C++默默编写并调用了哪些函数">条款5，了解C++默默编写并调用了哪些函数</h2><p>构造函数，拷贝构造函数，赋值函数，析构函数</p>
<h2 id="条款6，若不想使用编译器自动生成的函数，就该明确拒绝">条款6，若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul>
<li>如果某些对象不可复制（不能使用copy constructor）<br>不是很安全的做法：把拷贝构造函数声明为private<br>更好的做法：写一个<strong>UnCopyable基类</strong>，copy constructor声明为private</li>
</ul>
<h2 id="条款7，为多态基类声明virtual析构函数">条款7，为多态基类声明virtual析构函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="title">A</span></span>{}
A *b=<span class="keyword">new</span> B()
<span class="keyword">delete</span> b
</code></pre><p>因为b是A类型的指针，所以会导致局部销毁（只有A的部分被销毁）</p>
<p>原则：</p>
<ul>
<li><strong>企图作为（多态的）base class的类理论上都应该有virtual函数</strong>，否则不应该作为base class（虚指针会额外增加空间）</li>
<li>任何带有virtual 函数的类都应该把析构函数声明为virtual<br>不要试图继承任何STL容器，因为他们没有virtual的析构函数</li>
</ul>
<h2 id="条款8，别让异常逃离析构函数">条款8，别让异常逃离析构函数</h2><ul>
<li>析构函数不能抛出异常，否则会导致不明行为。</li>
<li>析构函数应该吞下这个异常，防止传播</li>
<li><strong>调用一个自己的函数，使得用户有机会来处理这个异常</strong>。 </li>
</ul>
<h2 id="条款9，_绝不要在构造或者析构过程中调用virtual函数">条款9， 绝不要在构造或者析构过程中调用virtual函数</h2><ul>
<li><p>构造过程</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:     
    A(){
         virtual <span class="function"><span class="title">fun</span><span class="params">()</span></span>
    }
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{}</span></span>
B b;
</code></pre></li>
</ul>
<p>构造B-&gt;构造A-&gt;调用fun(),这时B还没构造完（被编译器看成A对象），导致virtual 函数不会下降到子类执行。</p>
<ul>
<li>析构过程<br>析构B-&gt;析构A-&gt;调用fun()，这时B已经被析构掉了，同样virtual函数不会下降，得不到想要的结果。</li>
</ul>
<h2 id="条款10，令operator=_返回一个reference_to_*this">条款10，令operator= 返回一个reference to *this</h2><p>为了保证连续运算如：A=B=C 相当于A = (B = C)<br>返回一个引用，不会调用copy constructor<br>对于+=同样适用</p>
<h2 id="条款11，在operator=_中处理自我赋值">条款11，在operator= 中处理自我赋值</h2><p>判断一下，if (this == &amp;rhs) return *this</p>
<h2 id="条款12，复制对象时勿忘其每一个成分">条款12，复制对象时勿忘其每一个成分</h2><p>可能出现的问题</p>
<p>（1）对象中的非内置类型不能得到赋值</p>
<p>（2）对象从父类继承而来的变量不能得到赋值</p>
<ul>
<li>赋值所有local成员（内置类型，对象）</li>
<li>调用所有base class中的适当的copy constructor</li>
</ul>
<h2 id="条款13，以对象管理资源">条款13，以对象管理资源</h2><p>C++申请释放的资源：堆内存（最常用），文件，互斥锁，数据库连接等。一旦申请资源，就必须释放，否则就会造成内存泄露。</p>
<p>以对象管理资源相当于，使用一个类（RAII类）封装这个资源，在构造时初始化，在析构时释放。声明这个对象时使用栈内存声明。</p>
<p>常用：</p>
<p><code>auto_ptr</code> ,封装对象，重写了指针行为，看起来像一个指针。只能指向一个对象。复制或者赋值，会删除原来的指针。</p>
<p><code>shared_ptr</code>，类似于auto_ptr，不过允许多个指针指向同一个对象，内部提供引用计数。<br>这两个是最常见的RAII类，在构造时初始化，析构时delete。（注意不能<code>auto_ptr</code>(new std::string[10])数组对象）</p>
<h2 id="条款14，在资源管理类中小心copying行为">条款14，在资源管理类中小心copying行为</h2><p>类似于<code>auto_ptr</code>或者<code>shared_ptr</code>的处理方式，对于复制。可以：</p>
<ul>
<li>禁止复制</li>
<li>引用计数，类似于shared_ptr</li>
</ul>
<h2 id="条款15，在资源管理类中提供对原始资源的访问">条款15，在资源管理类中提供对原始资源的访问</h2><p>隐式：如<code>auto_ptr</code>重写了指针行为，*ptr,<code>ptr-&gt;</code>使得这个变量看起来像一个指针。从而可以访问封装的资源</p>
<p>显示：提供get()函数返回资源</p>
<h2 id="条款16，使用new和delete时要采用相同的形式">条款16，使用new和delete时要采用相同的形式</h2><p>A *a=new A() ,释放时 使用delete a</p>
<p>int *a=new a[100],释放时使用delete []a</p>
<h2 id="条款17，以独立语句将newed对象置入智能指针">条款17，以独立语句将newed对象置入智能指针</h2><pre><code>std::tr1::shared_ptr&lt;Widget&gt; <span class="function"><span class="title">pw</span><span class="params">(new Widget)</span></span>
<span class="function"><span class="title">processWidget</span><span class="params">(pwd, priority()</span></span>)
</code></pre><p>使用单独语句，不要放到一起可能会造成编译先后导致指针丢失。<br>其实不是很明白这点</p>
<h2 id="条款18，让接口容易被使用，不易被误用">条款18，让接口容易被使用，不易被误用</h2><ul>
<li><p>导入新类型</p>
<pre><code><span class="built_in">Date</span>(<span class="built_in">int</span> <span class="built_in">month</span>, <span class="built_in">int</span> <span class="built_in">day</span>, <span class="built_in">int</span> <span class="built_in">year</span>)
</code></pre></li>
</ul>
<p>多个参数，使用Month，Day，Year类型，可以预防接口被误用</p>
<ul>
<li>接口一致性</li>
</ul>
<p>如:stl每个容器都有size()方法</p>
<h2 id="条款19，设计class犹如设计type">条款19，设计class犹如设计type</h2><p>设计一个类时需要考虑很多问题：</p>
<ol>
<li>创建和销毁</li>
<li>初始化（初始化列表），拷贝构造函数</li>
<li>pass by value &amp;&amp; pass by reference</li>
<li>继承关系</li>
<li>类型转换</li>
<li>操作符重载</li>
<li>标准函数驳回（private copy constructor）</li>
<li>public private</li>
<li>效率，异常</li>
<li>不够一般化，太过一般化</li>
<li>是否真的需要这个类型</li>
</ol>
<h2 id="条款20，_宁以pass_by_reference_to_const_替换_pass_by_value">条款20， 宁以pass by reference to const 替换 pass by value</h2><ul>
<li>区别</li>
</ul>
<p>pass by value:</p>
<p>要调用copy constructor，可能是费时的操作</p>
<p>pass by reference to const:</p>
<p>const Student &amp;s，const保证变量在函数内不会被修改</p>
<ul>
<li><p>pass by value可能导致多态失效</p>
<pre><code><span class="keyword">void</span> printNameAndDisplay（Window w）
</code></pre></li>
</ul>
<p>传入子类对象，不能实现多态</p>
<ul>
<li>在编译器底层，reference是通过指针来实现的</li>
</ul>
<h2 id="条款21，必须返回对象时，别妄想返回其reference">条款21，必须返回对象时，别妄想返回其reference</h2><pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator* (<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs)
</code></pre><p>如果返回reference</p>
<ul>
<li>返回local stack的对象（Rational r），则函数退出时，这个对象已经被销毁了</li>
<li>返回heap-allocate对象，会造成何时delete的问题。</li>
<li>返回static对象，if(a<em>b == c</em>d),导致一个static对象不够用的问题</li>
</ul>
<p>原则，必须在返回reference和object作出一个选择，程序员的工作就是选出正确的那个</p>
<h2 id="条款22，将变量声明为private">条款22，将变量声明为private</h2><ul>
<li>public接口内全部都是函数，可以产生用户使用这个类时，良好的一致性</li>
<li>private parameter可以产生封装的效果，封装使得变更更加容易</li>
<li>假如有一个public变量，如果取消它，所有使用它的客户代码都会被破坏<br>假如有一个protect变量，如果取笑它，所有使用它的derived class都会被破坏<br>所以protect并不比public更具有封装性</li>
</ul>
<h2 id="条款23，宁以non-member、non-friend替换member函数">条款23，宁以non-member、non-friend替换member函数</h2><ul>
<li>多个操作具有先后顺序，应该把他们绑定到一起</li>
<li>封装-&gt;客户端难修改-&gt;更多弹性去改变</li>
<li>non-member（non-friend）函数VSmember函数</li>
</ul>
<p>non-member函数不能访问private成分，提供更大的封装性</p>
<h2 id="条款24，若所有参数皆需类型转换，请为此采用non-member函数">条款24，若所有参数皆需类型转换，请为此采用non-member函数</h2><p>实现有理数类Rational，乘法的操作符重载<br>开始可能会向使用成员函数的写法 </p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp; rhs) <span class="keyword">const</span>
</code></pre><p>但是希望完成乘法交换律</p>
<pre><code><span class="type">Rational</span> r
<span class="type">Rational</span> <span class="literal">result</span> = <span class="number">2</span> * r
</code></pre><p>需要对2进行隐式类型转换，方法</p>
<pre><code><span class="keyword">const</span> <span class="built_in">Rational</span> operator*(<span class="keyword">const</span> <span class="built_in">Rational</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">Rational</span> &amp;rhs) 
</code></pre><p>使用non-member函数。</p>
<p>不是很明白</p>
<h2 id="条款25，考虑写出一个不抛出异常的swap函数">条款25，考虑写出一个不抛出异常的swap函数</h2><p>std::swap(T&amp; a, T&amp; b)可以对两个对象进行交换</p>
<p>如果这样做的效率不高，可以考虑自己写一个不会抛出异常的swap成员函数</p>
<p>例如：stl 容器中就有很多swap函数，只交换指针，而不会复制对象。</p>
<ol>
<li>自行实现这样一个swap成员函数(可以使用std::swap调换指针)</li>
<li>在命名空间内提供一个swap<widget>(Widget &amp;a,Widget &amp;b)去实现一个非成员函数来调用前者。</widget></li>
</ol>
<h2 id="条款26，尽可能延后变量定义式的出现时间">条款26，尽可能延后变量定义式的出现时间</h2><p>对变量进行定义，意味着承受构造的成本。</p>
<p>原则：应该延后变量定义到使用前的一刻为止。</p>
<h2 id="条款27，尽量少做转型动作">条款27，尽量少做转型动作</h2><p>C风格的转型</p>
<pre><code><span class="list">(<span class="keyword">int</span>)</span><span class="number">2.1</span>
int<span class="list">(<span class="number">2.1</span>)</span>
</code></pre><p>C++的新式转型：</p>
<ul>
<li><code>const_cast&lt;T&gt;(expression)</code> 将对象的常量性移除</li>
<li><code>dynamic_cast&lt;T&gt;(expression)</code> 主要用来进行安全向下转型<br>例如：只有基类可以使用，但是想调用子类的函数。尝试使用多态来代替。</li>
<li><code>static_cast&lt;T&gt;(expression)</code> 主要用来强制类型转换<br>例如：<code>static_cast&lt;int&gt;(2.1)</code><br>尽量使用C++风格的转型</li>
</ul>
<h2 id="条款28，避免返回handles指向对象内部成分">条款28，避免返回handles指向对象内部成分</h2><pre><code><span class="keyword">class</span> <span class="title">A</span>{
<span class="keyword">public</span>：
     <span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span>;
}
<span class="keyword">class</span> <span class="title">B</span>{
<span class="keyword">private</span>:
     A *a
}
</code></pre><p>如果在B类中提供<code>A&amp;</code>的返回（假设为rt），那么用户可以调用<code>rt.func()</code>修改B中的private成员了。<br>这是一种放松封装的行为。</p>
<h2 id="条款29，为“异常安全”而努力是值得的">条款29，为“异常安全”而努力是值得的</h2><p>异常安全的函数提供以下三个保证之一（从弱到强）：</p>
<ul>
<li>基本承诺：如果抛出异常，程序内的任何事物仍然保持在有效状态下</li>
<li>强烈保证：函数调用成功，则完全成功。函数调用失败，则程序回复到调用之前的状态</li>
<li>nothrow：保证绝对不抛出异常。（通常完全使用内置类型的操作，提供不抛出异常的保证）<br>一个软件系统，要么具备异常安全性，要么不具备。只提供部分异常安全性函数，不能叫做具备异常安全性的系统。<br>以对象管理资源，是一种很好的防止内存泄露，保证异常安全性的方法。</li>
</ul>
<h2 id="条款30，透彻了解inlining的里里外外">条款30，透彻了解inlining的里里外外</h2><ul>
<li>inline函数意味着对这个函数的每一次调用，使用函数本体替换</li>
</ul>
<p>好处：减少调用成本</p>
<p>坏处：增加代码体积</p>
<ul>
<li>inline函数适合小型被频繁调用的函数</li>
</ul>
<p>函数内部有for循环不适合inline，因为本身的开销已经够大，减少调用的开销意义不大。</p>
<ul>
<li>inline只是一个向编译器发出的申请，编译器可以忽略它。</li>
</ul>
<p>如编译器拒绝复杂函数inline(带有递归，循环),virtual函数也会使inline落空。</p>
<h2 id="条款31，将文件间的编译依存关系降到最低">条款31，将文件间的编译依存关系降到最低</h2><p>方法1，使用Handle class</p>
<p>增加一个实现类去真正实现类的功能，原来的类只维护一个指向实现类的指针</p>
<p>方法2，使用Interface class</p>
<p>基类是虚基类，不包括任何成员变量。</p>
<h2 id="条款32，确定你的public继承是is-a的关系">条款32，确定你的public继承是is-a的关系</h2><p>如题</p>
<h2 id="条款33，避免遮掩继承而来的名称">条款33，避免遮掩继承而来的名称</h2><p>假如：Derived:Base</p>
<p>当编译器通过函数名称去找相应函数，会先从Derived类作用域找，然后再从Base类的作用域找<br>当使用函数重载的时候就可能出现问题。</p>
<p>使用using Base::func可以避免这种情况。 </p>
<h2 id="条款34，区分接口继承和实现继承">条款34，区分接口继承和实现继承</h2><ul>
<li>对于non-virtual函数的继承</li>
</ul>
<p>意味着，子类必须有和父类一样的实现</p>
<ul>
<li>对于virtual</li>
</ul>
<p>（1）pure-virtual, 只继承接口，意味着每个子类的行为都很有可能不一样</p>
<p>（2）imprure-virtual， 提供缺省的实现，意味着有一些子类的行为可能一样</p>
<p>可以使用pure-virtual+缺省行为分离(另外写一个函数)的方法，解决有可能子类在不知情的情况下继承了并不需要的缺省的实现。 </p>
<h2 id="条款35，考虑virtual函数以外的其他选择">条款35，考虑virtual函数以外的其他选择</h2><ul>
<li><p>NVI Non-virtual Interface<br>使用public non-virtual 函数调用private virtual函数(做一下修饰而已)</p>
</li>
<li><p>使用函数指针</p>
</li>
<li><p>使用tr1::function封装函数指针，代替函数指针的行为</p>
</li>
<li><p>使用strategy设计模式</p>
</li>
</ul>
<p>将想要virtual的行为封装成一个类(Calculator)，在类内部进行多态计算，通过传入的对象指针来判断。</p>
<h2 id="条款36，绝不重新定义继承而来的non-virtual函数">条款36，绝不重新定义继承而来的non-virtual函数</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">B</span>:<span class="typename">A{</span></span>
<span class="keyword">public</span>:
     void <span class="function"><span class="title">fun</span><span class="params">()</span></span>
}
A *ptA=new B()
B *ptB=new B()
</code></pre><p>ptA-&gt;fun()调用A中的fun<br>ptB-&gt;fun()调用B中的fun<br>因为non-virtual函数不能进行动态绑定，调用函数只跟指针类型有关，所以</p>
<ol>
<li>不要重写父类的non-virtual函数</li>
<li>父类的non-virtual函数意味着，所有子类的实现都是这样</li>
</ol>
<h2 id="条款37，绝不重新定义进程而来的缺省参数值">条款37，绝不重新定义进程而来的缺省参数值</h2><p>缺省参数都是静态绑定的，即使是在virtual的函数中</p>
<h2 id="条款38，复合（组合）是has-a的关系">条款38，复合（组合）是has-a的关系</h2><h2 id="条款39，明智而审慎地使用private继承">条款39，明智而审慎地使用private继承</h2><p>private继承意味着所有父类的成员在子类中都变为private，</p>
<p>好处：可以让基类部分最优化，减少尺寸。</p>
<h2 id="条款40，明智而审慎地使用多重继承">条款40，明智而审慎地使用多重继承</h2><ul>
<li>一个class继承自多个base class，那么父类成分有相同函数，就需要显示指定。</li>
<li>对于钻石型继承，B:A,C:A,D:B,D:C，需要指定虚继承，来避免重复继承A中的成分</li>
<li>虚继承需要编译器做很多工作，要付出一定成本，一般不用。</li>
<li>如果有单一继承可以满足需求，一般这个方案一定比多重继承要好。</li>
</ul>
<h2 id="条款41，了解隐式接口和编译器多态">条款41，了解隐式接口和编译器多态</h2><ul>
<li><p>运行时多态，通过虚指针和虚函数实现</p>
</li>
<li><p>编译时多态</p>
</li>
</ul>
<p>(1) 函数重载，相同函数名不同参数列表</p>
<p>(2) 在模板特化的时候，根据类型生成具体的函数</p>
<h2 id="条款42，了解typename的双重意义">条款42，了解typename的双重意义</h2><pre><code><span class="keyword">template</span>&lt; class T&gt; class <span class="type">Widget</span>;
<span class="keyword">template</span>&lt;typename T&gt;class <span class="type">Widget</span>;
</code></pre><p>并没有什么不同</p>
<p>当使用嵌套从属名称，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename C&gt;
typename C::const_iterator iter(container.begin())
</code></pre><p>const_iterator是依赖于C的名称，这时候必须用typename</p>
<h2 id="条款43，学习处理模板化基类内的名称">条款43，学习处理模板化基类内的名称</h2><p>对于模板C++的继承，由于基类模板可能被特化，特化使得基类内的成员不确定，C++会拒绝从模板化基类中寻找继承而来的名称</p>
<p>解决办法：</p>
<ol>
<li>在使用base class之前使用this-&gt;</li>
<li>使用using</li>
</ol>
<h2 id="条款44，将与参数无关的代码抽离templates">条款44，将与参数无关的代码抽离templates</h2><p>使用带参template可能会引起代码膨胀，如：</p>
<pre><code><span class="keyword">template</span>&lt;typename T,std:size_t n&gt;
</code></pre><p>解决办法：<br>使用模板父类去处理由于size_t而造成的代码膨胀的问题</p>
<h2 id="条款45，运用成员函数模板接受所有兼容类型的参数">条款45，运用成员函数模板接受所有兼容类型的参数</h2><ul>
<li>智能指针是使用模板实现的，那如果我们要智能指针之间（具有继承关系的）能够相互转化，赋值，解决办法：</li>
<li>使用成员函数模板，对兼容的类型进行构造和赋值</li>
</ul>
<h2 id="条款46，需要类型转换时请为模版定义非成员函数">条款46，需要类型转换时请为模版定义非成员函数</h2><pre><code><span class="type">Rational</span>&lt;<span class="type">int</span>&gt; a(<span class="number">1</span>,<span class="number">2</span>);
<span class="type">Rational</span>&lt;<span class="type">int</span>&gt; <span class="literal">result</span> = a*<span class="number">2</span>; // <span class="type">Error</span>
</code></pre><p>模板化实例，不进行隐式类型转换，使用friend方法。</p>
<h2 id="条款47，请使用traits_classes表现类型信息">条款47，请使用traits classes表现类型信息</h2><p>引用：</p>
<blockquote>
<p>traits class是个类模板，在不修改一个实体（通常是数据类型或常量）的前提下，把属性和方法关联到一个编译时的实体。在c++中的具体实现方式是：首先定义一个类模板，然后进行显式特化或进行相关类型的部分特化。<br>我的理解是：traits是服务于泛型编程的，其目的是让模板更加通用，同时把一些细节向普通的模板用户隐藏起来。当用不同的类型去实例化一个模板时，不可避免有些类型会存在一些与众不同的属性，若考虑这些特性的话，可能会导致形成的模板不够“泛型”或是过于繁琐，而traits的作用是把这些特殊属性隐藏起来，从而实现让模板更加通用。</p>
</blockquote>
<h2 id="条款48，认识template元编程">条款48，认识template元编程</h2><ul>
<li>模版元编程有两个效力：第一，它让某些事情更容易；第二，可将工作从运行期转移到编译期。</li>
<li>引用：<blockquote>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。</p>
</blockquote>
</li>
</ul>
<h2 id="条款49，了解new_handler的行为">条款49，了解new_handler的行为</h2><p>new_handler 的意思就是说，当使用operator new 无法分配内存时，转交给用户，用户来做一些事情。</p>
<h2 id="条款50，了解new和delete的合理替换时机">条款50，了解new和delete的合理替换时机</h2><p>有时候，我们替换掉编译器提供的new或者delete。重写operator new。三个常见理由：</p>
<ol>
<li>用来检测运用上的错误，超额分配一些内存，再额外的空间放置一些内存；</li>
<li>为了强化效能，编译器提供的new/delete是通用的，通用就意味着冗余和效率低下，为什么？这个很好理解，因为他要支持很多情况下，也必须考虑很多情况。我们重写new/delete，也就是说，对于特定情况，给出特定的实现。</li>
<li>为了收集使用上的统计数据。</li>
</ol>
<h2 id="条款51，编写new和delete时需固守常规">条款51，编写new和delete时需固守常规</h2><p>自定义new/delete的时候，需要遵守一些规则。</p>
<ol>
<li>循环申请，直到成功或者抛出异常</li>
<li>class专属版本处理，分配大小与class大小不一致的错误。</li>
<li>delete的时候，判断是否为null。</li>
</ol>
<h2 id="条款52，写了placement_new也要写placement_delete">条款52，写了placement new也要写placement delete</h2><h2 id="条款53，不要轻忽编译器的警告">条款53，不要轻忽编译器的警告</h2><h2 id="条款54，让自己熟悉包括TR1在内的标准程序库">条款54，让自己熟悉包括TR1在内的标准程序库</h2><p>C++11（原名C++0x）于2011年8月12日公布。<br>TR1是一份文档，由编译器实现，在std::tr1命名空间下<br>C++11纳入了大部分TR1的内容</p>
<h2 id="条款55，让自己熟悉Boost">条款55，让自己熟悉Boost</h2><p>Boost是一个社区，提供很多程序库，作为新的C++标准的试验场。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="条款1，视C++为一个语言联邦">条款1，视C++为一个语言联邦</h2><p>可以把C++看成四个组成部分：</p>
<ul>
<li>C语言的部分 </li>
<li>Object Oriented C++ 继承封装多态</li>
<li>Template C]]>
    </summary>
    
      <category term="C++" scheme="http://rudy-zhang.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://rudy-zhang.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从图灵到图灵测试再到图灵停机]]></title>
    <link href="http://rudy-zhang.me/2015/05/31/%E4%BB%8E%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95%E5%88%B0%E5%9B%BE%E7%81%B5%E5%81%9C%E6%9C%BA/"/>
    <id>http://rudy-zhang.me/2015/05/31/从图灵测试到图灵停机/</id>
    <published>2015-05-31T07:23:33.000Z</published>
    <updated>2015-05-31T08:02:36.000Z</updated>
    <content type="html"><![CDATA[<p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮助盟军破解德军密码系统Enigma的故事。图灵，这个计算机之父，影响着计算机技术发展的方方面面，计算机的最高奖图灵奖也是以他的名字命名的，没办法人家是祖师爷呀。</p>
<h2 id="图灵生平">图灵生平</h2><blockquote>
<p>阿兰·麦席森·图灵（Alan Mathison Turing），生于1912年6月23日，逝于1954年6月7日 ，被誉为“<strong>计算机科学之父</strong>”和“人工智能之父”。图灵和同事破译的情报，在盟军诺曼底登陆等重大军事行动中发挥了重要作用，图灵因此在1946年获得“不列颠帝国勋章”。历史学家认为，他让二战提早了2年结束，至少拯救了2000万人的生命 。<br>计算机逻辑的奠基者，提出了“图灵机”和“图灵测试”等重要概念。美国计算机协会（ACM）1966年设立的以其名命名的“<strong>图灵奖</strong>”是计算机界最负盛名和最崇高的一个奖项，有“计算机界的诺贝尔奖”之称。</p>
<p>1912年6月23日出生于英国帕丁顿，1931年进入剑桥大学国王学院，师从著名数学家哈代，1938年在美国普林斯顿大学取得博士学位，二战爆发后返回剑桥，曾经协助军方破解德国的著名密码系统Enigma，帮助盟军取得了二战的胜利。</p>
<p>因图灵的同性恋倾向，他于1952年被起诉（这种行为在当时的英国仍属刑事犯罪）。 为了继续科研工作，他接受了治疗雌激素注射（ 化学阉割 ）代替牢狱之刑。 图灵于1954年6月7日去世（食用氰化物泡过的苹果中毒）， 勘验确定他的死亡是自杀。 英国女王伊丽莎白二世在2013年追授特赦。</p>
<p>阿兰·麦席森·图灵是一名世界级的长跑运动员。他的马拉松最好成绩是2小时46分3秒，比1948年奥林匹克运动会金牌成绩慢11分钟。1948年的一次跨国赛跑比赛中，他跑赢了同年奥运会银牌得主汤姆·理查兹（Tom Richards）。</p>
</blockquote>
<h2 id="图灵测试">图灵测试</h2><blockquote>
<p>如果一台机器能够与人类展开对话（通过电传设备）而不能被辨别出其机器身份，那么称这台机器具有智能。</p>
</blockquote>
<p>这也是《机械姬》这部电影讨论的核心所在。善良单纯的天才程序员被大Boss天才坑蒙拐骗参加设计的图灵测试，机器人ava通过利用程序员的同情心（程序员多么可怜），诱骗他完成了逃离实验基地的任务。最终是否通过测试不是由程序员判断的，而是由机器人能否骗到程序员决定的。多么精巧的设计！一个高智商的程序员，明知道很有可能被骗，但还是被骗了，这无疑是真正的人工智能。</p>
<p>最后实验失控，大Boss被AI杀死（预示着人类要灭亡么？），AI进入到人群之中。</p>
<p>这是一部好电影，但这篇文章不是一篇影评，就不赘述电影的细节了。</p>
<h2 id="图灵停机问题">图灵停机问题</h2><p>突然想起来本科离散数学提到的一个很有意思的问题，图灵停机问题（The Halting Problem））。描述如下：</p>
<blockquote>
<p>不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。</p>
</blockquote>
<p>精妙的是这个问题的证明过程。通过反证法可以证明这个命题。</p>
<p>假设我们某一天真做出了这么一个极度聪明的万能算法（就叫God_algo吧），你只要给它一段程序（二进制描述），再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束（停机），我们来编写一下我们的这个算法吧：</p>
<pre><code>bool God_algo(<span class="keyword">char</span>* <span class="keyword">program</span>, <span class="keyword">char</span>* <span class="keyword">input</span>)
{
    <span class="keyword">if</span>(&lt;<span class="keyword">program</span>&gt; halts <span class="keyword">on</span> &lt;<span class="keyword">input</span>&gt;)
        <span class="keyword">return</span> true;
    <span class="keyword">return</span> false;
}
</code></pre><p>这里我们假设if的判断语句里面是你天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在，我们从这个God_algo出发导出一个新的算法：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">Satan_algo</span><span class="params">(<span class="keyword">char</span>* program)</span>
</span>{
    <span class="keyword">if</span>( God_algo(program, program) )
    {
           <span class="keyword">while</span>(<span class="number">1</span>);        <span class="comment">// loop forever!</span>
           <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// can never get here!</span>
    }
    <span class="keyword">else</span>
       <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p>
<pre><code>Satan_algo<span class="list">(<span class="keyword">Satan_algo</span>)</span><span class="comment">;</span>
</code></pre><p>我们来分析一下这行简单的调用：</p>
<ol>
<li><p>Satan_algo(Satan_algo)这个调用要么能够运行结束返回（停机），要么不能返回（loop forever）。</p>
</li>
<li><p>如果它能够结束，那么Santa_algo算法里面的那个if判断就会成立（因为God_algo(Santa_algo,Santa_algo)将会返回true），从而程序便进入那个包含一个无穷循环while(1);的if分支，于是这个Satan_algo(Satan_algo)调用便永远不会返回（结束）了。</p>
</li>
<li><p>如果不能结束（停机），则if判断就会失败，从而选择另一个if分支并返回true，即Satan_algo(Satan_algo)又能够返回（停机）。</p>
</li>
</ol>
<p>总之，我们有：</p>
<p>Satan_algo(Satan_algo)能够停机=&gt; 它不能停机</p>
<p>Satan_algo(Satan_algo)不能停机=&gt; 它能够停机</p>
<p>所以它停也不是，不停也不是，左右矛盾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天看了电影《机械姬》，讲述了由人类制造出了AI最终具有了通过图灵测试的能力，故事的核心在于判断一个机器人是否具真的具有人工智能。从一个理科生的角度来讲能够发现重重漏洞，但是电影还是不错的电影，引发了对人工智能的思考。</p>
<p>年初的《模仿游戏》讲述了图灵在二战时期帮]]>
    </summary>
    
      <category term="杂七杂八" scheme="http://rudy-zhang.me/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux命令sed和awk]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E5%91%BD%E4%BB%A4sed%E5%92%8Cawk/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux命令sed和awk/</id>
    <published>2015-05-25T23:39:28.000Z</published>
    <updated>2015-05-25T23:57:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p>
<h3 id="常见应用">常见应用</h3><ol>
<li>抽区域</li>
<li>匹配正则表达式</li>
<li>比较域</li>
<li>增加，附加，替换</li>
</ol>
<h3 id="执行过程">执行过程</h3><p>sed一次处理一行或多行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行或多行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向或写入命令存储输出。</p>
<h3 id="调用方式">调用方式</h3><ul>
<li>命令行输入</li>
</ul>
<p>sed [选项] ‘sed命令’ 输入文件</p>
<ul>
<li>使用sed脚本<br>sed [选项] –f sed脚本文件 输入文件</li>
</ul>
<h3 id="常用选项">常用选项</h3><p>-n：不打印，不写编辑行到标准输出，缺省情况下打印所有行[编辑/未编辑]p命令可以打印编辑行</p>
<p>-c：下一命令是编辑命令，使用多项编辑时加入此选项</p>
<p>-f： 调用sed脚本 sed –f sedScriptFile targetFile</p>
<p>-i：将修改附加到源文件上</p>
<h3 id="使用技巧">使用技巧</h3><p>重定向sed结果输出<br>$sed ‘sed-command’ inputfile &gt; outputfile</p>
<p>定位内容的方式</p>
<p><code>x</code> 行x</p>
<p><code>x,y</code> 行x到行y</p>
<p><code>/pattern/</code> 模式</p>
<p><code>/pattern/pattern/</code> 两个模式</p>
<p><code>/pattern/,x</code>     模式+行【在给定行号上查询模式】</p>
<p><code>X,y</code> /pattern/ 通过行号和模式查询匹配行</p>
<p><code>X,y!</code> 不包含指定行号</p>
<h3 id="基本的sed命令">基本的sed命令</h3><p>P 打印匹配行 print</p>
<p>= 打印匹配行行号</p>
<p>a\ 定位行号后附加新文本信息 append</p>
<p>i\ 定位行号后插入   insert</p>
<p>d 删除定位行   delete</p>
<p>c\ 用新文本替换定位文本   change</p>
<p>s 使用替换模式替换相应模式 </p>
<p>r 从另一个文件中读文本  read</p>
<p>w 写文本到一个文件   write</p>
<p>q 第一个模式匹配完成后退出或立即退出</p>
<p>{} 定位执行命令组</p>
<p>n 从另一个文件中读文本下一行，并附加在下一行</p>
<p>g 将模式2黏贴到/pattern n/</p>
<p>y 传送字符</p>
<h3 id="实例：">实例：</h3><ul>
<li>显示文本</li>
</ul>
<p><code>$sed -n &#39;1,4p&#39; file</code></p>
<p>显示1-4行</p>
<p><code>$sed -n &#39;4,/Str/p&#39;</code></p>
<p>显示第4行到匹配到Str的一行，/str/代表匹配到的一行</p>
<ul>
<li>插入修改文本</li>
</ul>
<p><code>$sed &#39;/str/a\ &quot;inserted line&quot;&#39; file</code></p>
<p>在满足条件的行后，插入内容</p>
<p><code>sed &#39;/str/i\ &quot;appended line&quot;&#39; file</code></p>
<p>在满足条件的行前插入内容</p>
<p><code>$sed &#39;3 c\ &quot;changed line&quot;&#39; file</code></p>
<p>满足条件的行，整行替换掉</p>
<ul>
<li>删除文本</li>
</ul>
<p><code>$sed &#39;1,3d&#39; file</code></p>
<p>删除1-3行</p>
<p><code>$sed &#39;/str/d&#39; file</code></p>
<p>删除匹配行</p>
<p><code>$sed -n &#39;/Begin/,/End/p&#39; file | more</code></p>
<p>删除两个匹配行之间的数据</p>
<ul>
<li>替换文本</li>
</ul>
<p>格式：<code>[address[,address]] s/pattern-find/replacement-pattern/[g,p,w,n]</code></p>
<p>n    1到512之间的一个数字，表示对本模式中指定模式第n次出现的情况进行替换。</p>
<p>g    对模式空间所有出现的情况进行全局更改【缺省只替换首次出现的模式 】</p>
<p>p    打印模式空间的内容</p>
<p>w    file</p>
<p><code>$sed &#39;s/str/tostr/&#39; file</code> </p>
<p>替换每一行首次出现的str为tostr</p>
<p><code>$sed &#39;s/str/tostr/g&#39; file</code></p>
<p>替换所有的行内，出现的所有str为tostr</p>
<p><code>$sed &#39;s/str/tostr/w output&#39; file</code></p>
<p>替换后重定向到output</p>
<p>转换字符</p>
<p><code>sed &#39;y/cp/wd/&#39; test.txt</code></p>
<p>c转换成w，p转换成d</p>
<ul>
<li>Shell向sed传值</li>
</ul>
<p><code>echo $input | sed &#39;s/bb/&#39;$str&#39;/&#39;</code></p>
<p><code>echo $input | sed &quot;s/bb/$str/&quot;</code></p>
<h2 id="awk">awk</h2><h3 id="主要功能-1">主要功能</h3><p>awk是一种用于处理文本的工具，主要用于格式化报文，或从一个大文本中抽取数据。</p>
<h3 id="执行过程-1">执行过程</h3><p>awk每次读入一行，执行’ ‘中的内容，按模式匹配来采取动作</p>
<h3 id="格式">格式</h3><p><code>awk &#39;pattern+{action}&#39; file</code></p>
<p>pattern用于筛选查询匹配行，决定了动作何时触发，可以使用条件语句，正则表达式</p>
<p>action用于对筛选后的内容进行处理</p>
<p>BEGIN可以设置计数和打印头（可选）</p>
<p>END打印输出文本总数和结尾状态标识(可选)</p>
<h3 id="常用参数">常用参数</h3><p>-F 指定读取一行数据的分隔符，默认为空格<br>-f 指定处理程序的脚本文件，这个文件必须符合awk语法</p>
<h3 id="调用方式：">调用方式：</h3><p><code>awk –f awk-script-file input-files</code></p>
<h3 id="常用内置参数">常用内置参数</h3><p><code>$0,$1,....$n</code>   <code>$0</code>代表当前行的内容，<code>$i</code>代表当前行被分割后的第i个字段的内容</p>
<p>ARGC 命令行参数个数</p>
<p>ARGV 命令行参数排列</p>
<p>ENVIRON 支持队列中系统环境变量的使用</p>
<p>FILENAME 实际操作的文件名</p>
<p>FNR 浏览文件记录数，&lt;=NR</p>
<p>FS <strong>设置输入域分隔符，等价于命令行-F选项</strong> ，可在BEGIN中进行设置,然后执行的时候均以设置的符号为分隔符</p>
<p>NF <strong>浏览记录 域的个数</strong>，在记录被读取时设置【number of fields】一共有多少个域</p>
<p>NR <strong>已读取记录数</strong>【number of rows】</p>
<p>RS 控制记录分隔符，缺省：新行\n，Row Separator记录分隔符，可以根据具体数据需求，设置读取一条记录的区间</p>
<p>OFS <strong>输出域的分隔符</strong>，缺省空格，输出结果 print $1,$2默认加的是空格，可以在BEGIN中设置，改为其他分隔符</p>
<p>ORS 输出记录的分隔符，缺省：新行\n，整体记录的</p>
<h3 id="实例">实例</h3><ul>
<li>打印</li>
</ul>
<p>打印所有行</p>
<p><code>awk &#39;{print $0}&#39; file</code></p>
<p>打印包含头尾</p>
<p><code>awk &#39;BEGIN{print &quot;Name Age&quot;}{print $1,$2}END{print &quot;END_OF_REPORT&quot;}&#39;</code></p>
<ul>
<li>使用判断语句</li>
</ul>
<p><code>&lt;  &lt;=  &gt;  &gt;=  ==  !=</code>  </p>
<p>~匹配正则   !~不匹配正则</p>
<p><code>|| &amp;&amp; !</code> 或且非</p>
<p><code>awk &#39;{if($2!~/Rudy/) print $0}&#39; content</code></p>
<p><code>awk &#39;{if($1==&quot;001&quot; &amp;&amp; $2~/^Ru/) print $0}&#39; content</code></p>
<ul>
<li>使用内置的变量 </li>
</ul>
<p><code>awk &#39;BEGIN{OFS=&#39;\t&#39;}{print NF,NR,$0}END{print FILENAME}&#39; content &gt; output</code></p>
<p>设置输出的分隔符为’\t’，输出一些内置变量的信息</p>
<ul>
<li>AWK变量中的字符串和数字的转换</li>
</ul>
<p>字符串-&gt;整数</p>
<p><code>$ awk &#39;BEGIN{a=&quot;100&quot;;b=&quot;10test10&quot;;print (a+b+0);}&#39;</code></p>
<p><code>110</code></p>
<p>只需要将变量通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。</p>
<p>整数-&gt;字符串</p>
<p><code>awk &#39;BEGIN{a=100;b=100;c=(a&quot;&quot;b);print c}&#39;</code>      </p>
<p><code>100100</code></p>
<p>只需要将变量与””符号连接起来运算即可。</p>
<ul>
<li>使用内置的字符串函数</li>
</ul>
<p><code>gsub(r,s)</code> 在整个$0中<strong>用s代替r</strong></p>
<p><code>gsub(r,s,t)</code> 在整个t中用s替代r</p>
<p><code>index(s,t)</code> 返回s中字符串t的第一位置</p>
<p><code>length(s)</code> <strong>返回s长度</strong></p>
<p><code>match(s,r)</code> 测试s是否包含匹配r的字符串</p>
<p><code>split(s,a,fs)</code> 在fs上将s分成序列a.fs为分隔符</p>
<p><code>sprint(fmt,exp)</code> 返回经fmt格式化后的exp</p>
<p><code>sub(r,s)</code> 用$0中最左边最长的子串代替s</p>
<p><code>substr(s,p)</code> 返回字符串s中从p开始的后缀部分</p>
<p><code>substr(s,p,n)</code> 返回字符串s中从p开始长度为n的后缀部分</p>
<p>替换字符串</p>
<p><code>awk &#39;BEGIN{FS=&#39;\t&#39;}{gsub(/Rudy/,&quot;RUDY&quot;);{print $0}}&#39; content</code></p>
<ul>
<li>使用printf进行格式化输出</li>
</ul>
<p><code>%c</code> ASCII字符</p>
<p><code>%d</code> 整数</p>
<p><code>%e</code> 浮点数，可科学计数法</p>
<p><code>%f</code> 浮点数，小数形式</p>
<p><code>%g</code> 由awk决定使用哪种浮点数转换e或f</p>
<p><code>%o</code> 八进制</p>
<p><code>%s</code> 字符串</p>
<p><code>%x</code> 十六进制</p>
<p>格式化输出一个字符串</p>
<p><code>awk -F&#39;\t&#39; &#39;{printf(&quot;%s\t%s\n&quot;,$2,$1)}&#39; content</code></p>
<ul>
<li>向awk中传递参数</li>
</ul>
<p><code>awk &#39;{if($3&lt;=AGE){print $0}}&#39; AGE=20 content</code> </p>
<ul>
<li><p>写一个awk脚本</p>
<pre><code><span class="comment">#!bin/awk -f</span>
BEGIN{
        FS=<span class="string">"['\t']"</span>
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="string">"NUMBER"</span>,<span class="string">"NAME"</span>,<span class="string">"AGE"</span>)
}
{
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)
}
END{
        <span class="keyword">print</span> <span class="string">"END OF FILE"</span>
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p]]>
    </summary>
    
      <category term="linux命令" scheme="http://rudy-zhang.me/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="linux" scheme="http://rudy-zhang.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux正则表达式和grep]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cgrep/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux正则表达式和grep/</id>
    <published>2015-05-25T23:27:44.000Z</published>
    <updated>2015-05-25T23:54:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk: 伪装成实用程序的强大编程语言，主要用于文本处理</li>
</ul>
<h3 id="常用符号">常用符号</h3><h4 id="基本元字符">基本元字符</h4><p><code>^</code> 行首定位符，表示以..开始</p>
<p><code>$</code> 行尾定位符，表示以..结束</p>
<p><code>.</code>  匹配单个字符</p>
<p><code>*</code> 匹配0个或任意多个字符</p>
<p><code>[]</code> 匹配[]中出现字符范围内的一个字符</p>
<p><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h4 id="扩展元字符">扩展元字符</h4><p><code>?</code> 匹配0个或者1个</p>
<p><code>+</code> 匹配1个或者多个</p>
<p><code>|</code> 或者</p>
<p><code>()</code>分组符号</p>
<h4 id="特殊匹配字符">特殊匹配字符</h4><p><code>[:alnum:]</code> 字母与数字字符</p>
<p><code>[:alpha:]</code> 字母</p>
<p><code>[:ascii:]</code> ASCII字符</p>
<p><code>[:blank:]</code> <strong>空格或制表符</strong></p>
<p><code>[:cntrl:]</code> ASCII控制字符</p>
<p><code>[:digit:]</code> 数字</p>
<p><code>[:graph:]</code> 非控制、空格字符</p>
<p><code>[:lower:]</code> 小写字母</p>
<p><code>[:print:]</code> 可打印字符</p>
<p><code>[:punct:]</code> 标点符号字符</p>
<p><code>[:space:]</code> <strong>空白字符，包括垂直制表符</strong></p>
<p><code>[:upper:]</code> 大写字母</p>
<p><code>[:xdigit:]</code> 十六进制数字</p>
<h3 id="实例">实例</h3><ul>
<li>^ $<br><code>ls -l | grep ^d</code></li>
</ul>
<p>匹配以d开头的所有内容</p>
<ul>
<li><code>ls -l | grep d$</code></li>
</ul>
<p>匹配以d结束的所有内容</p>
<ul>
<li><code>^$</code> </li>
</ul>
<p>匹配空行</p>
<ul>
<li><code>^.$</code></li>
</ul>
<p>只包含一个字符的</p>
<ul>
<li><code>* ？ +</code></li>
</ul>
<p><code>compu*ter</code> 匹配u，重复0次或多次</p>
<p><code>compu?ter</code> 匹配0个或者1个u</p>
<p><code>compu+ter</code> 匹配1个或多个u</p>
<p><strong>需要注意的是+和？是扩展字符，需要看具体使用正则表达式的环境<br>如果使用grep需要使用-E指定为扩展模式才能正常使用+和？</strong></p>
<ul>
<li><code>\</code>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
</ul>
<p><code>\.pass</code>  匹配<code>*.pass</code></p>
<ul>
<li><code>[]</code></li>
</ul>
<p><code>[1234]</code> 匹配1,2,3,4中的一个</p>
<p><code>[1-9]</code> 数字1-9中的一个</p>
<p><code>[A-Za-z]</code> 所有字母</p>
<p><code>[^0-9]</code> 一个非数字的字符</p>
<ul>
<li><code>\{\}</code></li>
</ul>
<p><code>A\{2\}B</code>   匹配AAB</p>
<p><code>A\{4,\}B</code>   匹配A出现至少4次B</p>
<p><code>A\{2,4\}B</code>  匹配A出现在2至4次之间</p>
<h2 id="grep">grep</h2><p>功能：grep是文本搜索工具，使用正则表达式搜索文本并打印匹配行</p>
<p>格式：<code>grep [options] PATTERN [Files]</code></p>
<p>注：</p>
<p>输入字符串<strong>作为参数，最好双引号括起</strong>  “mystr”</p>
<p>在<strong>调用变量时，也使用双引号括起</strong>  “$MYSTR”</p>
<p>使用<strong>正则[匹配模式]是，应使用单引号括起</strong>  ‘49[32]’</p>
<p>常用选项：</p>
<p><code>-c</code> 只输出匹配的行数,而不输出匹配的行</p>
<p><code>-i</code> 不区分大小写</p>
<p><code>-n</code> 显示匹配行及行号</p>
<p><code>-q</code>  安静模式，不输出任何东西，如果找到了返回0</p>
<p><code>-E</code> 启用扩展表达式，可使用扩展字符，如：+ ? | () {} , 或者直接使用egrep</p>
<p><code>-v</code> 显示不包含匹配文本的所有行</p>
<p>实例：</p>
<ol>
<li><p>在多个文件中查找<br><code>grep “sort” filea fileb</code>  在filea,fileb中查找</p>
</li>
<li><p>计算匹配行数<br><code>grep -c &quot;sort&quot; file</code></p>
</li>
<li><p>使用正则表达式查找<br><code>grep &#39;48[34]&#39; file</code></p>
</li>
<li><p>使用扩展元字符<br><code>grep -E &#39;aaa|bbb&#39; file</code></p>
</li>
<li><p>匹配空行<br><code>grep &#39;^$&#39; file</code></p>
</li>
<li><p>特殊匹配字符，grep 允许使用国际字符串模式匹配或匹配模式的类名<br><code>grep ‘5[[:upper:]] [[:upper:]]’</code> data  5开头，两个大写</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk:]]>
    </summary>
    
      <category term="linux命令" scheme="http://rudy-zhang.me/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="正则表达式" scheme="http://rudy-zhang.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="linux" scheme="http://rudy-zhang.me/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming学习文档]]></title>
    <link href="http://rudy-zhang.me/2015/05/24/HadoopStreaming/"/>
    <id>http://rudy-zhang.me/2015/05/24/HadoopStreaming/</id>
    <published>2015-05-24T01:30:00.000Z</published>
    <updated>2015-05-24T08:54:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架允许任何程序语言实现的程序（只要该程序支持标准输入输出即可），在Hadoop MapReduce中使用，方便已有程序向Hadoop平台移植。</p>
<h2 id="Streaming原理">Streaming原理</h2><p>使用Java实现了一个包装<strong>用户程序</strong>（mapper，reducer方法）的MapReduce程序，该程序调用MapReduce的Java接口，创建一个<strong>新的进程</strong>包装用户程序，将数据通过<strong>管道</strong>传递给包装的用户程序。</p>
<p><img src="http://i.imgur.com/dlebclb.jpg" alt=""></p>
<h2 id="考虑的问题">考虑的问题</h2><p>在实际的开发过程中，开发人员需要考虑下面几个方面的问题，其中1,2是必须实现的：</p>
<ol>
<li>Mapper程序：对输入key/value数据进行处理；</li>
<li>Reducer程序：对mapper的输出进行归并处理；</li>
<li>Combiner：在本地对一个计算节点上的mapper输出进行归并；</li>
<li>Partitioner：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li>InputFormat/OutputFormat：对输入数据进行切分，保存输出数据。</li>
</ol>
<h2 id="执行">执行</h2><pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “cat” \
    -reducer “cat” \
    -jobconf mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">1</span>\
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”dist-sort”
</code></pre><p>这是一个实现了分布式排序的程序。可以通过shell脚本，shell命令，或者其它语言的<strong>可执行程序</strong>来进行mapper和reducer程序的运行</p>
<h2 id="常用参数的使用">常用参数的使用</h2><p>例1：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">2</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"Python/bin/python $app/mapper.py"</span> \
    -reducer <span class="string">"Python/bin/python $app/reducer.py"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archive</span>
</code></pre><p>-D表示配置参数，剩余项是和输入输出相关的文件和可执行程序</p>
<p><code>-D mapred.job.name=&quot;jobname&quot; \</code>,作业名</p>
<p><code>-D mapred.job.priority=VERY_HIGH \</code> 作业优先级</p>
<p><code>-D mapred.job.map.capacity=500 \</code>,最多同时运行map任务数</p>
<p><code>-D mapred.job.reduce.capacity=300 \</code>最多同时运行reduce任务数</p>
<p><code>-D mapred.map.tasks=500 \</code>,map任务个数</p>
<p><code>-D mapred.reduce.tasks=300 \</code>,reduce任务个数</p>
<p>capacity是同时运行任务的个数，tasks是运行任务的总的个数，一般task更大，capacity是同时运行任务的上限</p>
<p><code>-D stream.num.map.output.key.fields=2 \</code>,表示在第2个分隔符（默认为\t）之前作为key，之后作为value，也可以使用参数<code>-D stream.map.output.field.separator=. \</code>指定分隔符为’.’或者其它字符。</p>
<p><code>-mapper &quot;Python/bin/python $app/mapper.py&quot; \</code>指定map任务，需要可执行，读入标准输入流，输出标准输出流</p>
<p><code>-reducer &quot;Python/bin/python $app/reducer.py&quot; \</code>指定reducer任务</p>
<p><code>-input $input \</code>指定输入文件</p>
<p><code>-output $output \</code>指定输出文件</p>
<p><code>-cacheArchive $archive</code>分发压缩包。<code>$archive</code>格式为<code>hdfs://host:port/path/to/archivefile#linkname</code>，表示hdfs上这个压缩包的路径为<code>hdfs://host:port/path/to/archivefile</code>,可以使用<code>linkname/children/path</code>访问这个压缩包的内容</p>
<p>例2：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">3</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.partitioner</span><span class="class">.options</span>=<span class="string">"-k1,1"</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.comparator</span><span class="class">.options</span>=<span class="string">"-k1,1 -k3,3nr"</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"cat"</span> \
    -reducer <span class="string">"cat"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archives</span>
</code></pre><p><code>-D mapred.text.key.partitioner.options=&quot;-k1,1&quot; \</code>表示对key进行分割，分割符默认为\t，取分割后的1,1部分作为主key，剩下的作为辅key</p>
<p><code>-D mapred.text.key.comparator.options=&quot;-k1,1 -k3,3nr&quot; \</code>指定排序依据，主key按第一部分排字母序，辅key按第三部分数字序倒序排</p>
<p>例3：</p>
<pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -D stream<span class="class">.map</span><span class="class">.output</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">4</span> \
    -D map<span class="class">.output</span><span class="class">.key</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D num<span class="class">.key</span><span class="class">.fields</span><span class="class">.for</span><span class="class">.partition</span>=<span class="number">2</span> \ 
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “mymapper.sh” -reducer “ myreducer.sh” \
    -partitioner org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.lib</span><span class="class">.KeyFieldBasedPartitioner</span> \
    -file /home/work/mymapper<span class="class">.sh</span> \
    -file /home/work/myreducer<span class="class">.sh</span> \
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”jobname”
</code></pre><p><code>-D stream.map.output.field.separator=. \</code><br><code>-D stream.num.map.output.key.fields=4 \</code><br>表示输出分隔符为’.’，并且第4个.之后为value，之前为key</p>
<p><code>-D map.output.key.field.separator=. \</code><br><code>-D num.key.fields.for.partition=2 \</code><br>表示key内的分隔符为’.’，第2个’.’之前作为主key，之后作为辅key</p>
<p><code>-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner \</code>指定要使用KeyFieldBasedPartitioner，也就是key域内的partioner。这样的话会把主key的内容作为partition的依据，相同的主key分配到同一个reducer中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop基本原理]]></title>
    <link href="http://rudy-zhang.me/2015/05/23/Hadoop%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://rudy-zhang.me/2015/05/23/Hadoop基本原理/</id>
    <published>2015-05-23T02:38:00.000Z</published>
    <updated>2015-05-24T14:11:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据处理速度快（Velocity） 数据真实性高（Veracity） 合起来被称为4V。</p>
<p>处理大数据是为了挖掘数据中的隐含价值</p>
<h4 id="如何处理大数据？">如何处理大数据？</h4><p>集中式计算VS分布式计算</p>
<p>集中式计算：通过不断增加处理器的个数来增强耽搁计算机的计算能力，从而提高处理的速度。需要的内存很大，计算的速度很快。</p>
<p>分布式计算：一组通过网络连接的计算机，形成一个分散的系统。将需要处理的大量数据分散成多个部分，交由系统中的耽搁计算机分别处理，最后将这些计算结果合并得到最终结果。（MapReduce的核心思想）</p>
<h3 id="Hadoop是怎么产生的">Hadoop是怎么产生的</h3><h4 id="技术基础">技术基础</h4><p>google三驾马车：GFS、MapReduce和BigTable。Hadoop是在google三驾马车基础上的开源实现。</p>
<ol>
<li>GFS（Google File System）分布式文件系统，对应Hadoop当中的HDFS。</li>
<li>MapReduce分布式计算框架，也是Hadoop处理大数据的核心思想。</li>
<li>BigTable是基于GFS的数据存储系统，对应Hadoop的HBase。</li>
</ol>
<h4 id="三大分布式计算系统">三大分布式计算系统</h4><p>Hadoop，Spark，Storm是主流的三大分布式计算系统</p>
<p>Spark VS Hadoop</p>
<p>Hadoop使用硬盘来存储数据，而Spark是将数据存在内存中的，因此Spark何以提供超过Hadoop 100倍的计算速度。内存断电后会丢失，所以Spark不<br>适用于需要长期保存的数据。</p>
<p>Storm VS Hadoop</p>
<p>Storm在Hadoop基础上提供了实时运算的特性，可以实时处理大数据流。不同于Hadoop和Spark，Storm不尽兴数据的手机和存储工作，直接通过网络接受并实时处理数据，然后直接通过网络实时传回结果。</p>
<p>所以三者适用于的应用场景分别为：</p>
<ol>
<li>Hadoop常用于离线的复杂的大数据处理</li>
<li>Spark常用于离线的快速的大数据处理</li>
<li>Storm常用于在线实时的大数据处理</li>
</ol>
<h3 id="Hadoop定义">Hadoop定义</h3><h4 id="Hadoop是什么">Hadoop是什么</h4><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架</p>
<h4 id="Hadoop特点">Hadoop特点</h4><ol>
<li>可靠。Hadoop假设计算元素和存储会失败，所以会维护多个工作数据的副本，对失败的节点会重新处理</li>
<li>高效。通过并行方式工作，加快处理速度。</li>
<li>可伸缩。可以处理PB级的数据。</li>
<li>高扩展。可以方便地扩展到数以千计的节点。</li>
<li>低成本。Hadoop是开源的，Hadoop节点可以是很便宜的机器。</li>
</ol>
<h4 id="应用场景">应用场景</h4><p>Hadoop适用于：海量数据，离线数据，复杂数据</p>
<p>场景1：数据分析，如海量日志分析，商品推荐，用户行为分析</p>
<p>场景2：离线计算，（异构计算+分布式计算）天文计算</p>
<p>场景3：海量数据存储，如Facebook的存储集群。</p>
<p><a href="http://cloud.zol.com.cn/441/4415033_all.html" target="_blank" rel="external">更多应用场景</a></p>
<h3 id="Hadoop原理">Hadoop原理</h3><h4 id="HDFS">HDFS</h4><p>HDFS（Hadoop File System），是Hadoop的分布式文件存储系统</p>
<ol>
<li>将大文件分解为多个Block，每个Block保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。</li>
<li>默认每个Block保存3个副本，64M为1个Block。</li>
<li>将Block按照key-value映射到内存当中。</li>
</ol>
<p>HDFS架构图如下：</p>
<p><img src="http://i.imgur.com/ZliSEXb.png" alt=""></p>
<h5 id="NameNode">NameNode</h5><p>HDFS使用主从结构，NameNode是Master节点，是领导。所有的客户端的读写请求，都需要首先请求NameNode。</p>
<p>NameNode存储</p>
<ol>
<li>fsimage：元数据镜像文件（文件系统的目录树，文件的<strong>元数据</strong>信息）。元数据信息包括文件的信息，文件对应的block信息（版本信息，类型信息，和checksum），以及每一个block所在的DataNode的信息。</li>
<li>edits：元数据的操作日志</li>
</ol>
<h5 id="DataNode">DataNode</h5><p>DataNode是Slave，负责真正存储所有的block内容，以及数据块的读写操作</p>
<p>NameNode，DataNode，rack只是一些逻辑上的概念。NameNode和DataNode可能是一台机器也可能是，相邻的一台机器，很多DataNode可能处于同一台机器。rack是逻辑上比DataNode更大的概念，可能是一台机器，一台机柜，也可能是一个机房。通过使文件的备份更广泛地分布到不同的rack，DataNode上可以保证数据的可靠性。</p>
<h5 id="HDFS写入数据">HDFS写入数据</h5><ol>
<li>Client拆分文件为64M一块。</li>
<li>Client向NameNode发送写数据请求。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode。</li>
<li>Client向DataNode发送block1,2,3….；发送过程是以流式写入。流式写入，数据流向为DataNode1-&gt;DataNode2-&gt;DataNode3(1,2,3为通过规则选出来的可用的DataNode)</li>
<li>发送完毕后告知NameNode</li>
<li>NameNode告知Client发送完成</li>
</ol>
<p>在写数据的时候：</p>
<ul>
<li>写1T文件，我们需要3T的存储，3T的网络流量贷款。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ul>
<h5 id="HDFS读取数据">HDFS读取数据</h5><ol>
<li>Client向NameNode发送读请求</li>
<li>NameNode查看MetaData信息，返回文件的block位置</li>
<li>根据一定规则（优先选择附近的数据），按顺序读取block</li>
</ol>
<p><a href="http://www.weixuehao.com/archives/596" target="_blank" rel="external">更多内容</a></p>
<h4 id="MapReduce">MapReduce</h4><p>Map是把一组数据一对一的<strong>映射</strong>为另外的一组数据，其映射的规则由一个<strong>map函数</strong>来指定。Reduce是对一组数据进行<strong>归约</strong>，这个归约的规则由一个<strong>reduce函数</strong>指定。</p>
<p>整个的MapReduce执行过程可以表示为：</p>
<p><code>(input)&lt;k1, v1&gt; =&gt; map =&gt; &lt;k2, v2&gt; =&gt; combine =&gt; &lt;k2, v2’&gt; =&gt; reduce =&gt; &lt;k3, v3&gt;(output)</code></p>
<p>也可以表示为流程图：</p>
<p><img src="http://i.imgur.com/yRsLgoK.png" alt=""></p>
<ol>
<li><strong>分割</strong>：把输入数据分割成不相关的若干键/值对（key1/value1）集合，作为input</li>
<li><strong>映射</strong>：这些键/值对会由多个map任务来<strong>并行地处理</strong>。输出一些中间键/值对key2/value2集合</li>
<li><strong>排序</strong>：MapReduce会对map的输出（key2/value2）按照key2进行排序（便于归并）</li>
<li><strong>conbine</strong>：属于同一个key2的所有value2组合在一起作为reduce任务的输入（相当于提前reduce，减小key2的数量，减小reduce的负担）</li>
<li><strong>Partition</strong>：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li><strong>规约</strong>：由reduce任务计算出最终结果并输出key3/value3。</li>
</ol>
<h4 id="程序员需要做的">程序员需要做的</h4><ul>
<li>单机程序需要处理数据读取和写入、数据处理</li>
<li>Hadoop程序需要实现map和reduce函数</li>
<li>map和reduce之间的数据传输、排序，容错处理等由Hadoop MapReduce和HDFS自动完成。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（二）]]></title>
    <link href="http://rudy-zhang.me/2015/04/22/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B62/"/>
    <id>http://rudy-zhang.me/2015/04/22/一步一步写一个PHP框架2/</id>
    <published>2015-04-22T07:31:44.000Z</published>
    <updated>2015-05-24T08:58:56.000Z</updated>
    <content type="html"><![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%B8%80/">这位大哥</a>,的内容和Codeigniter框架的源码。</p>
<h2 id="程序框架的搭建">程序框架的搭建</h2><p>前提：已经搭建好了一个apache+PHP的开发环境，我使用的是Apache+mod_php5的方式。</p>
<p>在根目录<code>simplemvc</code>下新建以下文件夹</p>
<ul>
<li><code>config</code> 用来存放配置文件</li>
<li><code>controller</code>用来存放控制器</li>
<li><code>lib</code>用来存放引入的库文件</li>
<li><code>model</code>用来存放模型</li>
<li><code>system</code>用来存放系统文件<ul>
<li><code>core</code>核心文件，包括核心controller控制器等，所有的controller都要继承于他</li>
<li><code>lib</code>存放核心的库文件，包括route等</li>
<li><code>app.php</code>应用程序驱动类</li>
</ul>
</li>
<li><code>view</code>用来存放视图</li>
<li><code>index.php</code>项目的入口文件，程序是从这里开始执行的。</li>
</ul>
<h2 id="定义系统路径">定义系统路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#39044;&#23450;&#20041;&#10;define(&#39;SYSTEM_PATH&#39;, dirname(__FILE__).&#39;/system&#39;);&#10;define(&#39;ROOT_PATH&#39;,  substr(SYSTEM_PATH, 0,-7));&#10;define(&#39;SYS_LIB_PATH&#39;, SYSTEM_PATH.&#39;/lib&#39;);&#10;define(&#39;APP_LIB_PATH&#39;, ROOT_PATH.&#39;/lib&#39;);&#10;define(&#39;SYS_CORE_PATH&#39;, SYSTEM_PATH.&#39;/core&#39;);&#10;define(&#39;CONTROLLER_PATH&#39;, ROOT_PATH.&#39;/controller&#39;);&#10;define(&#39;MODEL_PATH&#39;, ROOT_PATH.&#39;/model&#39;);&#10;define(&#39;VIEW_PATH&#39;, ROOT_PATH.&#39;/view&#39;);</span><br></pre></td></tr></table></figure>
<p>预定义一些常量，在之后的程序中我们会使用这些路径。</p>
<h2 id="加载配置文件，和应用程序驱动类">加载配置文件，和应用程序驱动类</h2><h3 id="配置文件">配置文件</h3><p>在config文件夹下的<code>config.php</code><br>··<br>$CONFIG[‘system’][‘db’]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（一）]]></title>
    <link href="http://rudy-zhang.me/2015/04/20/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B61/"/>
    <id>http://rudy-zhang.me/2015/04/20/一步一步写一个PHP框架1/</id>
    <published>2015-04-20T07:31:44.000Z</published>
    <updated>2015-05-24T08:59:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
<p>为了更好地理解PHP里面框架的设计，目标是自己写一个简单的PHP MVC框架，一方面可以更深入地学习PHP，一方面也能够更深入地理解框架设计里面的思想。</p>
<h2 id="Apache的工作流程">Apache的工作流程</h2><p>Apache是一个Web服务器，也可以叫做http服务器，因为Apache只能处理http请求。常见的web服务器还有Nginx</p>
<p>Apache的工作流程如下：</p>
<ol>
<li>浏览器向服务器发出HTTP请求(Request)。</li>
<li>服务器收到浏览器的请求数据，经过分析处理，向浏览器输出响应数据（Response）。</li>
<li>浏览器收到服务器的响应数据，经过分析处理，将最终结果显示在浏览器中。</li>
</ol>
<p>Apache和Nginx都属于Web服务器，两者都实现了HTTP 1.1协议。</p>
<p>所以如果有人问FTP协议可以在Apache上工作吗？答案是用Apache FTP Server可以，Apache web服务器不可以。</p>
<p>Apache是用C语言写的，服务器当然要追求高效率。</p>
<h2 id="PHP原理">PHP原理</h2><p>PHP的核心解释器是用C语言写的，相当于我们写了PHP代码，会有一个C语言写好的解释工具一边解释，一边执行。实际上在写PHP的时候就是在使用一个C语言写好的工具，我们的PHP代码就是指挥这个工具的命令。</p>
<p>PHP包括四层体系：</p>
<ol>
<li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分。负责翻译PHP代码，是一切的核心。</li>
<li>Extensions：围绕Zend引擎，通过组件方式提供基础服务。常见内置函数如array是由extension实现的。</li>
<li>Sapi通过一系列的<strong>钩子函数</strong>，使得PHP可以和外围交互数据。如Apache</li>
<li>上层应用：平时写的PHP程序</li>
</ol>
<blockquote>
<p>如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路， 车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。</p>
</blockquote>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p><strong>hashtable</strong>是PHP的核心数据结构，数组就是典型的应用。Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表（解决冲突），提供了正向、反向遍历数组的功能。</p>
<p>更详细的内容参考<a href="!http://www.cnblogs.com/zcy_soft/archive/2013/03/14/2959396.html">这里</a></p>
<h2 id="PHP在Apache上运行">PHP在Apache上运行</h2><h3 id="以模块加载的方式运行">以模块加载的方式运行</h3><p>这种方式使用了Apache的Hook机制。所谓Hook机制，就是在自己的程序运行的时候允许别的模块插上一腿。当我们配置Apache服务器的<code>http.config</code>文件时，写入<code>mod_php5.so/php5apache2.dll</code>就是将自定义的函数注入到Apache的请求处理循环当中。在模块化的运行方式中，PHP与Web服务器一起启动并且运行，通过Apache自身的进程线程管理来处理并发的请求。</p>
<h3 id="以CGI，FastCGI方式运行">以CGI，FastCGI方式运行</h3><p>CGI英文叫做公共网关接口，CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。Apache在Http请求的时候会将请求提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。</p>
<p>CGI VS FastCGI</p>
<p>FastCGI是CGI的加强版本，CGI是单进程，多线程的运行方式，程序执行完成之后就会销毁。FastCGI是常驻(long-live)型的CGI.有自身的进程管理器，不必每一次都fork一个进程（CGI解释器）去执行。常见的PHP-FPM是一个PHP FastCGI管理器。</p>
<p>关于更多的对比可以看<a href="http://fifiole.blog.163.com/blog/static/169459225201222962651804/" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>目前在HTTPServer这块基本可以看到有三种stack比较流行：</p>
<p>（1）Apache+mod_php5</p>
<p>（2）lighttp+spawn-fcgi</p>
<p>（3）nginx+PHP-FPM</p>
<p>三者后两者性能可能稍优，但是Apache由于有丰富的模块和功能，目前来说仍旧是老大。有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何完成一个在线考试的功能]]></title>
    <link href="http://rudy-zhang.me/2015/04/07/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://rudy-zhang.me/2015/04/07/如何完成一个在线考试的功能/</id>
    <published>2015-04-07T00:58:06.000Z</published>
    <updated>2015-05-24T02:27:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2><h3 id="考卷生成">考卷生成</h3><p>卷子总是由试题组成的，试题包括内容，选项之类的<strong>文本</strong>，以及相关的<strong>图片</strong>。每个试题在数据库中当然只能存一份，否则就浪费了存储空间。很多的OJ题目是随机生成的，一句特定的内容随机生成考题，并且答题结果也是每人一份的，这时候很容易就想到需要中间表来存储这个内容了。</p>
<h3 id="保存现场">保存现场</h3><p>如果使用一个大form，在用户提交考试结果的时候把所有数据提交到server，那中间如果用户不小心退出了，所有的答题内容就<strong>丢失</strong>了。所以需要在用户答题的过程中不断<strong>异步存储</strong>用户答题的结果，使得用户在任何一个时候退出，我们都能够统计出他已经答过的题并且给出分数（或者结果）的。</p>
<h3 id="断线处理">断线处理</h3><p>当用户断线的时候，或者不小心退出了浏览器，系统需要允许用户重新登录，<strong>继续考试</strong>。</p>
<h3 id="倒计时">倒计时</h3><p>倒计时运行在client上，你永远也无法控制client端的人会对代码做什么。在js中添加断点可以停止倒计时空间的运行，所以关于时间必须在server端进行校验，才能规避在时间上作弊的行为。</p>
<h3 id="结算分数">结算分数</h3><p>你永远也无法控制client端的人会对代码做什么，同时开多个窗口可以多次提交结果，甚至可以操纵client端的数据以各种方式提交数据。在server端要考虑到这种行为并且做出相应的对策，对策就是分数永远只结算一次。</p>
<h2 id="实现">实现</h2><h3 id="数据库">数据库</h3><p>根据我做的项目的系统需求，有如下几个关键概念：</p>
<ul>
<li>模块（module）<br>课程分为若干个模块（module），每个模块对应一次考试。每次有限定的时间。</li>
<li>考点（test_point）<br>每个模块包括若干个考点，每次考试从考点中随机抽取题目。</li>
<li>题目(question)<br>题目都是选择题，最多四个，单选题，题干和每个选项都可能对应图片。基于题目题型是固定的，我把这些内容都放到了一个表里，如果考题类型丰富需要更灵活的设计。</li>
<li>考卷（report）<br>每次考试的考卷，上面会有分数。考卷和题目有着多对多的关系，需要一个中间表来存储。</li>
</ul>
<p>出去其他需求，考试部分的数据表简单设计如下：<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqw7h465uvj20pz0ibgmo.jpg" alt="enter image description here"></p>
<h3 id="考卷生成-1">考卷生成</h3><p>每个考试（模块）都对应三种状态：</p>
<ol>
<li>没有考过试的模块 ——— 对应 ——— 生成考题，去考试</li>
<li>已经开始考试还没结束的模块 ——— 对应 ——— 使用已经生成的考题，继续考试</li>
<li>已经结束的模块 ——— 对应 ——— 查看考试成绩</li>
</ol>
<p>当系统没有这个模块的report信息的时候，根据考点随机抽取题目，生成考题和report，<br>report状态变成<strong>进行中</strong>，分数还没有结算。</p>
<p>关键函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#32452;&#21367;&#65292;&#23558;&#32452;&#21367;&#30340;&#20869;&#23481;&#25918;&#20837;report&#34920;&#65292;question_in_report&#34920;&#65292;&#32452;&#21367;&#23545;&#21516;&#19968;&#20010;&#32771;&#35797;&#19981;&#20250;&#32452;&#20004;&#27425;&#10;     * @param  [type] $student_id     [description]&#10;     * @param  [type] $module_id      [description]&#10;     * @param  [type] $logic_class_id [description]&#10;     * @return [type]                 [description]&#10;     */&#10;    function get_questions($student_id,$module_id,$logic_class_id)&#10;    &#123;&#10;        /*&#38656;&#35201;&#25552;&#21069;&#20570;&#30340;&#26816;&#26597;:&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#24050;&#32463;&#22312;&#36825;&#20010;&#36923;&#36753;&#29677;&#19979;&#32771;&#36807;&#36825;&#20010;&#27169;&#22359;&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#26159;&#29992;&#25143;&#33258;&#24049;&#10;        &#36825;&#20010;&#23398;&#29983;&#26159;&#21542;&#23646;&#20110;&#36825;&#20010;&#36923;&#36753;&#29677;&#10;        &#36825;&#20010;&#36923;&#36753;&#29677;&#20013;&#26159;&#21542;&#26377;&#36825;&#38376;&#35838;*/&#10;        &#10;        //&#36941;&#21382;&#25152;&#26377;&#32771;&#28857;&#65292;&#20174;&#27599;&#20010;&#32771;&#28857;&#20013;&#38543;&#26426;&#25277;&#20986;&#19968;&#36947;&#39064;&#23384;&#20837;$test_questions&#10;&#10;        //&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;&#10;        $datetime=date(&#34;Y-m-d H:i:s&#34;);&#10;        &#10;        //&#23558;&#32467;&#26524;&#23384;&#20837;report&#34920;&#10;        $this-&#62;report_model-&#62;add($report_item);&#10;        &#10;        //&#23558;&#32452;&#39064;&#20449;&#24687;&#20889;&#20837;question_in_report &#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="保存现场-1">保存现场</h3><p>使用一个简单的jquery ajax，异步提交用户每次点击的选项，都在后台存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function save_choose(question_id,choose)&#10;&#123;&#10;    myUrl=&#34;&#60;?php echo site_url(&#39;student_test/ajax_save_user_choose&#39;)?&#62;/&#34;+&#60;?php echo $report_id ?&#62;+&#34;/&#34;+question_id+&#34;/&#34;+choose;&#10;    $.ajax(&#123;&#10;        type:&#34;post&#34;,&#10;        url:myUrl,&#10;        success:function(resp)&#123;&#125;&#10;    &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>后台接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#24322;&#27493;ajax&#23384;&#20648;&#29992;&#25143;&#30340;&#36873;&#25321;&#10; * @param  [type] $report_id   [description]&#10; * @param  [type] $question_id [description]&#10; * @return [type]              [description]&#10; */&#10;function ajax_save_user_choose($report_id,$question_id,$choose)&#10;&#123;&#10;    //&#20808;&#21028;&#26029;&#26102;&#38388;&#26159;&#21542;&#27491;&#30830;     &#10;    $now=date(&#34;Y-m-d H:i:s&#34;);&#10;    $this-&#62;load-&#62;helper(&#39;compare_time&#39;);&#10;    $time_past=compare_time_of_minute($report[&#39;datetime&#39;],$now);&#10;    &#10;    if($time_past&#60;=($module[&#39;time_limit&#39;]))&#123;&#10;        //&#26356;&#26032;&#20449;&#24687;&#10;        );  &#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="断线处理-1">断线处理</h3><p>当用户掉线重新进入，需要通过比对<strong>report状态</strong>+<strong>时间</strong>，确定用户是否可以继续考试。</p>
<ul>
<li>如果report状态为结束，则不能继续考试</li>
<li>如果report状态为进行中，时间超过截止时间，不能继续考试</li>
<li>如果report状态为进行中，时间还有，继续考试</li>
</ul>
<p>继续考试通过reportid得到已经<strong>组好的试题信息</strong>，和<strong>用户的答题情况</strong>，返回数据<br>关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#26597;&#25214;&#25968;&#25454;&#24211;&#20013;&#30340;&#24050;&#32463;&#32452;&#22909;&#21367;&#30340;&#20449;&#24687;&#10;     * @param  [type] $report_id [description]&#10;     * @return [type]            [description]&#10;     */&#10;    function get_exist_questions($report_id)&#10;    &#123;       &#10;        //&#23384;&#20648;&#25152;&#26377;&#32771;&#21367;&#39064;&#30446;&#30340;&#25968;&#32452;&#10;        $test_questions = array();&#10;        &#10;        //&#20174;question_in_report&#20013;&#26597;&#25214;&#25152;&#26377;&#28385;&#36275;&#26465;&#20214;&#30340;&#38382;&#39064;&#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="倒计时-1">倒计时</h3><p>客户端的倒计时使用js，最简单的可以使用<code>window.setInterval()</code>函数，每隔1s时间修改html的内容。结果在stackoverflow上询问倒计时解决方法的时候被“鄙视”了一下：</p>
<blockquote>
<p>You’re design is bad, you should base your time measurement using the date object. Each time a loop will get triggered, check the current date with new Date() and keep track of the last date.</p>
<p>Keep in mind that even if you set an interval of 1000ms, it doesn’t mean that on the function will get called every seconds. It only means that it will never get called before 1000ms. As Javascript runs in one thread, any blocking process may delay calling methods that will remain in the event queue (setInterval in this case).</p>
</blockquote>
<p>大体意思是<code>setInterval</code>能保证运行的时间一定比传入的参数多，但是js是单线程的，别的操作有可能会阻塞这个方法，所以最好使用<code>Date()</code>方法来比对客户端的时间。</p>
<p>所以我的实现是使用了<a href="https://github.com/tomgrohl/jCountdown" target="_blank" rel="external">jcountdown插件</a>，通过计算出截止日期，进行倒计时。方法很简单，只需要在<code>id</code>为<code>time</code>的div上使用插件里的函数就可以了。通过template可以指定显示时间的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#34;#time&#34;).countdown(&#123;&#10;            minSingularText: &#39;&#20998;&#39;,&#10;            secSingularText: &#39;&#31186;&#39;,&#10;            &#34;date&#34; : d,&#10;            template: &#34;&#60;div class=&#39;time-item&#39;&#62;&#60;strong&#62;%i %s&#60;/strong&#62;&#60;/div&#62;&#34;,&#10;            onComplete : function()&#123;$(&#34;#test&#34;).submit();&#125;&#10;        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>不管倒计时做的多么炫酷，client is client，我永远无法控制它最终怎么运行，有没有被篡改。所以，每一次用户答题提交ajax请求，以及最终提交考卷的时候，都要<strong>比对时间</strong>，只保存合理的请求。这样就保证了整个考试系统在时间上的正确性。</p>
<h3 id="结算分数-1">结算分数</h3><p>结算分数有以下几个时间点</p>
<ol>
<li>用户答题完成，提交所有数据</li>
<li>用户在时间结束时由浏览器自动提交数据</li>
<li>用户没有通过浏览器提交数据（半路关闭浏览器），下次登录时系统自动算分</li>
</ol>
<p>1,2类似，正常提交表单就可以，需要注意的是：</p>
<ol>
<li>在所有这些过程中，<strong>网络可能有延时</strong>，所以在比对用户提交的时间的时候，可以宽限一定时间。</li>
<li>提交后修改report的状态，这个操作只有一次，拒绝之后的所有修改（form的数据，ajax请求）。</li>
</ol>
<p>3对应着意外退出，时间过了才重新登录的情况。这个时候的考试状态是，<code>report</code>的状态还是进行中，但是时间已经超过。这时候通过保存现场的数据计算分数即可。</p>
<h2 id="结束语">结束语</h2><p>我通过这样的设计，完成了一个体验相对良好，逻辑上没有问题，避免了用户在时间和数据上做手脚的在线考试功能。但因为是第一次做，也许有的地方还是考虑不周全，或者有更好的设计，希望大家多多指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2>]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站应对大数据量高并发的挑战]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/%E7%BD%91%E7%AB%99%E5%BA%94%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://rudy-zhang.me/2015/04/06/网站应对大数据量高并发的挑战/</id>
    <published>2015-04-06T13:12:52.000Z</published>
    <updated>2015-05-24T13:51:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使用不同的架构和解决方案。架构的改变和升级，往往意味着成本，所有没有最好的架构，只有最适合的架构。</p>
<p>应对数据量和负载的压力，可以从以下几个方面入手:</p>
<ul>
<li>硬件性能挖掘</li>
<li>数据库和存储</li>
<li>应用程序架构<br>每一个方面里都有非常多的技术</li>
</ul>
<h2 id="硬件性能挖掘">硬件性能挖掘</h2><p>硬件性能是有上限的，超过了就必须升级硬件，所以硬件是基础。</p>
<p>但是并不是一味的堆积硬件就可以了，要理解硬件的细节，如mysql的多线程写入机制，cpu寻址方式，顺序写和随机写的存储分布。不仅仅是购买硬件而已，但是核心是，理解硬件，理解系统级的处理机制，来做优化。</p>
<p>这样才能最大限度地挖掘硬件本省的性能，提供更好的服务。</p>
<h2 id="数据库和存储">数据库和存储</h2><p>大文件，或者大量的静态文件，使用静态存储，云存储</p>
<h3 id="建立恰当的索引">建立恰当的索引</h3><h3 id="数据库连接线程池缓存">数据库连接线程池缓存</h3><h3 id="分库/分表/分区">分库/分表/分区</h3><p>MySQL数据库表一般承受数据量在百万级别，再往上增长，各项性能将会出现大幅度下降，因此，当我们预见数据量会超过这个量级的时候，建议进行分库/分表/分区等操作。<br>一个主库一个从库、到一个主库多个从库、 然后到多个主库多个从库。从库做备份，或者作为读写分离的库。<br>多个库之间使用日志同步。</p>
<h3 id="拆分方式：水平拆分VS垂直拆分">拆分方式：水平拆分VS垂直拆分</h3><ul>
<li>垂直拆分 ：是指按功能模块拆分，比如可以将群组相关表和照片相关表存放在不同的数据库中，这种方式多个数据库之 间的表结构不同 。（豆瓣 的 各核心业务/模块（书籍、电影、音乐）相对独立，数据的增加速度也比较平稳。适合垂直拆分）</li>
<li>水平拆分 ：而水平拆分是将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构 完全相同 。</li>
</ul>
<h3 id="按索引_/_映射表对应">按索引 / 映射表对应</h3><p>建立一个索引表，保存每个用户的ID和数据库ID的对应关系，每次读写用户数据时先从这个表获取对应数据库。新用户注册后，在所有可用 的数据库中随机挑选一个为其建立索引。</p>
<h3 id="读写分离">读写分离</h3><p>读写分离，主库写，从库读。</p>
<h3 id="减少数据库写">减少数据库写</h3><p>先将修改请求生效在cache中，让外界查询显示正常，然后将这些sql修改放入到一个队列中存储起来，队列满或者每隔一段时间，合并为一个请求到数据库中更新数据库</p>
<h2 id="应用程序架构">应用程序架构</h2><h3 id="负载均衡">负载均衡</h3><p>Web负载均衡（Load Balancing），作用在Web系统的外部网络环境，简单地说就是给我们的服务器集群分配“工作任务”，而采用恰当的分配方式。对于保护处于后端的Web服务器来说，非常重要。策略有很多</p>
<h4 id="HTTP重定向">HTTP重定向</h4><p>Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。<br>应用：重定向到距离近的镜像去下载。</p>
<h4 id="反向代理负载均衡">反向代理负载均衡</h4><p>反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。把HTTP请求分配道不同的服务器上</p>
<h4 id="IP负载均衡">IP负载均衡</h4><p>IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。这种方式，也被称为“四层负载均衡”。</p>
<h4 id="DNS负载均衡">DNS负载均衡</h4><p>DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。</p>
<h4 id="DNS/GSLB负载均衡">DNS/GSLB负载均衡</h4><p>我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在<strong>同一个域名映射为多IP</strong>的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。<strong>一般情况下都是按照地理位置，将离用户近的IP返回给用户</strong>，减少网络传输中的路由节点之间的跳跃消耗。<br><strong>应用</strong>：CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。</p>
<h3 id="在Web服务器和数据库之间建立缓存">在Web服务器和数据库之间建立缓存</h3><p>80%的请求只关注在20%的热点数据上。因此，我们应该建立Web服务器和数据库之间的缓存机制。用磁盘作为缓存，也可以用内存缓存的方式。通过它们，<strong>将大部分的热点数据查询，阻挡在数据库之前</strong>。 </p>
<h4 id="页面静态化">页面静态化</h4><p>页面上的大部分内容在很长一段时间内，可能都是没有变化的。生成的静态html页面缓存到Web服务器的磁盘本地。直接将本地磁盘文件返回给用户。</p>
<h4 id="单台/集群内存缓存">单台/集群内存缓存</h4><p>一旦Web系统规模变大，例如当我有100台的Web服务器的时候。那样这些磁盘文件，将会有100份，这个是资源浪费，也不好维护。这个时候有人会想，可以集中一台服务器存起来<br>内存缓存的选择，主要有<strong>redis/memcache</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>