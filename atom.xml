<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Rudy's Blog]]></title>
  <subtitle><![CDATA[seize the day]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://rudy-zhang.me/"/>
  <updated>2015-05-25T23:40:53.184Z</updated>
  <id>http://rudy-zhang.me/</id>
  
  <author>
    <name><![CDATA[Rudy Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[linux命令sed和awk]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E5%91%BD%E4%BB%A4sed%E5%92%8Cawk/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux命令sed和awk/</id>
    <published>2015-05-25T23:39:28.000Z</published>
    <updated>2015-05-25T23:40:53.184Z</updated>
    <content type="html"><![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p>
<h3 id="常见应用">常见应用</h3><ol>
<li>抽区域</li>
<li>匹配正则表达式</li>
<li>比较域</li>
<li>增加，附加，替换</li>
</ol>
<h3 id="执行过程">执行过程</h3><p>sed一次处理一行或多行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行或多行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向或写入命令存储输出。</p>
<h3 id="调用方式">调用方式</h3><ul>
<li>命令行输入</li>
</ul>
<p>sed [选项] ‘sed命令’ 输入文件</p>
<ul>
<li>使用sed脚本<br>sed [选项] –f sed脚本文件 输入文件</li>
</ul>
<h3 id="常用选项">常用选项</h3><p>-n：不打印，不写编辑行到标准输出，缺省情况下打印所有行[编辑/未编辑]p命令可以打印编辑行</p>
<p>-c：下一命令是编辑命令，使用多项编辑时加入此选项</p>
<p>-f： 调用sed脚本 sed –f sedScriptFile targetFile</p>
<p>-i：将修改附加到源文件上</p>
<h3 id="使用技巧">使用技巧</h3><p>重定向sed结果输出<br>$sed ‘sed-command’ inputfile &gt; outputfile</p>
<p>定位内容的方式</p>
<p><code>x</code> 行x</p>
<p><code>x,y</code> 行x到行y</p>
<p><code>/pattern/</code> 模式</p>
<p><code>/pattern/pattern/</code> 两个模式</p>
<p><code>/pattern/,x</code>     模式+行【在给定行号上查询模式】</p>
<p><code>X,y</code> /pattern/ 通过行号和模式查询匹配行</p>
<p><code>X,y!</code> 不包含指定行号</p>
<h3 id="基本的sed命令">基本的sed命令</h3><p>P 打印匹配行 print</p>
<p>= 打印匹配行行号</p>
<p>a\ 定位行号后附加新文本信息 append</p>
<p>i\ 定位行号后插入   insert</p>
<p>d 删除定位行   delete</p>
<p>c\ 用新文本替换定位文本   change</p>
<p>s 使用替换模式替换相应模式 </p>
<p>r 从另一个文件中读文本  read</p>
<p>w 写文本到一个文件   write</p>
<p>q 第一个模式匹配完成后退出或立即退出</p>
<p>{} 定位执行命令组</p>
<p>n 从另一个文件中读文本下一行，并附加在下一行</p>
<p>g 将模式2黏贴到/pattern n/</p>
<p>y 传送字符</p>
<h3 id="实例：">实例：</h3><ul>
<li>显示文本</li>
</ul>
<p><code>$sed -n &#39;1,4p&#39; file</code></p>
<p>显示1-4行</p>
<p><code>$sed -n &#39;4,/Str/p&#39;</code></p>
<p>显示第4行到匹配到Str的一行，/str/代表匹配到的一行</p>
<ul>
<li>插入修改文本</li>
</ul>
<p><code>$sed &#39;/str/a\ &quot;inserted line&quot;&#39; file</code></p>
<p>在满足条件的行后，插入内容</p>
<p><code>sed &#39;/str/i\ &quot;appended line&quot;&#39; file</code></p>
<p>在满足条件的行前插入内容</p>
<p><code>$sed &#39;3 c\ &quot;changed line&quot;&#39; file</code></p>
<p>满足条件的行，整行替换掉</p>
<ul>
<li>删除文本</li>
</ul>
<p><code>$sed &#39;1,3d&#39; file</code></p>
<p>删除1-3行</p>
<p><code>$sed &#39;/str/d&#39; file</code></p>
<p>删除匹配行</p>
<p><code>$sed -n &#39;/Begin/,/End/p&#39; file | more</code></p>
<p>删除两个匹配行之间的数据</p>
<ul>
<li>替换文本</li>
</ul>
<p>格式：<code>[address[,address]] s/pattern-find/replacement-pattern/[g,p,w,n]</code></p>
<p>n    1到512之间的一个数字，表示对本模式中指定模式第n次出现的情况进行替换。</p>
<p>g    对模式空间所有出现的情况进行全局更改【缺省只替换首次出现的模式 】</p>
<p>p    打印模式空间的内容</p>
<p>w    file</p>
<p><code>$sed &#39;s/str/tostr/&#39; file</code> </p>
<p>替换每一行首次出现的str为tostr</p>
<p><code>$sed &#39;s/str/tostr/g&#39; file</code></p>
<p>替换所有的行内，出现的所有str为tostr</p>
<p><code>$sed &#39;s/str/tostr/w output&#39; file</code></p>
<p>替换后重定向到output</p>
<p>转换字符</p>
<p><code>sed &#39;y/cp/wd/&#39; test.txt</code></p>
<p>c转换成w，p转换成d</p>
<ul>
<li>Shell向sed传值</li>
</ul>
<p><code>echo $input | sed &#39;s/bb/&#39;$str&#39;/&#39;</code></p>
<p><code>echo $input | sed &quot;s/bb/$str/&quot;</code></p>
<h2 id="awk">awk</h2><h3 id="主要功能-1">主要功能</h3><p>awk是一种用于处理文本的工具，主要用于格式化报文，或从一个大文本中抽取数据。</p>
<h3 id="执行过程-1">执行过程</h3><p>awk每次读入一行，执行’ ‘中的内容，按模式匹配来采取动作</p>
<h3 id="格式">格式</h3><p><code>awk &#39;pattern+{action}&#39; file</code></p>
<p>pattern用于筛选查询匹配行，决定了动作何时触发，可以使用条件语句，正则表达式</p>
<p>action用于对筛选后的内容进行处理</p>
<p>BEGIN可以设置计数和打印头（可选）</p>
<p>END打印输出文本总数和结尾状态标识(可选)</p>
<h3 id="常用参数">常用参数</h3><p>-F 指定读取一行数据的分隔符，默认为空格<br>-f 指定处理程序的脚本文件，这个文件必须符合awk语法</p>
<h2 id="调用方式：">调用方式：</h2><p><code>awk –f awk-script-file input-files</code></p>
<h3 id="常用内置参数">常用内置参数</h3><p><code>$0,$1,....$n</code>   <code>$0</code>代表当前行的内容，<code>$i</code>代表当前行被分割后的第i个字段的内容</p>
<p>ARGC 命令行参数个数</p>
<p>ARGV 命令行参数排列</p>
<p>ENVIRON 支持队列中系统环境变量的使用</p>
<p>FILENAME 实际操作的文件名</p>
<p>FNR 浏览文件记录数，&lt;=NR</p>
<p>FS <strong>设置输入域分隔符，等价于命令行-F选项</strong> ，可在BEGIN中进行设置,然后执行的时候均以设置的符号为分隔符</p>
<p>NF <strong>浏览记录 域的个数</strong>，在记录被读取时设置【number of fields】一共有多少个域</p>
<p>NR <strong>已读取记录数</strong>【number of rows】</p>
<p>RS 控制记录分隔符，缺省：新行\n，Row Separator记录分隔符，可以根据具体数据需求，设置读取一条记录的区间</p>
<p>OFS <strong>输出域的分隔符</strong>，缺省空格，输出结果 print $1,$2默认加的是空格，可以在BEGIN中设置，改为其他分隔符</p>
<p>ORS 输出记录的分隔符，缺省：新行\n，整体记录的</p>
<h3 id="实例">实例</h3><ul>
<li>打印</li>
</ul>
<p>打印所有行</p>
<p><code>awk &#39;{print $0}&#39; file</code></p>
<p>打印包含头尾</p>
<p><code>awk &#39;BEGIN{print &quot;Name Age&quot;}{print $1,$2}END{print &quot;END_OF_REPORT&quot;}&#39;</code></p>
<ul>
<li>使用判断语句</li>
</ul>
<p><code>&lt;  &lt;=  &gt;  &gt;=  ==  !=</code>  </p>
<p>~匹配正则   !~不匹配正则</p>
<p><code>|| &amp;&amp; !</code> 或且非</p>
<p><code>awk &#39;{if($2!~/Rudy/) print $0}&#39; content</code></p>
<p><code>awk &#39;{if($1==&quot;001&quot; &amp;&amp; $2~/^Ru/) print $0}&#39; content</code></p>
<ul>
<li>使用内置的变量 </li>
</ul>
<p><code>awk &#39;BEGIN{OFS=&#39;\t&#39;}{print NF,NR,$0}END{print FILENAME}&#39; content &gt; output</code></p>
<p>设置输出的分隔符为’\t’，输出一些内置变量的信息</p>
<ul>
<li>AWK变量中的字符串和数字的转换</li>
</ul>
<p>字符串-&gt;整数</p>
<p><code>$ awk &#39;BEGIN{a=&quot;100&quot;;b=&quot;10test10&quot;;print (a+b+0);}&#39;</code></p>
<p><code>110</code></p>
<p>只需要将变量通过”+”连接运算。自动强制将字符串转为整型。非数字变成0，发现第一个非数字字符，后面自动忽略。</p>
<p>整数-&gt;字符串</p>
<p><code>awk &#39;BEGIN{a=100;b=100;c=(a&quot;&quot;b);print c}&#39;</code>      </p>
<p><code>100100</code></p>
<p>只需要将变量与””符号连接起来运算即可。</p>
<ul>
<li>使用内置的字符串函数</li>
</ul>
<p><code>gsub(r,s)</code> 在整个$0中<strong>用s代替r</strong></p>
<p><code>gsub(r,s,t)</code> 在整个t中用s替代r</p>
<p><code>index(s,t)</code> 返回s中字符串t的第一位置</p>
<p><code>length(s)</code> <strong>返回s长度</strong></p>
<p><code>match(s,r)</code> 测试s是否包含匹配r的字符串</p>
<p><code>split(s,a,fs)</code> 在fs上将s分成序列a.fs为分隔符</p>
<p><code>sprint(fmt,exp)</code> 返回经fmt格式化后的exp</p>
<p><code>sub(r,s)</code> 用$0中最左边最长的子串代替s</p>
<p><code>substr(s,p)</code> 返回字符串s中从p开始的后缀部分</p>
<p><code>substr(s,p,n)</code> 返回字符串s中从p开始长度为n的后缀部分</p>
<p>替换字符串</p>
<p><code>awk &#39;BEGIN{FS=&#39;\t&#39;}{gsub(/Rudy/,&quot;RUDY&quot;);{print $0}}&#39; content</code></p>
<ul>
<li>使用printf进行格式化输出</li>
</ul>
<p><code>%c</code> ASCII字符</p>
<p><code>%d</code> 整数</p>
<p><code>%e</code> 浮点数，可科学计数法</p>
<p><code>%f</code> 浮点数，小数形式</p>
<p><code>%g</code> 由awk决定使用哪种浮点数转换e或f</p>
<p><code>%o</code> 八进制</p>
<p><code>%s</code> 字符串</p>
<p><code>%x</code> 十六进制</p>
<p>格式化输出一个字符串</p>
<p><code>awk -F&#39;\t&#39; &#39;{printf(&quot;%s\t%s\n&quot;,$2,$1)}&#39; content</code></p>
<ul>
<li>向awk中传递参数</li>
</ul>
<p><code>awk &#39;{if($3&lt;=AGE){print $0}}&#39; AGE=20 content</code> </p>
<ul>
<li><p>写一个awk脚本</p>
<pre><code><span class="comment">#!bin/awk -f</span>
BEGIN{
        FS=<span class="string">"['\t']"</span>
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="string">"NUMBER"</span>,<span class="string">"NAME"</span>,<span class="string">"AGE"</span>)
}
{
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%s</span>\t<span class="variable">%s</span>\t<span class="variable">%s</span>\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)
}
END{
        <span class="keyword">print</span> <span class="string">"END OF FILE"</span>
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="sed">sed</h2><h3 id="主要功能">主要功能</h3><p>sed，stream editor。是一个”非交互式“字符流编辑器。输入流通过程序并输出到标准输出端。<br>sed主要用来自动编辑一个或者多个文件（替换，插入，删除，追加，更改）</p]]>
    </summary>
    
      <category term="linux命令" scheme="http://rudy-zhang.me/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux正则表达式和grep]]></title>
    <link href="http://rudy-zhang.me/2015/05/26/linux%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cgrep/"/>
    <id>http://rudy-zhang.me/2015/05/26/linux正则表达式和grep/</id>
    <published>2015-05-25T23:27:44.000Z</published>
    <updated>2015-05-25T23:38:55.906Z</updated>
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk: 伪装成实用程序的强大编程语言，主要用于文本处理</li>
</ul>
<h3 id="常用符号">常用符号</h3><h4 id="基本元字符">基本元字符</h4><p><code>^</code> 行首定位符，表示以..开始</p>
<p><code>$</code> 行尾定位符，表示以..结束</p>
<p><code>.</code>  匹配单个字符</p>
<p><code>*</code> 匹配0个或任意多个字符</p>
<p><code>[]</code> 匹配[]中出现字符范围内的一个字符</p>
<p><code>\</code> 用来转义元字符，如{m,n},启用扩展元字符\? +</p>
<h4 id="扩展元字符">扩展元字符</h4><p><code>?</code> 匹配0个或者1个</p>
<p><code>+</code> 匹配1个或者多个</p>
<p><code>|</code> 或者</p>
<p><code>()</code>分组符号</p>
<h4 id="特殊匹配字符">特殊匹配字符</h4><p><code>[:alnum:]</code> 字母与数字字符</p>
<p><code>[:alpha:]</code> 字母</p>
<p><code>[:ascii:]</code> ASCII字符</p>
<p><code>[:blank:]</code> <strong>空格或制表符</strong></p>
<p><code>[:cntrl:]</code> ASCII控制字符</p>
<p><code>[:digit:]</code> 数字</p>
<p><code>[:graph:]</code> 非控制、空格字符</p>
<p><code>[:lower:]</code> 小写字母</p>
<p><code>[:print:]</code> 可打印字符</p>
<p><code>[:punct:]</code> 标点符号字符</p>
<p><code>[:space:]</code> <strong>空白字符，包括垂直制表符</strong></p>
<p><code>[:upper:]</code> 大写字母</p>
<p><code>[:xdigit:]</code> 十六进制数字</p>
<h3 id="实例">实例</h3><ul>
<li>^ $<br><code>ls -l | grep ^d</code></li>
</ul>
<p>匹配以d开头的所有内容</p>
<ul>
<li><code>ls -l | grep d$</code></li>
</ul>
<p>匹配以d结束的所有内容</p>
<ul>
<li><code>^$</code> </li>
</ul>
<p>匹配空行</p>
<ul>
<li><code>^.$</code></li>
</ul>
<p>只包含一个字符的</p>
<ul>
<li><code>* ？ +</code></li>
</ul>
<p><code>compu*ter</code> 匹配u，重复0次或多次</p>
<p><code>compu?ter</code> 匹配0个或者1个u</p>
<p><code>compu+ter</code> 匹配1个或多个u</p>
<p><strong>需要注意的是+和？是扩展字符，需要看具体使用正则表达式的环境<br>如果使用grep需要使用-E指定为扩展模式才能正常使用+和？</strong></p>
<ul>
<li><code>\</code>可以屏蔽一些特殊字符，如<code>$  .  ‘  “  *  [  ]  ^  |  (  )  \  +  ?</code></li>
</ul>
<p><code>\.pass</code>  匹配<code>*.pass</code></p>
<ul>
<li><code>[]</code></li>
</ul>
<p><code>[1234]</code> 匹配1,2,3,4中的一个</p>
<p><code>[1-9]</code> 数字1-9中的一个</p>
<p><code>[A-Za-z]</code> 所有字母</p>
<p><code>[^0-9]</code> 一个非数字的字符</p>
<ul>
<li><code>\{\}</code></li>
</ul>
<p><code>A\{2\}B</code>   匹配AAB</p>
<p><code>A\{4,\}B</code>   匹配A出现至少4次B</p>
<p><code>A\{2,4\}B</code>  匹配A出现在2至4次之间</p>
<h2 id="grep">grep</h2><p>功能：grep是文本搜索工具，使用正则表达式搜索文本并打印匹配行</p>
<p>格式：<code>grep [options] PATTERN [Files]</code></p>
<p>注：</p>
<p>输入字符串<strong>作为参数，最好双引号括起</strong>  “mystr”</p>
<p>在<strong>调用变量时，也使用双引号括起</strong>  “$MYSTR”</p>
<p>使用<strong>正则[匹配模式]是，应使用单引号括起</strong>  ‘49[32]’</p>
<p>常用选项：</p>
<p><code>-c</code> 只输出匹配的行数,而不输出匹配的行</p>
<p><code>-i</code> 不区分大小写</p>
<p><code>-n</code> 显示匹配行及行号</p>
<p><code>-q</code>  安静模式，不输出任何东西，如果找到了返回0</p>
<p><code>-E</code> 启用扩展表达式，可使用扩展字符，如：+ ? | () {} , 或者直接使用egrep</p>
<p><code>-v</code> 显示不包含匹配文本的所有行</p>
<p>实例：</p>
<ol>
<li><p>在多个文件中查找<br><code>grep “sort” filea fileb</code>  在filea,fileb中查找</p>
</li>
<li><p>计算匹配行数<br><code>grep -c &quot;sort&quot; file</code></p>
</li>
<li><p>使用正则表达式查找<br><code>grep &#39;48[34]&#39; file</code></p>
</li>
<li><p>使用扩展元字符<br><code>grep -E &#39;aaa|bbb&#39; file</code></p>
</li>
<li><p>匹配空行<br><code>grep &#39;^$&#39; file</code></p>
</li>
<li><p>特殊匹配字符，grep 允许使用国际字符串模式匹配或匹配模式的类名<br><code>grep ‘5[[:upper:]] [[:upper:]]’</code> data  5开头，两个大写</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="正则表达式">正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式，常用于：</p>
<ul>
<li>grep:从特定的文件中或从标准输入中查找含有某个字符串的行</li>
<li>sed :从输入中读取信息，经过编辑后输出</li>
<li>awk:]]>
    </summary>
    
      <category term="正则表达式，linux命令" scheme="http://rudy-zhang.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8Clinux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://rudy-zhang.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming学习文档]]></title>
    <link href="http://rudy-zhang.me/2015/05/24/HadoopStreaming/"/>
    <id>http://rudy-zhang.me/2015/05/24/HadoopStreaming/</id>
    <published>2015-05-24T01:30:00.000Z</published>
    <updated>2015-05-24T08:54:54.516Z</updated>
    <content type="html"><![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架允许任何程序语言实现的程序（只要该程序支持标准输入输出即可），在Hadoop MapReduce中使用，方便已有程序向Hadoop平台移植。</p>
<h2 id="Streaming原理">Streaming原理</h2><p>使用Java实现了一个包装<strong>用户程序</strong>（mapper，reducer方法）的MapReduce程序，该程序调用MapReduce的Java接口，创建一个<strong>新的进程</strong>包装用户程序，将数据通过<strong>管道</strong>传递给包装的用户程序。</p>
<p><img src="http://i.imgur.com/dlebclb.jpg" alt=""></p>
<h2 id="考虑的问题">考虑的问题</h2><p>在实际的开发过程中，开发人员需要考虑下面几个方面的问题，其中1,2是必须实现的：</p>
<ol>
<li>Mapper程序：对输入key/value数据进行处理；</li>
<li>Reducer程序：对mapper的输出进行归并处理；</li>
<li>Combiner：在本地对一个计算节点上的mapper输出进行归并；</li>
<li>Partitioner：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li>InputFormat/OutputFormat：对输入数据进行切分，保存输出数据。</li>
</ol>
<h2 id="执行">执行</h2><pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “cat” \
    -reducer “cat” \
    -jobconf mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">1</span>\
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”dist-sort”
</code></pre><p>这是一个实现了分布式排序的程序。可以通过shell脚本，shell命令，或者其它语言的<strong>可执行程序</strong>来进行mapper和reducer程序的运行</p>
<h2 id="常用参数的使用">常用参数的使用</h2><p>例1：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">2</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"Python/bin/python $app/mapper.py"</span> \
    -reducer <span class="string">"Python/bin/python $app/reducer.py"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archive</span>
</code></pre><p>-D表示配置参数，剩余项是和输入输出相关的文件和可执行程序</p>
<p><code>-D mapred.job.name=&quot;jobname&quot; \</code>,作业名</p>
<p><code>-D mapred.job.priority=VERY_HIGH \</code> 作业优先级</p>
<p><code>-D mapred.job.map.capacity=500 \</code>,最多同时运行map任务数</p>
<p><code>-D mapred.job.reduce.capacity=300 \</code>最多同时运行reduce任务数</p>
<p><code>-D mapred.map.tasks=500 \</code>,map任务个数</p>
<p><code>-D mapred.reduce.tasks=300 \</code>,reduce任务个数</p>
<p>capacity是同时运行任务的个数，tasks是运行任务的总的个数，一般task更大，capacity是同时运行任务的上限</p>
<p><code>-D stream.num.map.output.key.fields=2 \</code>,表示在第2个分隔符（默认为\t）之前作为key，之后作为value，也可以使用参数<code>-D stream.map.output.field.separator=. \</code>指定分隔符为’.’或者其它字符。</p>
<p><code>-mapper &quot;Python/bin/python $app/mapper.py&quot; \</code>指定map任务，需要可执行，读入标准输入流，输出标准输出流</p>
<p><code>-reducer &quot;Python/bin/python $app/reducer.py&quot; \</code>指定reducer任务</p>
<p><code>-input $input \</code>指定输入文件</p>
<p><code>-output $output \</code>指定输出文件</p>
<p><code>-cacheArchive $archive</code>分发压缩包。<code>$archive</code>格式为<code>hdfs://host:port/path/to/archivefile#linkname</code>，表示hdfs上这个压缩包的路径为<code>hdfs://host:port/path/to/archivefile</code>,可以使用<code>linkname/children/path</code>访问这个压缩包的内容</p>
<p>例2：</p>
<pre><code><span class="variable">$hadoop</span> streaming \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">3</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.partitioner</span><span class="class">.options</span>=<span class="string">"-k1,1"</span> \
    -D mapred<span class="class">.text</span><span class="class">.key</span><span class="class">.comparator</span><span class="class">.options</span>=<span class="string">"-k1,1 -k3,3nr"</span> \
    -D mapred<span class="class">.job</span><span class="class">.name</span>=<span class="string">"jobname"</span> \
    -D mapred<span class="class">.job</span><span class="class">.priority</span>=VERY_HIGH \
    -D mapred<span class="class">.job</span><span class="class">.map</span><span class="class">.capacity</span>=<span class="number">500</span> \
    -D mapred<span class="class">.job</span><span class="class">.reduce</span><span class="class">.capacity</span>=<span class="number">300</span> \
    -D mapred<span class="class">.map</span><span class="class">.tasks</span>=<span class="number">500</span> \
    -D mapred<span class="class">.reduce</span><span class="class">.tasks</span>=<span class="number">300</span> \
    -mapper <span class="string">"cat"</span> \
    -reducer <span class="string">"cat"</span> \
    -<span class="tag">input</span> <span class="variable">$input</span> \
    -output <span class="variable">$output</span> \
    -cacheArchive <span class="variable">$archives</span>
</code></pre><p><code>-D mapred.text.key.partitioner.options=&quot;-k1,1&quot; \</code>表示对key进行分割，分割符默认为\t，取分割后的1,1部分作为主key，剩下的作为辅key</p>
<p><code>-D mapred.text.key.comparator.options=&quot;-k1,1 -k3,3nr&quot; \</code>指定排序依据，主key按第一部分排字母序，辅key按第三部分数字序倒序排</p>
<p>例3：</p>
<pre><code><span class="variable">$HADOOP_HOME</span>/bin/hadoop streaming \
    -D stream<span class="class">.map</span><span class="class">.output</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D stream<span class="class">.num</span><span class="class">.map</span><span class="class">.output</span><span class="class">.key</span><span class="class">.fields</span>=<span class="number">4</span> \
    -D map<span class="class">.output</span><span class="class">.key</span><span class="class">.field</span><span class="class">.separator</span>=. \
    -D num<span class="class">.key</span><span class="class">.fields</span><span class="class">.for</span><span class="class">.partition</span>=<span class="number">2</span> \ 
    -<span class="tag">input</span> /user/test/<span class="tag">input</span> -output /user/test/output \
    -mapper “mymapper.sh” -reducer “ myreducer.sh” \
    -partitioner org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.lib</span><span class="class">.KeyFieldBasedPartitioner</span> \
    -file /home/work/mymapper<span class="class">.sh</span> \
    -file /home/work/myreducer<span class="class">.sh</span> \
    -jobconf mapred<span class="class">.job</span><span class="class">.name</span>=”jobname”
</code></pre><p><code>-D stream.map.output.field.separator=. \</code><br><code>-D stream.num.map.output.key.fields=4 \</code><br>表示输出分隔符为’.’，并且第4个.之后为value，之前为key</p>
<p><code>-D map.output.key.field.separator=. \</code><br><code>-D num.key.fields.for.partition=2 \</code><br>表示key内的分隔符为’.’，第2个’.’之前作为主key，之后作为辅key</p>
<p><code>-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner \</code>指定要使用KeyFieldBasedPartitioner，也就是key域内的partioner。这样的话会把主key的内容作为partition的依据，相同的主key分配到同一个reducer中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hadoop_Streaming是什么">Hadoop Streaming是什么</h2><p>Hadoop MapReduce和HDFS使用Java实现，默认是Java接口，另外提供了C++编程接口和Streaming框架。</p>
<p>Streaming框架]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop基本原理]]></title>
    <link href="http://rudy-zhang.me/2015/05/23/Hadoop%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://rudy-zhang.me/2015/05/23/Hadoop基本原理/</id>
    <published>2015-05-23T02:38:00.000Z</published>
    <updated>2015-05-24T14:11:32.606Z</updated>
    <content type="html"><![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据处理速度快（Velocity） 数据真实性高（Veracity） 合起来被称为4V。</p>
<p>处理大数据是为了挖掘数据中的隐含价值</p>
<h4 id="如何处理大数据？">如何处理大数据？</h4><p>集中式计算VS分布式计算</p>
<p>集中式计算：通过不断增加处理器的个数来增强耽搁计算机的计算能力，从而提高处理的速度。需要的内存很大，计算的速度很快。</p>
<p>分布式计算：一组通过网络连接的计算机，形成一个分散的系统。将需要处理的大量数据分散成多个部分，交由系统中的耽搁计算机分别处理，最后将这些计算结果合并得到最终结果。（MapReduce的核心思想）</p>
<h3 id="Hadoop是怎么产生的">Hadoop是怎么产生的</h3><h4 id="技术基础">技术基础</h4><p>google三驾马车：GFS、MapReduce和BigTable。Hadoop是在google三驾马车基础上的开源实现。</p>
<ol>
<li>GFS（Google File System）分布式文件系统，对应Hadoop当中的HDFS。</li>
<li>MapReduce分布式计算框架，也是Hadoop处理大数据的核心思想。</li>
<li>BigTable是基于GFS的数据存储系统，对应Hadoop的HBase。</li>
</ol>
<h4 id="三大分布式计算系统">三大分布式计算系统</h4><p>Hadoop，Spark，Storm是主流的三大分布式计算系统</p>
<p>Spark VS Hadoop</p>
<p>Hadoop使用硬盘来存储数据，而Spark是将数据存在内存中的，因此Spark何以提供超过Hadoop 100倍的计算速度。内存断电后会丢失，所以Spark不<br>适用于需要长期保存的数据。</p>
<p>Storm VS Hadoop</p>
<p>Storm在Hadoop基础上提供了实时运算的特性，可以实时处理大数据流。不同于Hadoop和Spark，Storm不尽兴数据的手机和存储工作，直接通过网络接受并实时处理数据，然后直接通过网络实时传回结果。</p>
<p>所以三者适用于的应用场景分别为：</p>
<ol>
<li>Hadoop常用于离线的复杂的大数据处理</li>
<li>Spark常用于离线的快速的大数据处理</li>
<li>Storm常用于在线实时的大数据处理</li>
</ol>
<h3 id="Hadoop定义">Hadoop定义</h3><h4 id="Hadoop是什么">Hadoop是什么</h4><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架</p>
<h4 id="Hadoop特点">Hadoop特点</h4><ol>
<li>可靠。Hadoop假设计算元素和存储会失败，所以会维护多个工作数据的副本，对失败的节点会重新处理</li>
<li>高效。通过并行方式工作，加快处理速度。</li>
<li>可伸缩。可以处理PB级的数据。</li>
<li>高扩展。可以方便地扩展到数以千计的节点。</li>
<li>低成本。Hadoop是开源的，Hadoop节点可以是很便宜的机器。</li>
</ol>
<h4 id="应用场景">应用场景</h4><p>Hadoop适用于：海量数据，离线数据，复杂数据</p>
<p>场景1：数据分析，如海量日志分析，商品推荐，用户行为分析</p>
<p>场景2：离线计算，（异构计算+分布式计算）天文计算</p>
<p>场景3：海量数据存储，如Facebook的存储集群。</p>
<p><a href="http://cloud.zol.com.cn/441/4415033_all.html" target="_blank" rel="external">更多应用场景</a></p>
<h3 id="Hadoop原理">Hadoop原理</h3><h4 id="HDFS">HDFS</h4><p>HDFS（Hadoop File System），是Hadoop的分布式文件存储系统</p>
<ol>
<li>将大文件分解为多个Block，每个Block保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。</li>
<li>默认每个Block保存3个副本，64M为1个Block。</li>
<li>将Block按照key-value映射到内存当中。</li>
</ol>
<p>HDFS架构图如下：</p>
<p><img src="http://i.imgur.com/ZliSEXb.png" alt=""></p>
<h5 id="NameNode">NameNode</h5><p>HDFS使用主从结构，NameNode是Master节点，是领导。所有的客户端的读写请求，都需要首先请求NameNode。</p>
<p>NameNode存储</p>
<ol>
<li>fsimage：元数据镜像文件（文件系统的目录树，文件的<strong>元数据</strong>信息）。元数据信息包括文件的信息，文件对应的block信息（版本信息，类型信息，和checksum），以及每一个block所在的DataNode的信息。</li>
<li>edits：元数据的操作日志</li>
</ol>
<h5 id="DataNode">DataNode</h5><p>DataNode是Slave，负责真正存储所有的block内容，以及数据块的读写操作</p>
<p>NameNode，DataNode，rack只是一些逻辑上的概念。NameNode和DataNode可能是一台机器也可能是，相邻的一台机器，很多DataNode可能处于同一台机器。rack是逻辑上比DataNode更大的概念，可能是一台机器，一台机柜，也可能是一个机房。通过使文件的备份更广泛地分布到不同的rack，DataNode上可以保证数据的可靠性。</p>
<h5 id="HDFS写入数据">HDFS写入数据</h5><ol>
<li>Client拆分文件为64M一块。</li>
<li>Client向NameNode发送写数据请求。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode。</li>
<li>Client向DataNode发送block1,2,3….；发送过程是以流式写入。流式写入，数据流向为DataNode1-&gt;DataNode2-&gt;DataNode3(1,2,3为通过规则选出来的可用的DataNode)</li>
<li>发送完毕后告知NameNode</li>
<li>NameNode告知Client发送完成</li>
</ol>
<p>在写数据的时候：</p>
<ul>
<li>写1T文件，我们需要3T的存储，3T的网络流量贷款。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ul>
<h5 id="HDFS读取数据">HDFS读取数据</h5><ol>
<li>Client向NameNode发送读请求</li>
<li>NameNode查看MetaData信息，返回文件的block位置</li>
<li>根据一定规则（优先选择附近的数据），按顺序读取block</li>
</ol>
<p><a href="http://www.weixuehao.com/archives/596" target="_blank" rel="external">更多内容</a></p>
<h4 id="MapReduce">MapReduce</h4><p>Map是把一组数据一对一的<strong>映射</strong>为另外的一组数据，其映射的规则由一个<strong>map函数</strong>来指定。Reduce是对一组数据进行<strong>归约</strong>，这个归约的规则由一个<strong>reduce函数</strong>指定。</p>
<p>整个的MapReduce执行过程可以表示为：</p>
<p><code>(input)&lt;k1, v1&gt; =&gt; map =&gt; &lt;k2, v2&gt; =&gt; combine =&gt; &lt;k2, v2’&gt; =&gt; reduce =&gt; &lt;k3, v3&gt;(output)</code></p>
<p>也可以表示为流程图：</p>
<p><img src="http://i.imgur.com/yRsLgoK.png" alt=""></p>
<ol>
<li><strong>分割</strong>：把输入数据分割成不相关的若干键/值对（key1/value1）集合，作为input</li>
<li><strong>映射</strong>：这些键/值对会由多个map任务来<strong>并行地处理</strong>。输出一些中间键/值对key2/value2集合</li>
<li><strong>排序</strong>：MapReduce会对map的输出（key2/value2）按照key2进行排序（便于归并）</li>
<li><strong>conbine</strong>：属于同一个key2的所有value2组合在一起作为reduce任务的输入（相当于提前reduce，减小key2的数量，减小reduce的负担）</li>
<li><strong>Partition</strong>：将mapper的输出分配到reducer；（Map的中间结果通常用”hash(key) mod R”这个结果作为标准）</li>
<li><strong>规约</strong>：由reduce任务计算出最终结果并输出key3/value3。</li>
</ol>
<h4 id="程序员需要做的">程序员需要做的</h4><ul>
<li>单机程序需要处理数据读取和写入、数据处理</li>
<li>Hadoop程序需要实现map和reduce函数</li>
<li>map和reduce之间的数据传输、排序，容错处理等由Hadoop MapReduce和HDFS自动完成。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="了解大数据">了解大数据</h3><p>首先，搞清楚hadoop在处理大数据的定位在哪里</p>
<h4 id="什么是大数据？为什么要处理大数据？">什么是大数据？为什么要处理大数据？</h4><p>数据量大（Volume） 数据类别复杂（Variety） 数据]]>
    </summary>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://rudy-zhang.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（二）]]></title>
    <link href="http://rudy-zhang.me/2015/04/22/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B62/"/>
    <id>http://rudy-zhang.me/2015/04/22/一步一步写一个PHP框架2/</id>
    <published>2015-04-22T07:31:44.000Z</published>
    <updated>2015-05-24T08:58:54.266Z</updated>
    <content type="html"><![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%B8%80/">这位大哥</a>,的内容和Codeigniter框架的源码。</p>
<h2 id="程序框架的搭建">程序框架的搭建</h2><p>前提：已经搭建好了一个apache+PHP的开发环境，我使用的是Apache+mod_php5的方式。</p>
<p>在根目录<code>simplemvc</code>下新建以下文件夹</p>
<ul>
<li><code>config</code> 用来存放配置文件</li>
<li><code>controller</code>用来存放控制器</li>
<li><code>lib</code>用来存放引入的库文件</li>
<li><code>model</code>用来存放模型</li>
<li><code>system</code>用来存放系统文件<ul>
<li><code>core</code>核心文件，包括核心controller控制器等，所有的controller都要继承于他</li>
<li><code>lib</code>存放核心的库文件，包括route等</li>
<li><code>app.php</code>应用程序驱动类</li>
</ul>
</li>
<li><code>view</code>用来存放视图</li>
<li><code>index.php</code>项目的入口文件，程序是从这里开始执行的。</li>
</ul>
<h2 id="定义系统路径">定义系统路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#39044;&#23450;&#20041;&#10;define(&#39;SYSTEM_PATH&#39;, dirname(__FILE__).&#39;/system&#39;);&#10;define(&#39;ROOT_PATH&#39;,  substr(SYSTEM_PATH, 0,-7));&#10;define(&#39;SYS_LIB_PATH&#39;, SYSTEM_PATH.&#39;/lib&#39;);&#10;define(&#39;APP_LIB_PATH&#39;, ROOT_PATH.&#39;/lib&#39;);&#10;define(&#39;SYS_CORE_PATH&#39;, SYSTEM_PATH.&#39;/core&#39;);&#10;define(&#39;CONTROLLER_PATH&#39;, ROOT_PATH.&#39;/controller&#39;);&#10;define(&#39;MODEL_PATH&#39;, ROOT_PATH.&#39;/model&#39;);&#10;define(&#39;VIEW_PATH&#39;, ROOT_PATH.&#39;/view&#39;);</span><br></pre></td></tr></table></figure>
<p>预定义一些常量，在之后的程序中我们会使用这些路径。</p>
<h2 id="加载配置文件，和应用程序驱动类">加载配置文件，和应用程序驱动类</h2><h3 id="配置文件">配置文件</h3><p>在config文件夹下的<code>config.php</code><br>··<br>$CONFIG[‘system’][‘db’]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在写第一个PHP框架的时候参考<a href="!http://www.yuansir-web.com/2012/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99php-mvc%E6%A1%86%E6%9E%B6%E4%]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步写一个PHP框架（一）]]></title>
    <link href="http://rudy-zhang.me/2015/04/20/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E4%B8%80%E4%B8%AAPHP%E6%A1%86%E6%9E%B61/"/>
    <id>http://rudy-zhang.me/2015/04/20/一步一步写一个PHP框架1/</id>
    <published>2015-04-20T07:31:44.000Z</published>
    <updated>2015-05-24T08:58:59.649Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
<p>为了更好地理解PHP里面框架的设计，目标是自己写一个简单的PHP MVC框架，一方面可以更深入地学习PHP，一方面也能够更深入地理解框架设计里面的思想。</p>
<h2 id="Apache的工作流程">Apache的工作流程</h2><p>Apache是一个Web服务器，也可以叫做http服务器，因为Apache只能处理http请求。常见的web服务器还有Nginx</p>
<p>Apache的工作流程如下：</p>
<ol>
<li>浏览器向服务器发出HTTP请求(Request)。</li>
<li>服务器收到浏览器的请求数据，经过分析处理，向浏览器输出响应数据（Response）。</li>
<li>浏览器收到服务器的响应数据，经过分析处理，将最终结果显示在浏览器中。</li>
</ol>
<p>Apache和Nginx都属于Web服务器，两者都实现了HTTP 1.1协议。</p>
<p>所以如果有人问FTP协议可以在Apache上工作吗？答案是用Apache FTP Server可以，Apache web服务器不可以。</p>
<p>Apache是用C语言写的，服务器当然要追求高效率。</p>
<h2 id="PHP原理">PHP原理</h2><p>PHP的核心解释器是用C语言写的，相当于我们写了PHP代码，会有一个C语言写好的解释工具一边解释，一边执行。实际上在写PHP的时候就是在使用一个C语言写好的工具，我们的PHP代码就是指挥这个工具的命令。</p>
<p>PHP包括四层体系：</p>
<ol>
<li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分。负责翻译PHP代码，是一切的核心。</li>
<li>Extensions：围绕Zend引擎，通过组件方式提供基础服务。常见内置函数如array是由extension实现的。</li>
<li>Sapi通过一系列的<strong>钩子函数</strong>，使得PHP可以和外围交互数据。如Apache</li>
<li>上层应用：平时写的PHP程序</li>
</ol>
<blockquote>
<p>如果PHP是一辆车，那么车的框架就是PHP本身，Zend是车的引擎（发动机），Ext下面的各种组件就是车的轮子，Sapi可以看做是公路， 车可以跑在不同类型的公路上，而一次PHP程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。</p>
</blockquote>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p><strong>hashtable</strong>是PHP的核心数据结构，数组就是典型的应用。Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表（解决冲突），提供了正向、反向遍历数组的功能。</p>
<p>更详细的内容参考<a href="!http://www.cnblogs.com/zcy_soft/archive/2013/03/14/2959396.html">这里</a></p>
<h2 id="PHP在Apache上运行">PHP在Apache上运行</h2><h3 id="以模块加载的方式运行">以模块加载的方式运行</h3><p>这种方式使用了Apache的Hook机制。所谓Hook机制，就是在自己的程序运行的时候允许别的模块插上一腿。当我们配置Apache服务器的<code>http.config</code>文件时，写入<code>mod_php5.so/php5apache2.dll</code>就是将自定义的函数注入到Apache的请求处理循环当中。在模块化的运行方式中，PHP与Web服务器一起启动并且运行，通过Apache自身的进程线程管理来处理并发的请求。</p>
<h3 id="以CGI，FastCGI方式运行">以CGI，FastCGI方式运行</h3><p>CGI英文叫做公共网关接口，CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。Apache在Http请求的时候会将请求提交给CGI应用程序（php-cgi.exe）解释，解释之后的结果返回给Apache，然后再返回给相应的请求用户。</p>
<p>CGI VS FastCGI</p>
<p>FastCGI是CGI的加强版本，CGI是单进程，多线程的运行方式，程序执行完成之后就会销毁。FastCGI是常驻(long-live)型的CGI.有自身的进程管理器，不必每一次都fork一个进程（CGI解释器）去执行。常见的PHP-FPM是一个PHP FastCGI管理器。</p>
<p>关于更多的对比可以看<a href="http://fifiole.blog.163.com/blog/static/169459225201222962651804/" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>目前在HTTPServer这块基本可以看到有三种stack比较流行：</p>
<p>（1）Apache+mod_php5</p>
<p>（2）lighttp+spawn-fcgi</p>
<p>（3）nginx+PHP-FPM</p>
<p>三者后两者性能可能稍优，但是Apache由于有丰富的模块和功能，目前来说仍旧是老大。有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>完成了一个小项目，使用Apache+MySql+PHP。PHP中使用的框架是CodeIgniter，这是一个轻量易扩展的PHP MVC框架，适用于轻量级的网站搭建。CodeIgniter手册清晰丰富，覆盖了一般网站的所有需求。</p>
]]>
    </summary>
    
      <category term="PHP" scheme="http://rudy-zhang.me/tags/PHP/"/>
    
      <category term="PHP框架" scheme="http://rudy-zhang.me/tags/PHP%E6%A1%86%E6%9E%B6/"/>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何完成一个在线考试的功能]]></title>
    <link href="http://rudy-zhang.me/2015/04/07/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://rudy-zhang.me/2015/04/07/如何完成一个在线考试的功能/</id>
    <published>2015-04-07T00:58:06.000Z</published>
    <updated>2015-05-24T02:27:13.006Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2><h3 id="考卷生成">考卷生成</h3><p>卷子总是由试题组成的，试题包括内容，选项之类的<strong>文本</strong>，以及相关的<strong>图片</strong>。每个试题在数据库中当然只能存一份，否则就浪费了存储空间。很多的OJ题目是随机生成的，一句特定的内容随机生成考题，并且答题结果也是每人一份的，这时候很容易就想到需要中间表来存储这个内容了。</p>
<h3 id="保存现场">保存现场</h3><p>如果使用一个大form，在用户提交考试结果的时候把所有数据提交到server，那中间如果用户不小心退出了，所有的答题内容就<strong>丢失</strong>了。所以需要在用户答题的过程中不断<strong>异步存储</strong>用户答题的结果，使得用户在任何一个时候退出，我们都能够统计出他已经答过的题并且给出分数（或者结果）的。</p>
<h3 id="断线处理">断线处理</h3><p>当用户断线的时候，或者不小心退出了浏览器，系统需要允许用户重新登录，<strong>继续考试</strong>。</p>
<h3 id="倒计时">倒计时</h3><p>倒计时运行在client上，你永远也无法控制client端的人会对代码做什么。在js中添加断点可以停止倒计时空间的运行，所以关于时间必须在server端进行校验，才能规避在时间上作弊的行为。</p>
<h3 id="结算分数">结算分数</h3><p>你永远也无法控制client端的人会对代码做什么，同时开多个窗口可以多次提交结果，甚至可以操纵client端的数据以各种方式提交数据。在server端要考虑到这种行为并且做出相应的对策，对策就是分数永远只结算一次。</p>
<h2 id="实现">实现</h2><h3 id="数据库">数据库</h3><p>根据我做的项目的系统需求，有如下几个关键概念：</p>
<ul>
<li>模块（module）<br>课程分为若干个模块（module），每个模块对应一次考试。每次有限定的时间。</li>
<li>考点（test_point）<br>每个模块包括若干个考点，每次考试从考点中随机抽取题目。</li>
<li>题目(question)<br>题目都是选择题，最多四个，单选题，题干和每个选项都可能对应图片。基于题目题型是固定的，我把这些内容都放到了一个表里，如果考题类型丰富需要更灵活的设计。</li>
<li>考卷（report）<br>每次考试的考卷，上面会有分数。考卷和题目有着多对多的关系，需要一个中间表来存储。</li>
</ul>
<p>出去其他需求，考试部分的数据表简单设计如下：<br><img src="http://ww2.sinaimg.cn/mw690/4c2edcb7jw1eqw7h465uvj20pz0ibgmo.jpg" alt="enter image description here"></p>
<h3 id="考卷生成-1">考卷生成</h3><p>每个考试（模块）都对应三种状态：</p>
<ol>
<li>没有考过试的模块 ——— 对应 ——— 生成考题，去考试</li>
<li>已经开始考试还没结束的模块 ——— 对应 ——— 使用已经生成的考题，继续考试</li>
<li>已经结束的模块 ——— 对应 ——— 查看考试成绩</li>
</ol>
<p>当系统没有这个模块的report信息的时候，根据考点随机抽取题目，生成考题和report，<br>report状态变成<strong>进行中</strong>，分数还没有结算。</p>
<p>关键函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#32452;&#21367;&#65292;&#23558;&#32452;&#21367;&#30340;&#20869;&#23481;&#25918;&#20837;report&#34920;&#65292;question_in_report&#34920;&#65292;&#32452;&#21367;&#23545;&#21516;&#19968;&#20010;&#32771;&#35797;&#19981;&#20250;&#32452;&#20004;&#27425;&#10;     * @param  [type] $student_id     [description]&#10;     * @param  [type] $module_id      [description]&#10;     * @param  [type] $logic_class_id [description]&#10;     * @return [type]                 [description]&#10;     */&#10;    function get_questions($student_id,$module_id,$logic_class_id)&#10;    &#123;&#10;        /*&#38656;&#35201;&#25552;&#21069;&#20570;&#30340;&#26816;&#26597;:&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#24050;&#32463;&#22312;&#36825;&#20010;&#36923;&#36753;&#29677;&#19979;&#32771;&#36807;&#36825;&#20010;&#27169;&#22359;&#10;        &#36825;&#20010;&#21516;&#23398;&#26159;&#21542;&#26159;&#29992;&#25143;&#33258;&#24049;&#10;        &#36825;&#20010;&#23398;&#29983;&#26159;&#21542;&#23646;&#20110;&#36825;&#20010;&#36923;&#36753;&#29677;&#10;        &#36825;&#20010;&#36923;&#36753;&#29677;&#20013;&#26159;&#21542;&#26377;&#36825;&#38376;&#35838;*/&#10;        &#10;        //&#36941;&#21382;&#25152;&#26377;&#32771;&#28857;&#65292;&#20174;&#27599;&#20010;&#32771;&#28857;&#20013;&#38543;&#26426;&#25277;&#20986;&#19968;&#36947;&#39064;&#23384;&#20837;$test_questions&#10;&#10;        //&#33719;&#21462;&#24403;&#21069;&#26102;&#38388;&#10;        $datetime=date(&#34;Y-m-d H:i:s&#34;);&#10;        &#10;        //&#23558;&#32467;&#26524;&#23384;&#20837;report&#34920;&#10;        $this-&#62;report_model-&#62;add($report_item);&#10;        &#10;        //&#23558;&#32452;&#39064;&#20449;&#24687;&#20889;&#20837;question_in_report &#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="保存现场-1">保存现场</h3><p>使用一个简单的jquery ajax，异步提交用户每次点击的选项，都在后台存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function save_choose(question_id,choose)&#10;&#123;&#10;    myUrl=&#34;&#60;?php echo site_url(&#39;student_test/ajax_save_user_choose&#39;)?&#62;/&#34;+&#60;?php echo $report_id ?&#62;+&#34;/&#34;+question_id+&#34;/&#34;+choose;&#10;    $.ajax(&#123;&#10;        type:&#34;post&#34;,&#10;        url:myUrl,&#10;        success:function(resp)&#123;&#125;&#10;    &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>后台接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * &#24322;&#27493;ajax&#23384;&#20648;&#29992;&#25143;&#30340;&#36873;&#25321;&#10; * @param  [type] $report_id   [description]&#10; * @param  [type] $question_id [description]&#10; * @return [type]              [description]&#10; */&#10;function ajax_save_user_choose($report_id,$question_id,$choose)&#10;&#123;&#10;    //&#20808;&#21028;&#26029;&#26102;&#38388;&#26159;&#21542;&#27491;&#30830;     &#10;    $now=date(&#34;Y-m-d H:i:s&#34;);&#10;    $this-&#62;load-&#62;helper(&#39;compare_time&#39;);&#10;    $time_past=compare_time_of_minute($report[&#39;datetime&#39;],$now);&#10;    &#10;    if($time_past&#60;=($module[&#39;time_limit&#39;]))&#123;&#10;        //&#26356;&#26032;&#20449;&#24687;&#10;        );  &#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="断线处理-1">断线处理</h3><p>当用户掉线重新进入，需要通过比对<strong>report状态</strong>+<strong>时间</strong>，确定用户是否可以继续考试。</p>
<ul>
<li>如果report状态为结束，则不能继续考试</li>
<li>如果report状态为进行中，时间超过截止时间，不能继续考试</li>
<li>如果report状态为进行中，时间还有，继续考试</li>
</ul>
<p>继续考试通过reportid得到已经<strong>组好的试题信息</strong>，和<strong>用户的答题情况</strong>，返回数据<br>关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10;     * &#26597;&#25214;&#25968;&#25454;&#24211;&#20013;&#30340;&#24050;&#32463;&#32452;&#22909;&#21367;&#30340;&#20449;&#24687;&#10;     * @param  [type] $report_id [description]&#10;     * @return [type]            [description]&#10;     */&#10;    function get_exist_questions($report_id)&#10;    &#123;       &#10;        //&#23384;&#20648;&#25152;&#26377;&#32771;&#21367;&#39064;&#30446;&#30340;&#25968;&#32452;&#10;        $test_questions = array();&#10;        &#10;        //&#20174;question_in_report&#20013;&#26597;&#25214;&#25152;&#26377;&#28385;&#36275;&#26465;&#20214;&#30340;&#38382;&#39064;&#10;        &#10;        return $test_questions;&#10;    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="倒计时-1">倒计时</h3><p>客户端的倒计时使用js，最简单的可以使用<code>window.setInterval()</code>函数，每隔1s时间修改html的内容。结果在stackoverflow上询问倒计时解决方法的时候被“鄙视”了一下：</p>
<blockquote>
<p>You’re design is bad, you should base your time measurement using the date object. Each time a loop will get triggered, check the current date with new Date() and keep track of the last date.</p>
<p>Keep in mind that even if you set an interval of 1000ms, it doesn’t mean that on the function will get called every seconds. It only means that it will never get called before 1000ms. As Javascript runs in one thread, any blocking process may delay calling methods that will remain in the event queue (setInterval in this case).</p>
</blockquote>
<p>大体意思是<code>setInterval</code>能保证运行的时间一定比传入的参数多，但是js是单线程的，别的操作有可能会阻塞这个方法，所以最好使用<code>Date()</code>方法来比对客户端的时间。</p>
<p>所以我的实现是使用了<a href="https://github.com/tomgrohl/jCountdown" target="_blank" rel="external">jcountdown插件</a>，通过计算出截止日期，进行倒计时。方法很简单，只需要在<code>id</code>为<code>time</code>的div上使用插件里的函数就可以了。通过template可以指定显示时间的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#34;#time&#34;).countdown(&#123;&#10;            minSingularText: &#39;&#20998;&#39;,&#10;            secSingularText: &#39;&#31186;&#39;,&#10;            &#34;date&#34; : d,&#10;            template: &#34;&#60;div class=&#39;time-item&#39;&#62;&#60;strong&#62;%i %s&#60;/strong&#62;&#60;/div&#62;&#34;,&#10;            onComplete : function()&#123;$(&#34;#test&#34;).submit();&#125;&#10;        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>不管倒计时做的多么炫酷，client is client，我永远无法控制它最终怎么运行，有没有被篡改。所以，每一次用户答题提交ajax请求，以及最终提交考卷的时候，都要<strong>比对时间</strong>，只保存合理的请求。这样就保证了整个考试系统在时间上的正确性。</p>
<h3 id="结算分数-1">结算分数</h3><p>结算分数有以下几个时间点</p>
<ol>
<li>用户答题完成，提交所有数据</li>
<li>用户在时间结束时由浏览器自动提交数据</li>
<li>用户没有通过浏览器提交数据（半路关闭浏览器），下次登录时系统自动算分</li>
</ol>
<p>1,2类似，正常提交表单就可以，需要注意的是：</p>
<ol>
<li>在所有这些过程中，<strong>网络可能有延时</strong>，所以在比对用户提交的时间的时候，可以宽限一定时间。</li>
<li>提交后修改report的状态，这个操作只有一次，拒绝之后的所有修改（form的数据，ajax请求）。</li>
</ol>
<p>3对应着意外退出，时间过了才重新登录的情况。这个时候的考试状态是，<code>report</code>的状态还是进行中，但是时间已经超过。这时候通过保存现场的数据计算分数即可。</p>
<h2 id="结束语">结束语</h2><p>我通过这样的设计，完成了一个体验相对良好，逻辑上没有问题，避免了用户在时间和数据上做手脚的在线考试功能。但因为是第一次做，也许有的地方还是考虑不周全，或者有更好的设计，希望大家多多指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>现在类似于在线考试的网站层出不穷，最近在做的leetcode还有各种OJ，都让我们能够在网络上实现考试的功能。最近在做一个类似的项目，就如何完成一个体验良好的在线考试系统梳理一下自己的看法</p>
<h2 id="功能">功能</h2>]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站应对大数据量高并发的挑战]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/%E7%BD%91%E7%AB%99%E5%BA%94%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://rudy-zhang.me/2015/04/06/网站应对大数据量高并发的挑战/</id>
    <published>2015-04-06T13:12:52.000Z</published>
    <updated>2015-05-24T13:51:34.456Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使用不同的架构和解决方案。架构的改变和升级，往往意味着成本，所有没有最好的架构，只有最适合的架构。</p>
<p>应对数据量和负载的压力，可以从以下几个方面入手:</p>
<ul>
<li>硬件性能挖掘</li>
<li>数据库和存储</li>
<li>应用程序架构<br>每一个方面里都有非常多的技术</li>
</ul>
<h2 id="硬件性能挖掘">硬件性能挖掘</h2><p>硬件性能是有上限的，超过了就必须升级硬件，所以硬件是基础。</p>
<p>但是并不是一味的堆积硬件就可以了，要理解硬件的细节，如mysql的多线程写入机制，cpu寻址方式，顺序写和随机写的存储分布。不仅仅是购买硬件而已，但是核心是，理解硬件，理解系统级的处理机制，来做优化。</p>
<p>这样才能最大限度地挖掘硬件本省的性能，提供更好的服务。</p>
<h2 id="数据库和存储">数据库和存储</h2><p>大文件，或者大量的静态文件，使用静态存储，云存储</p>
<h3 id="建立恰当的索引">建立恰当的索引</h3><h3 id="数据库连接线程池缓存">数据库连接线程池缓存</h3><h3 id="分库/分表/分区">分库/分表/分区</h3><p>MySQL数据库表一般承受数据量在百万级别，再往上增长，各项性能将会出现大幅度下降，因此，当我们预见数据量会超过这个量级的时候，建议进行分库/分表/分区等操作。<br>一个主库一个从库、到一个主库多个从库、 然后到多个主库多个从库。从库做备份，或者作为读写分离的库。<br>多个库之间使用日志同步。</p>
<h3 id="拆分方式：水平拆分VS垂直拆分">拆分方式：水平拆分VS垂直拆分</h3><ul>
<li>垂直拆分 ：是指按功能模块拆分，比如可以将群组相关表和照片相关表存放在不同的数据库中，这种方式多个数据库之 间的表结构不同 。（豆瓣 的 各核心业务/模块（书籍、电影、音乐）相对独立，数据的增加速度也比较平稳。适合垂直拆分）</li>
<li>水平拆分 ：而水平拆分是将同一个表的数据进行分块保存到不同的数据库中，这些数据库中的表结构 完全相同 。</li>
</ul>
<h3 id="按索引_/_映射表对应">按索引 / 映射表对应</h3><p>建立一个索引表，保存每个用户的ID和数据库ID的对应关系，每次读写用户数据时先从这个表获取对应数据库。新用户注册后，在所有可用 的数据库中随机挑选一个为其建立索引。</p>
<h3 id="读写分离">读写分离</h3><p>读写分离，主库写，从库读。</p>
<h3 id="减少数据库写">减少数据库写</h3><p>先将修改请求生效在cache中，让外界查询显示正常，然后将这些sql修改放入到一个队列中存储起来，队列满或者每隔一段时间，合并为一个请求到数据库中更新数据库</p>
<h2 id="应用程序架构">应用程序架构</h2><h3 id="负载均衡">负载均衡</h3><p>Web负载均衡（Load Balancing），作用在Web系统的外部网络环境，简单地说就是给我们的服务器集群分配“工作任务”，而采用恰当的分配方式。对于保护处于后端的Web服务器来说，非常重要。策略有很多</p>
<h4 id="HTTP重定向">HTTP重定向</h4><p>Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。<br>应用：重定向到距离近的镜像去下载。</p>
<h4 id="反向代理负载均衡">反向代理负载均衡</h4><p>反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。把HTTP请求分配道不同的服务器上</p>
<h4 id="IP负载均衡">IP负载均衡</h4><p>IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。这种方式，也被称为“四层负载均衡”。</p>
<h4 id="DNS负载均衡">DNS负载均衡</h4><p>DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。</p>
<h4 id="DNS/GSLB负载均衡">DNS/GSLB负载均衡</h4><p>我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在<strong>同一个域名映射为多IP</strong>的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。<strong>一般情况下都是按照地理位置，将离用户近的IP返回给用户</strong>，减少网络传输中的路由节点之间的跳跃消耗。<br><strong>应用</strong>：CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。</p>
<h3 id="在Web服务器和数据库之间建立缓存">在Web服务器和数据库之间建立缓存</h3><p>80%的请求只关注在20%的热点数据上。因此，我们应该建立Web服务器和数据库之间的缓存机制。用磁盘作为缓存，也可以用内存缓存的方式。通过它们，<strong>将大部分的热点数据查询，阻挡在数据库之前</strong>。 </p>
<h4 id="页面静态化">页面静态化</h4><p>页面上的大部分内容在很长一段时间内，可能都是没有变化的。生成的静态html页面缓存到Web服务器的磁盘本地。直接将本地磁盘文件返回给用户。</p>
<h4 id="单台/集群内存缓存">单台/集群内存缓存</h4><p>一旦Web系统规模变大，例如当我有100台的Web服务器的时候。那样这些磁盘文件，将会有100份，这个是资源浪费，也不好维护。这个时候有人会想，可以集中一台服务器存起来<br>内存缓存的选择，主要有<strong>redis/memcache</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是网站关于应对数据量和负载的压力的调研。</p>
<p>随着网站数据量和请求的增加，系统承受的压力会越来越大。在web服务的各个阶段，都要通过各种各样的方式来进行优化，或者改变为新的架构。在数据量不同的阶段，会遇到不同的问题，需要使]]>
    </summary>
    
      <category term="web开发" scheme="http://rudy-zhang.me/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 1 Two Sum]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%861/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集1/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:55:06.389Z</updated>
    <content type="html"><![CDATA[<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>题意：找vector中的两个数，和为target</p>
<p>思路：</p>
<ol>
<li><p>两重循环遍历，复杂度O(n^2)</p>
</li>
<li><p>先排序，标记left，right，扫描一遍即可，复杂度O(nlogn)</p>
</li>
<li><p>空间换时间,每次访问一个数记下这个数的index和值，使用hash表存储，下次需要的时候直接取出来复杂度O(n)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    vector&#60;int&#62; twoSum(vector&#60;int&#62; &#38;numbers, int target) &#123;&#10;&#9;&#9;vector&#60;int&#62; vec;&#10;&#9;&#9;unordered_map&#60;int,int&#62; hash;&#10;&#9;&#9;for(int i=0;i&#60;numbers.size();i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;int numToFind=target-numbers[i];&#10;&#9;&#9;&#9;if(hash.find(numToFind)!=hash.end())&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;vec.push_back(hash[numToFind]+1);&#10;&#9;&#9;&#9;&#9;vec.push_back(i+1);&#10;&#9;&#9;&#9;&#9;return vec;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;&#9;hash[numbers[i]]=i;&#10;&#9;&#9;&#125;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return ]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 100 Same Tree]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86100/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集100/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:55:12.186Z</updated>
    <content type="html"><![CDATA[<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<p>题意：给定两个二叉树，判断两个二叉树是不是一样的（树结构相同，节点值相同）</p>
<p>思路：</p>
<ol>
<li>先序中序递归遍历，如果两个序列都相等，则一定相同</li>
<li>先序递归遍历</li>
<li>先序非递归</li>
<li>层次遍历</li>
</ol>
<p>先序递归遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isSameTree(TreeNode *p, TreeNode *q) &#123;&#10;&#9;if(NULL==p &#38;&#38; NULL==q) return true;&#10;&#9;if(NULL==p &#38;&#38; NULL!=q) return false;&#10;&#9;if(NULL!=p &#38;&#38; NULL==q) return false;&#10;&#9;if(p-&#62;val != q-&#62;val) return false;&#10;&#9;return (isSameTree(p-&#62;left,q-&#62;left)&#38;&#38;isSameTree(p-&#62;right,q-&#62;right));&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>层次遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * Definition for binary tree&#10; * struct TreeNode &#123;&#10; *     int val;&#10; *     TreeNode *left;&#10; *     TreeNode *right;&#10; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#10; * &#125;;&#10; */&#10;class Solution &#123;&#10;public:&#10;    /*bool isSameTree(TreeNode *p, TreeNode *q) &#123;&#10;        if(NULL==p &#38;&#38; NULL==q) return true;&#10;        if(NULL==p &#38;&#38; NULL!=q) return false;&#10;        if(NULL!=p &#38;&#38; NULL==q) return false;&#10;        if(p-&#62;val != q-&#62;val) return false;&#10;        return (isSameTree(p-&#62;left,q-&#62;left)&#38;&#38;isSameTree(p-&#62;right,q-&#62;right));&#10;    &#125;*/&#10;    bool isSameTree(TreeNode *p, TreeNode *q) &#123;&#10;        queue&#60;TreeNode *&#62; queue1,queue2;&#10;        if(NULL == p &#38;&#38; NULL==q) return true;&#10;        if(NULL != p &#38;&#38; NULL==q) return false;&#10;        if(NULL == p &#38;&#38; NULL!=q) return false;&#10;        queue&#60;TreeNode *&#62; q1,q2;&#10;        q1.push(p);&#10;        q2.push(q);&#10;        TreeNode *n1,*n2;&#10;        while(!q1.empty() &#38;&#38; !q2.empty())&#10;        &#123;&#10;            n1=q1.front();&#10;            q1.pop();&#10;            n2=q2.front();&#10;            q2.pop();&#10;            if(NULL==n1 &#38;&#38; NULL==n2)&#10;                continue;&#10;            if(NULL==n1 &#38;&#38; NULL!=n2)&#10;                return false;&#10;            if(NULL!=n1 &#38;&#38; NULL==n2)&#10;                return false;&#10;            if(n1-&#62;val != n2-&#62;val)&#10;                return false;&#10;            q1.push(n1-&#62;left);&#10;            q1.push(n1-&#62;right);&#10;            q2.push(n2-&#62;left);&#10;            q2.push(n2-&#62;right);&#10;        &#125;&#10;        if(!(q1.empty()&#38;&#38;q2.empty()))&#10;            return false;&#10;        return true;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are stru]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 14 Longest Common Prefix  ]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8614/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集14/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:56:13.443Z</updated>
    <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>题意：找出一组字符串的最长相同前缀</p>
<p>思路：</p>
<p>找出strs最小长度，遍历即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;//&#25214;&#20986;&#26368;&#23567;&#38271;&#24230;&#10;    string longestCommonPrefix(vector&#60;string&#62; &#38;strs) &#123;&#10;        string prefix;&#10;        if(strs.size()==0) return prefix;&#10;        int minLength=strs[0].size();&#10;        for(int i=0;i&#60;strs.size();i++)&#10;        &#123;&#10;            if(strs[i].size()&#60;minLength)&#10;                minLength=strs[i].size();&#10;        &#125;&#10;        &#10;        for(int j=0;j&#60;minLength;j++)&#10;        &#123;&#10;            for(int i=0;i&#60;strs.size()-1;i++)&#10;            &#123;&#10;                if(strs[i][j]!=strs[i+1][j]) return prefix;&#10;            &#125;&#10;            prefix+=strs[0][j];&#10;        &#125;&#10;        return prefix;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>题意：找出一组字符串的最长相同前缀</p>
<p>思路：</p>
<p>找出strs最]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 92 Reverse Linked List II ]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8692/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集92/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:57.894Z</updated>
    <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<p>题意：反转一个链表的指定部分</p>
<p>思路：</p>
<ol>
<li>将原始链表分为三个部分part1,2,3翻转part2部分到新链表然后连接起来</li>
<li>p1,p2在reverse部分的前一个节点和最后一个节点停下，翻转，注意考虑前后为空的处理</li>
</ol>
<p>注意：<br>可以相信mn的值，但是也要判断一下，头结点和空节点的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;//&#24605;&#36335;&#65306;&#23558;&#21407;&#22987;&#38142;&#34920;&#20998;&#20026;&#19977;&#20010;&#37096;&#20998;part1,2,3&#32763;&#36716;part2&#37096;&#20998;&#21040;&#26032;&#38142;&#34920;&#28982;&#21518;&#36830;&#25509;&#36215;&#26469;&#10;//&#27880;&#24847;&#65306;&#21487;&#20197;&#30456;&#20449;mn&#30340;&#20540;&#65292;&#20294;&#26159;&#20063;&#35201;&#21028;&#26029;&#19968;&#19979;&#65292;&#22836;&#32467;&#28857;&#21644;&#31354;&#33410;&#28857;&#30340;&#22788;&#29702;&#10;//&#24605;&#36335;2&#65306;p1,p2&#22312;reverse&#37096;&#20998;&#30340;&#21069;&#19968;&#20010;&#33410;&#28857;&#21644;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#20572;&#19979;&#65292;&#32763;&#36716;&#65292;&#27880;&#24847;&#32771;&#34385;&#21069;&#21518;&#20026;&#31354;&#30340;&#22788;&#29702;&#10;    ListNode *reverseBetween(ListNode *head, int m, int n) &#123;&#10;        ListNode *part1head=head,*node=head;&#10;        ListNode *part1tail=NULL,*part2head=NULL,*part2tail=NULL,*part3head=NULL;&#10;        if(m==n) return head;&#10;        if(m==1)&#10;        &#123;&#10;            part1head=part1tail=NULL;&#10;&#9;&#9;&#9;part2head=head;&#10;        &#125;&#10;&#9;&#9;else&#10;&#9;&#9;&#123;&#10;&#9;&#9;    //&#21028;&#26029;&#30340;&#26102;&#20505;&#20986;&#29616;&#20102;&#38169;&#35823;&#65292;&#24212;&#35813;&#20174;1&#24320;&#22987;&#21040;m-1&#10;&#9;&#9;&#9;for(int i=1;i&#60;m-1&#38;&#38;node-&#62;next!=NULL;i++)&#10;&#9;&#9;&#9;&#9;node=node-&#62;next;&#10;&#9;&#9;&#9;part1tail=node;&#10;&#9;&#9;&#9;node=node-&#62;next;&#10;&#9;&#9;&#9;part2head=node;&#10;&#9;&#9;&#125;&#10;        &#10;        for(int i=0;i&#60;n-m&#38;&#38;node-&#62;next!=NULL;i++)&#10;            node=node-&#62;next;&#10;        part2tail=node;&#10;        if(node-&#62;next==NULL)&#10;            part3head=NULL;&#10;        else&#10;        &#123;&#10;            part3head=node-&#62;next;&#10;            node-&#62;next=NULL;&#10;        &#125;&#10;        ListNode *revhead=NULL,*revtail=NULL;&#10;        node=part2head;&#10;        ListNode *tnode=node-&#62;next;&#10;        node-&#62;next=revhead;&#10;        revhead=node;&#10;        revtail=revhead;&#10;        node=tnode;&#10;        while(node)&#10;        &#123;&#10;            tnode=node-&#62;next;&#10;            node-&#62;next=revhead;&#10;            revhead=node;&#10;            node=tnode;&#10;        &#125;&#10;        if(part1head)&#10;        &#123;&#10;            part1tail-&#62;next=revhead;&#10;            revtail-&#62;next=part3head;&#10;            return part1head;&#10;        &#125;&#10;        else&#10;        &#123;&#10;            revtail-&#62;next=part3head;&#10;            return revhead;&#10;        &#125;&#10;        &#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 9 Palindrome Number]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%869/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集9/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:54.976Z</updated>
    <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>click to show spoilers.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
<p>题意：判断一个整数是不是回文数</p>
<p>思路：</p>
<ol>
<li>和反转整数的思路一样，反转到一半进行比较（其实反转到比较能相等就可以了）。需要考虑比较多的是测试用例的情况</li>
</ol>
<p>注意：</p>
<ol>
<li>负数都不是回文数</li>
<li>10的倍数不能当做回文数，计算时翻转0就消失了</li>
<li>当然0是回文数</li>
<li>整数变化问题都要考虑是否越界,翻转其实只需要做到一半比较就可以了</li>
<li>考虑中间有一位，和中间有两位的情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public:&#10;    bool isPalindrome(int x) &#123;&#10;        if(x==0) return true;&#10;        if(x&#60;0 || (x%10==0)) return false;&#10;        int y=0;&#10;        while(y&#60;x)&#10;        &#123;&#10;            y=y*10+x%10;&#10;            if(x==y) return true;&#10;            x/=10;&#10;            if(x==y) return true;&#10;        &#125;&#10;        return (x==y);&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>click to show spoilers.</p>
<p>Some hints:<br>Could neg]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 88 Merge Sorted Array ]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8688/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集88/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:52.129Z</updated>
    <content type="html"><![CDATA[<p>Given two sorted integer arrays A and B, merge B into A as one sorted array.</p>
<p>Note:<br>You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.</p>
<p>题意：给两个有序数组，合并成一个</p>
<p>思路：模拟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    void merge(int A[], int m, int B[], int n) &#123;&#10;        int i=m-1,j=n-1,k=m+n-1;&#10;&#9;&#9;while(i&#62;=0&#38;&#38;j&#62;=0)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;if(A[i]&#62;=B[j])&#10;&#9;&#9;&#9;&#123; &#10;&#9;&#9;&#9;&#9;A[k--]=A[i];&#10;&#9;&#9;&#9;&#9;i--;&#9;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;A[k--]=B[j];&#10;&#9;&#9;&#9;&#9;j--;&#10;&#9;&#9;&#9;&#125; &#10;&#9;&#9;&#125;&#10;&#9;&#9;if(j&#62;=0)&#10;&#9;&#9;&#9;for(;k&#62;=0;k--)&#10;&#9;&#9;&#9;&#9;A[k]=B[k];&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Given two sorted integer arrays A and B, merge B into A as one sorted array.</p>
<p>Note:<br>You may assume that A has enough space (size]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 83 Remove Duplicates from Sorted List]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8683/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集83/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:48.976Z</updated>
    <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
<p>题意：给一个链表，删除链表中的重复元素</p>
<p>思路：两个指针，遍历，模拟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**&#10; * Definition for singly-linked list.&#10; * struct ListNode &#123;&#10; *     int val;&#10; *     ListNode *next;&#10; *     ListNode(int x) : val(x), next(NULL) &#123;&#125;&#10; * &#125;;&#10; */&#10;class Solution &#123;&#10;public:&#10;//&#36890;&#36807;&#20004;&#20010;&#25351;&#38024;&#21516;&#26102;&#21521;&#21069;&#31227;&#21160;&#21024;&#38500;&#20803;&#32032;&#10;//&#27880;&#24847;&#65306;&#20026;&#31354;&#65292;&#19968;&#20010;&#20803;&#32032;&#65292;&#22810;&#20010;&#20803;&#32032;&#65292;&#23614;&#20803;&#32032;&#10;    ListNode *deleteDuplicates(ListNode *head) &#123;&#10;        if(NULL == head || NULL==head-&#62;next)&#10;            return head;&#10;        ListNode *n1=head;&#10;        ListNode *n2=head-&#62;next;&#10;        while(n2)&#10;        &#123;&#10;            if(n1-&#62;val == n2-&#62;val)&#10;            &#123;&#10;                ListNode *toBeDelete;&#10;                toBeDelete=n2;&#10;                n1-&#62;next=n2-&#62;next;&#10;                n2=n1-&#62;next;&#10;                delete toBeDelete;&#10;            &#125;&#10;            else&#10;            &#123;&#10;                n1=n1-&#62;next;&#10;                n2=n2-&#62;next;&#10;            &#125;&#10;        &#125;&#10;        return head;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given <code>1-&gt;1-&gt]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 8 String to Integer (atoi) ]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%868/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集8/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:43.417Z</updated>
    <content type="html"><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p>spoilers alert… click to show requirements for atoi.</p>
<p>Requirements for atoi:<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>
<p>题意：实现C++库函数（在cstdlib中）atoi，转化string为整数</p>
<p>思路：</p>
<ol>
<li>开头可能是正负号，然后以数字的字符开始，到第一个不是数字字符结束，忽略后面的内容。如果字符串不合法，返回0；</li>
</ol>
<p>注意：</p>
<ol>
<li><p>处理开头为空的情况</p>
</li>
<li><p>开头有可能是负号,正号</p>
</li>
<li><p>注意测试用例完备，超过int_max小于int_min</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    int atoi(string str) &#123;&#10;        int emptyIndex=0;&#10;        while(str[emptyIndex]==&#39; &#39;) emptyIndex++;&#10;        str=str.substr(emptyIndex);&#10;        &#10;        bool isneg=false;&#10;        if(!isNum(str[0]) &#38;&#38; str[0]!=&#39;-&#39; &#38;&#38; str[0]!=&#39;+&#39;) return 0;&#10;        if(str[0]==&#39;-&#39;)&#10;        &#123;&#10;          isneg=true;&#10;          str=str.substr(1);&#10;        &#125; &#10;        else if(str[0]==&#39;+&#39;)&#10;            str=str.substr(1);&#10;        long long num=0;&#10;        for(int i=0;isNum(str[i]);i++)&#10;        &#123;&#10;            num=num*10+(str[i]-&#39;0&#39;);&#10;            if(isneg==false&#38;&#38;num&#62;INT_MAX) return INT_MAX;&#10;            if(isneg==true&#38;&#38;(0-num)&#60;INT_MIN) return INT_MIN;&#10;        &#125;&#10;        if(isneg==true) return (int)(0-num);&#10;        else return (int)num;&#10;        &#10;    &#125;&#10;    &#10;    bool isNum(char a)&#10;    &#123;&#10;        if((a-&#39;0&#39;)&#62;=0 &#38;&#38; (a-&#39;0&#39;)&#60;10)&#10;            return 1;&#10;        else return 0;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, plea]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 73 Set Matrix Zeroes]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8673/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集73/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:40.407Z</updated>
    <content type="html"><![CDATA[<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>click to show follow up.</p>
<p>Follow up:<br>Did you use extra space?<br>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<p>题意：给定一个m*n的矩阵，如果有一个元素等于0，那么这个元素属于的行和列都变成0</p>
<p>思路：</p>
<ol>
<li>使用另外的存储m*n矩阵记录遍历结果，不太好</li>
<li>使用M+N的存储记录遍历结果，指示第M[i]行和第N[j]列是否被置0</li>
<li>使用row0，col0记录第一行，第一列的状态，然后把matrix[i][j]映射到第一行第一列，然后遍历，根据第一行，第一列的情况为矩阵置0，处理第一行第一列。使用了常数存储，两次遍历。</li>
</ol>
<p>M+N存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    void setZeroes(vector&#60;vector&#60;int&#62; &#62; &#38;matrix) &#123;&#10;        vector&#60;bool&#62; vecM(matrix.size(),false);&#10;&#9;&#9;vector&#60;bool&#62; vecN(matrix[0].size(),false);&#10;&#9;&#9;for(int i=0;i&#60;matrix.size();i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;for(int j=0;j&#60;matrix[i].size();j++)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;if(matrix[i][j]==0)&#123;&#10;&#9;&#9;&#9;&#9;&#9;vecM[i]=true;&#10;&#9;&#9;&#9;&#9;&#9;vecN[j]=true;&#10;&#9;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#125; &#10;&#9;&#9;for(int i=0;i&#60;vecM.size();i++)&#10;&#9;&#9;&#9;if(vecM[i]==true)&#10;&#9;&#9;&#9;&#9;for(int j=0;j&#60;matrix[i].size();j++)&#10;&#9;&#9;&#9;&#9;&#9;matrix[i][j]=0;&#10;&#9;&#9;for(int i=0;i&#60;vecN.size();i++)&#10;&#9;&#9;&#9;if(vecN[i]==true)&#10;&#9;&#9;&#9;&#9;for(int j=0;j&#60;matrix.size();j++)&#10;&#9;&#9;&#9;&#9;&#9;matrix[j][i]=0;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>常数存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;    void setZeroes(vector&#60;vector&#60;int&#62; &#62; &#38;matrix) &#123;&#10;        int col0=0,row0=0,rows = matrix.size(), cols = matrix[0].size();&#10;&#10;&#9;&#9;for(int j=0;j&#60;cols;j++)&#10;&#9;&#9;&#9;if(matrix[0][j]==0) row0=1;&#10;&#10;&#9;&#9;for(int i=0;i&#60;rows;i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;if(matrix[i][0]==0) col0=1;&#10;&#9;&#9;&#9;for(int j=0;j&#60;cols;j++)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;if(matrix[i][j]==0) &#10;&#9;&#9;&#9;&#9;&#9;matrix[i][0]=matrix[0][j]=0;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#125;&#10;&#9;&#9;for(int i=1;i&#60;rows;i++)&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;for(int j=1;j&#60;cols;j++)&#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;if(matrix[i][0]==0||matrix[0][j]==0) &#10;&#9;&#9;&#9;&#9;&#9;matrix[i][j]=0;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#125;&#10;&#9;&#9;if(col0==1)&#10;&#9;&#9;&#9;for(int i=0;i&#60;rows;i++)&#10;&#9;&#9;&#9;&#9;matrix[i][0]=0;&#10;&#9;&#9;if(row0==1)&#10;&#9;&#9;&#9;for(int j=0;j&#60;cols;j++)&#10;&#9;&#9;&#9;&#9;matrix[0][j]=0;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>click to show follow up.</p>
<p>Foll]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 70 Climbing Stairs]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8670/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集70/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:37.696Z</updated>
    <content type="html"><![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>题意：爬楼梯，每次可以爬一步或者两步，爬到第n阶台阶有几种方法</p>
<p>思路：<br>类似于斐波那契数列，f(n)=f(n-1)+f(n-2),使用a[n]空间换时间，否则递归太多容易爆栈<br>实际上这是一个动态规划问题</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;//&#31867;&#20284;&#20110;&#26000;&#27874;&#37027;&#22865;&#25968;&#21015;&#65292;f(n)=f(n-1)+f(n-2),&#20351;&#29992;a[n]&#31354;&#38388;&#25442;&#26102;&#38388;&#65292;&#21542;&#21017;&#36882;&#24402;&#22826;&#22810;&#23481;&#26131;&#29190;&#26632;&#10;    int climbStairs(int n) &#123;&#10;        int *a=new int[n+1];&#10;        for(int i=0;i&#60;n+1;i++)&#10;            a[i]=0;&#10;        a[1]=1;&#10;        a[2]=2;&#10;        count(a,n);&#10;    &#125;&#10;    &#10;    int count(int a[],int n)&#10;    &#123;&#10;        if(a[n]!=0) return a[n];&#10;        else &#10;        &#123;&#10;            int num=count(a,n-1)+count(a,n-2);&#10;            a[n]=num;&#10;            return num;&#10;        &#125;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many dist]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 7 Reverse Integer]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%867/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集7/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:34.428Z</updated>
    <content type="html"><![CDATA[<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>click to show spoilers.</p>
<p>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<p>Update (2014-11-10):<br>Test cases had been added to test the overflow behavior.</p>
<p>题意：整数反转</p>
<p>思路：</p>
<ol>
<li>%10，然后一位一位往上加</li>
</ol>
<p>注意：</p>
<p>这题有个陷阱，反转整数可能出现整数溢出的情况，要考虑到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;//&#22238;&#25991;&#25972;&#25968;&#38382;&#39064;&#10;    int reverse(int x) &#123;&#10;        long long int ans=0;&#10;        while(x)&#10;        &#123;&#10;            ans=ans*10+x%10;//&#36825;&#37324;&#19981;&#33021;&#20889;&#25104;ans+=ans*10+x%10&#10;            x/=10;&#10;        &#125;&#10;        if(ans&#62;INT_MAX||ans&#60;INT_MIN) return 0;&#10;        else return ans;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>click to show spoilers.</p>
]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode习题集 67 Add Binary ]]></title>
    <link href="http://rudy-zhang.me/2015/04/06/leetcode%E4%B9%A0%E9%A2%98%E9%9B%8667/"/>
    <id>http://rudy-zhang.me/2015/04/06/leetcode习题集67/</id>
    <published>2015-04-06T07:31:44.000Z</published>
    <updated>2015-05-24T08:57:09.894Z</updated>
    <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = <code>&quot;11&quot;</code><br>b = <code>&quot;1&quot;</code><br>Return <code>&quot;100&quot;</code>.</p>
<p>题意：给定一个int的vector，给这个数字加上1，返回最终的数字</p>
<p>思路：模拟</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;&#10;public:&#10;//&#24605;&#36335;1&#65306;stoi&#36716;&#21270;&#20026;&#25972;&#25968;&#65292;&#36716;&#25442;&#36827;&#20301;&#65292;itos&#36716;&#21270;&#20026;&#23383;&#31526;&#20018;&#65292;&#27604;&#36739;&#22797;&#26434;&#10;//&#24605;&#36335;2&#65306;&#30452;&#25509;&#20351;&#29992;&#23383;&#31526;&#20174;&#21518;&#21521;&#21069;&#21152;&#65292;carry&#35760;&#24405;&#10;//&#24212;&#35813;&#20808;&#34917;&#40784;&#30701;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230;&#10;//&#25968;&#25454;&#65306;&#23383;&#31526;&#20018;&#20026;&#31354;&#65292;&#23383;&#31526;&#20018;&#39318;&#20301;&#26377;&#36827;&#20301;&#10;    string addBinary(string a, string b) &#123;&#10;        if(a.size()==0) return b;&#10;        if(b.size()==0) return a;&#10;        string ans;&#10;        int carry=0;&#10;        int i=a.size()-1,j=b.size()-1;&#10;        for(;i&#62;=0&#38;&#38;j&#62;=0;i--,j--)&#10;        &#123;&#10;            ans=add(a[i],b[j],carry)+ans;&#10;        &#125;&#10;        string sub;&#10;        if(i&#62;=0)&#10;            sub=a.substr(0,i+1);&#10;        else if(j&#62;=0)&#10;            sub=b.substr(0,j+1);&#10;        else&#10;            sub=&#34;&#34;;&#10;        if(carry==0)&#10;            return (sub+ans);&#10;        else if(carry==1 &#38;&#38; i&#60;0 &#38;&#38; j&#60;0)&#10;            return (&#39;1&#39;+ans);&#10;        else &#10;        &#123;&#10;            for(int k=sub.size()-1;k&#62;=0;k--)&#10;            &#123;&#10;                ans=add(&#39;0&#39;,sub[k],carry)+ans;&#10;            &#125;    &#10;            if(carry==1)&#10;                return (&#39;1&#39;+ans);&#10;            else&#10;                return ans;&#10;            &#10;        &#125;&#10;        &#10;    &#125;&#10;    &#10;    char add(char a,char b,int &#38;carry)&#10;        &#123;&#10;            if(a==&#39;0&#39;&#38;&#38;b==&#39;0&#39;) &#10;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;if(carry==1) &#10;&#9;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;&#9;carry=0;&#10;&#9;&#9;&#9;&#9;&#9;return &#39;1&#39;;&#10;&#9;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;&#9;else return &#39;0&#39;;&#10;&#9;&#9;&#9;&#125;&#10;            if((a==&#39;0&#39;&#38;&#38;b==&#39;1&#39;)||(a==&#39;1&#39;&#38;&#38;b==&#39;0&#39;)) &#10;            &#123;&#10;                if(carry==0) return &#39;1&#39;;&#10;                if(carry==1)&#10;                &#123;&#10;                    carry==1;&#10;                    return &#39;0&#39;;&#10;                &#125;&#10;            &#125;&#10;            if(a==&#39;1&#39;&#38;&#38;b==&#39;1&#39;)&#10;            &#123;&#10;                if(carry==0)&#10;                &#123;&#10;                    carry=1;&#10;                    return &#39;0&#39;;&#10;                &#125;&#10;                if(carry==1)&#10;                &#123;&#10;                    carry=1;&#10;                    return &#39;1&#39;;&#10;                &#125;&#10;            &#125;&#10;            &#10;        &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = <code>&quot;11&quot;</code><br>b = <code>&q]]>
    </summary>
    
      <category term="leetcode习题集" scheme="http://rudy-zhang.me/tags/leetcode%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
      <category term="算法" scheme="http://rudy-zhang.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>